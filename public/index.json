
[{"content":"","date":"10 November 2025","externalUrl":null,"permalink":"/achievements/","section":"Achievements","summary":"","title":"Achievements","type":"achievements"},{"content":"","date":"10 November 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"10 November 2025","externalUrl":null,"permalink":"/","section":"Deadnaut","summary":"","title":"Deadnaut","type":"page"},{"content":"","date":"10 November 2025","externalUrl":null,"permalink":"/categories/participation/","section":"Categories","summary":"","title":"Participation","type":"categories"},{"content":"üöÄ Proud to Announce Our Victory at the INSIGHT Hackathon 2025!\nI‚Äôm incredibly proud to share that my team Cteam and I won the INSIGHT Hackathon 2025, a 24-hour cybersecurity and innovation challenge organized by IEEE SB ESPRIM.\nThis event was an intense mix of problem-solving, creativity, and teamwork ‚Äî and pushing through every stage with my teammates made this achievement even more meaningful.\nüí° We built a solution that combined technical depth, fast decision-making, and a lot of resilience.\nü§ù Huge respect to all the participating teams for their impressive projects.\nüôå And a special thanks to the organizing team for an amazing event full of energy and inspiration.\nThis experience reinforced my passion for cybersecurity and collaborative innovation.\n","date":"10 November 2025","externalUrl":null,"permalink":"/achievements/insight-hackthon/","section":"Achievements","summary":"","title":"Victory at the INSIGHT Hackathon 2025","type":"achievements"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/categories/position/","section":"Categories","summary":"","title":"Position","type":"categories"},{"content":"I‚Äôm happy to share that I‚Äôve held a dual role at Pwn \u0026amp; Patch, working as both a Ruby on Rails developer and a Cyber Security intern. During this experience, I contributed to secure application development, vulnerability assessment, and hands-on debugging while strengthening my skills across backend engineering and offensive security practices.\n","date":"23 September 2025","externalUrl":null,"permalink":"/achievements/pwn-and-patch-internship/","section":"Achievements","summary":"","title":"Pwn \u0026 Patch Internship","type":"achievements"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/tags/ruby-on-rails/","section":"Tags","summary":"","title":"Ruby on Rails","type":"tags"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"üéâ I\u0026rsquo;m excited to share that I‚Äôve officially earned my CCNA (Cisco Certified Network Associate) certification! üèÖ Looking forward to applying this knowledge and growing further in the field of IT and networking. üöÄ\nYou can view or visit link below:\nVisit link\n","date":"20 May 2025","externalUrl":null,"permalink":"/achievements/ccna-introduction-to-networks/","section":"Achievements","summary":"","title":"CCNA: Introduction to Networks","type":"achievements"},{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/categories/certificate/","section":"Categories","summary":"","title":"Certificate","type":"categories"},{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/tags/network/","section":"Tags","summary":"","title":"Network","type":"tags"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/categories/blog/","section":"Categories","summary":"","title":"Blog","type":"categories"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/","section":"Blog","summary":"","title":"Cryptography","type":"blog"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"Cryptography","type":"tags"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/","section":"Blog","summary":"","title":"Cybersecurity","type":"blog"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/tags/cybersecurity/","section":"Tags","summary":"","title":"Cybersecurity","type":"tags"},{"content":" Introduction # In today‚Äôs digital world, protecting sensitive data is more important than ever. One of the most popular methods for secure communication is RSA encryption, a public-key cryptosystem that allows secure data exchange without sharing a secret key beforehand. In this blog, we‚Äôll break down how RSA works in an easy-to-understand way and demonstrate its use in C with practical code examples.\nWhat Is RSA Encryption? # RSA encryption is based on a pair of keys ‚Äî a public keyand a private key:\nPublic Key: Used to encrypt messages. It can be freely shared. Private Key: Used to decrypt messages. It must be kept secret. The beauty of RSA lies in its asymmetric nature: anyone can encrypt a message using the public key, but only the holder of the private key can decrypt it. This makes RSA ideal for scenarios where secure key exchange is challenging.\nHow Does RSA Work? # RSA relies on mathematical properties of large prime numbers:\nKey Generation: Two large prime numbers are chosen and multiplied together to create a modulus. The public and private keys are derived from this modulus and another number called the public exponent.\nEncryption: The sender uses the recipient‚Äôs public key to encrypt the message, transforming it into an unreadable format.\nDecryption: The recipient uses their private key to convert the ciphertext back into the original message.\nThis process ensures that even if someone intercepts the encrypted data, they cannot decipher it without the private key.\nUnderstanding the Mathematics Behind RSA Key Generation # RSA encryption is built upon fundamental principles of number theory. Here‚Äôs a simplified look at the math that underpins RSA:\nKey Generation # Two large prime numbers, p and q, are chosen and multiplied together to form the modulus:\nn=p√óq The totient of n is calculated as: œï(n)=(p‚àí1)√ó(q‚àí1)\nPublic and Private Keys # The public key is made up of (n, e), where e is a public exponent (often chosen as 65537 for efficiency and security). The private key is a number d that satisfies the following equation:\ne√ód‚â°1 mod œï(n)\nIn other words, d is the modular inverse of e modulo œï(n).\nThe Challenge of Deriving the Private Key # To calculate d, one must know œï(n), which in turn requires knowing the prime factors p and q of n. For sufficiently large primes, factoring n into p and q is computationally infeasible with current technology. This is why, despite knowing n and e (the public key), it is practically impossible to derive d (the private key) without breaking the underlying hard problem of integer factorization.\nExtended Euclidean Algorithm # In theory, if you could factor n and determine œï(n), you would use the Extended Euclidean Algorithm to compute d as the modular inverse of e modulo œï(n):\nd=e^{‚àí1}mod√óœï(n)\nWhy You Can‚Äôt Derive the Private Key from the Public Key # In RSA, the public key is made up of a large number and an exponent, while the private key is mathematically linked to these values. However, obtaining the private key from the public key requires figuring out two secret prime numbers that were used to generate the large number. This process, known as factoring, is extremely difficult and practically impossible with current technology. As a result, even though the public key is shared openly, the private key remains secure.\nImplementing RSA Encryption in C # Below is a practical example demonstrating how to generate RSA keys in memory, encrypt a message using the public key, and then decrypt it using the private key. We use OpenSSL libraries to simplify cryptographic operations.\nRSA Encryption \u0026amp; Decryption Code Example\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/rsa.h\u0026gt; #include \u0026lt;openssl/pem.h\u0026gt; #include \u0026lt;openssl/err.h\u0026gt; int main() { int ret = 0; RSA *rsa = NULL; BIGNUM *bn = NULL; unsigned char *encrypted = NULL; unsigned char *decrypted = NULL; int encrypted_length, decrypted_length; // Step 1: Generate RSA Keys bn = BN_new(); BN_set_word(bn, RSA_F4); // RSA_F4 == 0x10001 rsa = RSA_new(); if (RSA_generate_key_ex(rsa, 2048, bn, NULL) != 1) { ERR_print_errors_fp(stderr); return 1; } // Step 2: Define the message to encrypt unsigned char message[] = \u0026#34;Hello RSA Encryption!\u0026#34;; int message_len = strlen((char *)message) + 1; // include null terminator // Allocate memory for encrypted and decrypted data int rsa_size = RSA_size(rsa); encrypted = malloc(rsa_size); decrypted = malloc(rsa_size); // Step 3: Encrypt the message using the public key encrypted_length = RSA_public_encrypt(message_len, message, encrypted, rsa, RSA_PKCS1_OAEP_PADDING); if(encrypted_length == -1) { ERR_print_errors_fp(stderr); return 1; } printf(\u0026#34;Encrypted message (in hex):\\n\u0026#34;); for (int i = 0; i \u0026lt; encrypted_length; i++) { printf(\u0026#34;%02x\u0026#34;, encrypted[i]); } printf(\u0026#34;\\n\\n\u0026#34;); // Step 4: Decrypt the message using the private key decrypted_length = RSA_private_decrypt(encrypted_length, encrypted, decrypted, rsa, RSA_PKCS1_OAEP_PADDING); if(decrypted_length == -1) { ERR_print_errors_fp(stderr); return 1; } printf(\u0026#34;Decrypted message: %s\\n\u0026#34;, decrypted); // Cleanup: Free allocated resources RSA_free(rsa); BN_free(bn); free(encrypted); free(decrypted); return 0; } Explanation of the Code:\nKey Generation: We generate a 2048-bit RSA key pair using RSA_generate_key_ex(). A BIGNUM (bn) is used to set the public exponent, commonly set to RSA_F4.\nEncryption: The RSA_public_encrypt() function encrypts the plaintext message using the public key. We use RSA_PKCS1_OAEP_PADDING to ensure robust security through proper padding.\nDecryption: The RSA_private_decrypt() function decrypts the ciphertext back into plaintext using the private key and the same padding scheme.\nOutput: The encrypted message is displayed in hexadecimal format, and the decrypted message is printed as a string.\nApplications of RSA Encryption # RSA encryption is widely used in:\nSecure Communications: Establishing secure connections over the Internet (e.g., SSL/TLS). Digital Signatures: Verifying the authenticity and integrity of digital messages. Key Exchange: Securely exchanging keys for symmetric encryption algorithms. Its role in ensuring that data remains confidential and authentic makes RSA an essential tool in modern cybersecurity.\nFinal Thoughts # RSA encryption simplifies secure communication by eliminating the need to share private keys. With its robust mathematical foundation, RSA continues to be a cornerstone in protecting sensitive data. By leveraging libraries like OpenSSL, you can integrate RSA encryption into your C applications with ease.\n","date":"28 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/understanding-rsa-encryption/","section":"Blog","summary":"","title":"Understanding RSA Encryption: A Simple Guide Using C","type":"blog"},{"content":" Introduction # In today‚Äôs interconnected digital landscape, ensuring that a message has not been tampered with during transmission is just as important as keeping its contents confidential. One of the most effective tools for verifying message integrity and authenticity is HMAC (Hash-based Message Authentication Code). In this blog post, we‚Äôll explore what HMAC is, why it matters, and how you can integrate it into your C applications using practical code examples.\nWhat Is HMAC? # HMAC is a mechanism for message authentication that uses cryptographic hash functions (such as SHA-256) along with a secret key. It produces a fixed-size output (the MAC) that is unique to both the message and the key. This signature helps recipients verify that the message hasn‚Äôt been altered and confirms the sender‚Äôs identity.\nKey aspects of HMAC include:\nMessage Integrity: Even a small change in the message results in a drastically different HMAC. Authentication: Only someone with the secret key can generate or verify the correct HMAC. Flexibility: It can work with various cryptographic hash functions, offering a balance between performance and security. Integrating HMAC in C # To integrate HMAC into your C programs, you can use the OpenSSL library, which provides robust cryptographic functions. Below is a simple example demonstrating how to compute an HMAC using the SHA-256 hash function.\nHMAC in C: Code Example\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/hmac.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; int main() { // Define a secret key and a message const char *key = \u0026#34;supersecretkey\u0026#34;; const char *message = \u0026#34;This is a test message for HMAC\u0026#34;; // Buffer for the HMAC digest unsigned char digest[EVP_MAX_MD_SIZE]; unsigned int digest_len = 0; // Compute the HMAC using SHA-256 HMAC(EVP_sha256(), key, strlen(key), (unsigned char*)message, strlen(message), digest, \u0026amp;digest_len); // Print the resulting HMAC in hexadecimal format printf(\u0026#34;HMAC (SHA-256): \u0026#34;); for (unsigned int i = 0; i \u0026lt; digest_len; i++) { printf(\u0026#34;%02x\u0026#34;, digest[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Explanation of the Code: # Key \u0026amp; Message: The secret key and the message are defined as strings. Digest Buffer: A buffer is allocated to hold the HMAC result. EVP_MAX_MD_SIZE is used to ensure the buffer is large enough for any supported hash function. HMAC Calculation: The **HMAC( )**function from OpenSSL computes the HMAC using the SHA-256 hash algorithm. The result is stored in digest, and its length is updated in digest_len. Output: The resulting HMAC is printed in a hexadecimal format. How HMAC Enhances Message Integrity # HMAC ensures that:\nIntegrity Check: The recipient computes the HMAC over the received message using the same secret key. A mismatch indicates tampering. Authentication: Only someone with the secret key can produce a valid HMAC, thereby authenticating the sender. These properties make HMAC invaluable in secure communications, file transfers, and API request validations.\nBest Practices for Using HMAC # Secure Key Management: Always protect and manage your secret keys securely. Use Strong Hash Functions: SHA-256 or higher is recommended over older algorithms like MD5. Combine with Encryption: While HMAC verifies integrity, combining it with encryption ensures both confidentiality and integrity. Validate on Both Ends: Always verify the HMAC on the receiving end to detect any data corruption or tampering. Final Thoughts # Integrating HMAC for message integrity is a powerful addition to your security toolkit. It not only confirms that the message hasn‚Äôt been altered during transit but also authenticates its origin. By leveraging libraries like OpenSSL in your C applications, you can implement HMAC quickly and effectively, bolstering the security of your communications.\nWould you like to explore more advanced implementations, such as combining HMAC with encryption or error handling improvements in C? Feel free to reach out for further discussion!\n","date":"17 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/integrating-hmac/","section":"Blog","summary":"","title":"Securing Your Messages: Integrating HMAC for Message Integrity in C","type":"blog"},{"content":" Introduction # When it comes to protecting sensitive data, encryption plays a crucial role in modern security systems. One of the most popular modes of AES (Advanced Encryption Standard) is the CBC (Cipher Block Chaining) mode. In this blog, we‚Äôll explore how CBC works, why it‚Äôs essential, and how to implement it using C with practical code examples.\nWhat Is AES CBC Mode? # AES in Cipher Block Chaining (CBC) mode encrypts blocks of data by chaining them together. Each block of plaintext is XORed with the previous ciphertext block before being encrypted.\nThis process ensures that identical plaintext blocks produce different ciphertext blocks, enhancing security.\nKey Elements of CBC Mode:\nInitialization Vector (IV): A random block used for the first encryption step.\nChaining: Each encrypted block depends on the previous ciphertext block.\nWhy Use CBC Mode? # CBC mode offers several advantages:\nIncreased Security: Reduces the risk of pattern detection. Integrity Protection: Chaining ensures even small changes in plaintext affect multiple ciphertext blocks. However, it requires the same IV and key for decryption, which adds complexity to key management.\nAES Encryption in CBC Mode # (C Code Example)\nHere‚Äôs a simple implementation using OpenSSL‚Äôs AES functions:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; #include \u0026lt;openssl/rand.h\u0026gt; void encryptAES_CBC(const unsigned char *plaintext, unsigned char *ciphertext, const unsigned char *key, unsigned char *iv) { AES_KEY encryptKey; AES_set_encrypt_key(key, 128, \u0026amp;encryptKey); AES_cbc_encrypt(plaintext, ciphertext, strlen((const char *)plaintext), \u0026amp;encryptKey, iv, AES_ENCRYPT); } int main() { unsigned char key[16] = \u0026#34;mysecurekey12345\u0026#34;; unsigned char iv[AES_BLOCK_SIZE]; unsigned char plaintext[32] = \u0026#34;SensitiveDataForEncryption\u0026#34;; unsigned char ciphertext[32]; // Generate a random IV if (!RAND_bytes(iv, AES_BLOCK_SIZE)) { printf(\u0026#34;Error generating random IV\\n\u0026#34;); return 1; } encryptAES_CBC(plaintext, ciphertext, key, iv); printf(\u0026#34;Encrypted Ciphertext: \u0026#34;); for (int i = 0; i \u0026lt; sizeof(ciphertext); i++) { printf(\u0026#34;%02x \u0026#34;, ciphertext[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } How CBC Mode Works # Initialization Vector (IV): Used to XOR the first block of plaintext. Encryption: Each block of plaintext is XORed with the previous ciphertext block before encryption. Chaining: The output of each encrypted block feeds into the next block‚Äôs encryption step. AES Decryption in CBC Mode # (C Code Example)\nHere‚Äôs how to decrypt data encrypted in CBC mode:\nvoid decryptAES_CBC(const unsigned char *ciphertext, unsigned char *decryptedText, const unsigned char *key, unsigned char *iv) { AES_KEY decryptKey; AES_set_decrypt_key(key, 128, \u0026amp;decryptKey); AES_cbc_encrypt(ciphertext, decryptedText, strlen((const char *)ciphertext), \u0026amp;decryptKey, iv, AES_DECRYPT); } int main() { unsigned char key[16] = \u0026#34;mysecurekey12345\u0026#34;; unsigned char iv[AES_BLOCK_SIZE] = {0x00}; // Ensure the IV is the same as used in encryption unsigned char ciphertext[32] = {0x00}; // Provide actual encrypted data here unsigned char decryptedText[32]; decryptAES_CBC(ciphertext, decryptedText, key, iv); printf(\u0026#34;Decrypted Text: %s\\n\u0026#34;, decryptedText); return 0; } REMARK:\nIn OpenSSL, there is no separate function AES_cbc_decrypt( ) ‚Äî AES_cbc_encrypt( ) serves both encryption and decryption depending on the flag passed (AES_ENCRYPT or AES_DECRYPT). The function name might seem misleading, but it\u0026rsquo;s intentional.\nTo clarify, this line in the code:\nAES_cbc_encrypt(ciphertext, decryptedText, strlen((const char *)ciphertext), \u0026amp;decryptKey, iv, AES_DECRYPT); Key Points # AES_cbc_encrypt() handles both encryption and decryption. The flag AES_DECRYPT triggers decryption. The IV must match exactly what was used during encryption. Applications of AES CBC Mode # AES CBC mode is widely used in:\nSecure Communications: Encrypted VPN connections and TLS protocols File and Disk Encryption: Protecting data at rest Cryptographic Libraries: Implementing secure messaging systems Payment Systems: Securing financial transactions Limitations of CBC Mode # Despite its popularity, CBC mode has some limitations:\nIV Management: Using the same IV repeatedly weakens security. Padding Vulnerabilities: Poor padding schemes can introduce security flaws. Sequential Processing: Blocks must be processed in sequence, reducing parallelism. Best Practices for Secure AES CBC Implementation # Use Secure IVs: Always generate random IVs using secure methods like RAND_bytes( ). Protect Keys: Store and manage encryption keys securely. Use Padding Properly: Ensure correct padding schemes to avoid decryption errors. example of oracle padding Final Thoughts # AES in CBC mode is a powerful and versatile encryption method. By understanding its inner workings and implementing it securely, you can build robust systems to protect sensitive data.\n","date":"8 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/mastering-aes-in-cbc-mode/","section":"Blog","summary":"","title":"Mastering AES in CBC Mode: A Secure Approach to Encryption","type":"blog"},{"content":"","date":"7 February 2025","externalUrl":null,"permalink":"/tags/c/","section":"Tags","summary":"","title":"C","type":"tags"},{"content":" Introduction # In today‚Äôs digital world, data security is more critical than ever. Whether you‚Äôre shopping online or communicating confidential information, encryption plays a vital role in keeping your data safe. One of the most widely used encryption algorithms is AES (Advanced Encryption Standard), known for its speed and security.\nIn this post, we‚Äôll explore what AES is, why it matters, and how to implement it using C code.\nWhat Is AES Encryption? # AES (Advanced Encryption Standard) is a symmetric encryption algorithm, which means the same key is used for both encryption and decryption. Developed by Vincent Rijmen and Joan Daemen, AES was adopted by the U.S. government as the encryption standard in 2001 and remains a cornerstone of modern cryptographic security.\nAES supports three key lengths: 128, 192, and 256 bits, offering varying levels of security Simple AES Encryption in C (Pseudo-Implementation)\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; void encryptAES(const unsigned char *plaintext, const unsigned char *key, unsigned char *ciphertext) { AES_KEY encryptKey; AES_set_encrypt_key(key, 128, \u0026amp;encryptKey); AES_encrypt(plaintext, ciphertext, \u0026amp;encryptKey); } int main() { unsigned char key[16] = \u0026#34;mysecretkey12345\u0026#34;; unsigned char plaintext[16] = \u0026#34;HelloAESWorld!!\u0026#34;; unsigned char ciphertext[16]; encryptAES(plaintext, key, ciphertext); printf(\u0026#34;Encrypted Ciphertext: \u0026#34;); for (int i = 0; i \u0026lt; 16; i++) { printf(\u0026#34;%02x \u0026#34;, ciphertext[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Why Is AES Important? # AES has become the encryption standard for countless applications due to its:\nEfficiency: AES is fast, even on resource-constrained devices. Security: Resistant to all known practical attacks, including brute force. Versatility: Used for securing everything from file storage to communication protocols. AES Decryption Example in C # void decryptAES(const unsigned char *ciphertext, const unsigned char *key, unsigned char *decryptedText) { AES_KEY decryptKey; AES_set_decrypt_key(key, 128, \u0026amp;decryptKey); AES_decrypt(ciphertext, decryptedText, \u0026amp;decryptKey); } int main() { unsigned char key[16] = \u0026#34;mysecretkey12345\u0026#34;; unsigned char ciphertext[16] = {0xe2, 0x91, 0x3f, 0x5b, 0xa1, 0x71, 0xf4, 0x2e, 0x6d, 0x4e, 0xae, 0xfb, 0x72, 0xcd, 0xa5, 0x6a}; unsigned char decryptedText[16]; decryptAES(ciphertext, key, decryptedText); printf(\u0026#34;Decrypted Text: %s\\n\u0026#34;, decryptedText); return 0; } How AES Works: # AES operates on blocks of 128 bits and transforms plaintext into ciphertext through multiple rounds of processing. Each round involves:\nSubBytes: Non-linear substitution of bytes using an S-Box. ShiftRows: Row shifting for diffusion. MixColumns: Mixing bytes for further diffusion (except in the final round). AddRoundKey: XOR operation between the block and a round key. Key Schedule in AES # (Round Key Generation)\n#include \u0026lt;openssl/aes.h\u0026gt; void displayRoundKey(const unsigned char *key) { for (int i = 0; i \u0026lt; AES_BLOCK_SIZE; i++) { printf(\u0026#34;%02x \u0026#34;, key[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { unsigned char key[16] = \u0026#34;testkeyforround\u0026#34;; unsigned char roundKey[AES_BLOCK_SIZE]; AES_KEY aesKey; AES_set_encrypt_key(key, 128, \u0026amp;aesKey); for (int i = 0; i \u0026lt; 11; i++) { printf(\u0026#34;Round %d Key: \u0026#34;, i); displayRoundKey((unsigned char *)\u0026amp;aesKey.rd_key[i * 4]); } return 0; } Applications of AES # AES is widely used across industries and applications, including:\nSecure Communications: Protecting data over TLS and VPNs File Encryption: Keeping sensitive information secure in storage Wireless Security: Protecting Wi-Fi networks through WPA2 Cryptocurrencies: Securing blockchain transactions The Future of AES Encryption # While AES remains one of the most secure algorithms available, emerging technologies like quantum computing present potential threats. Post-quantum cryptography aims to develop encryption algorithms resistant to quantum attacks.\nFinal Thoughts # AES is a critical tool in modern cybersecurity. Understanding how it works and implementing it in code is essential for anyone interested in cryptography or secure software development.\n","date":"7 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/demystifying-aes-cipher-encryption/","section":"Blog","summary":"","title":"Demystifying AES Cipher Encryption: A Comprehensive Guide","type":"blog"},{"content":"","date":"7 February 2025","externalUrl":null,"permalink":"/blog/programming/","section":"Blog","summary":"","title":"Programming","type":"blog"},{"content":"","date":"7 February 2025","externalUrl":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":" Introduction # scanf family functions support scanset specifiers which are represented by %[]. Inside scanset, we can specify single character or range of characters. While processing scanset, scanf will process only those characters which are part of scanset. We can define scanset by putting characters inside square brackets. Please note that the scansets are case-sensitive.\nWe can also use scanset by providing comma in between the character you want to add.\nexample: scanf(%s[A-Z,_,a,b,c]s,str);\nThis will scan all the specified character in the scanset.\nLet us see with example. Below example will store only capital letters to character array ‚Äòstr‚Äô, any other character will not be stored inside character array. /* A simple scanset example */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str[128]; printf(\u0026#34;Enter a string: \u0026#34;); scanf(\u0026#34;%[A-Z]s\u0026#34;, str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } Output:\n[root@centos-6 C]# ./scan-set Enter a string: DEADs_pro_gramming You entered: DEAD If first character of scanset is ‚Äò^‚Äô, then the specifier will stop reading after first occurrence of that character. For example, given below scanset will read all characters but stops after first occurrence of ‚Äòo‚Äô scanf(\u0026#34;%[^o]s\u0026#34;, str); Let us see with example:\n/* Another scanset example with ^ */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str[128]; printf(\u0026#34;Enter a string: \u0026#34;); scanf(\u0026#34;%[^o]s\u0026#34;, str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } Output:\n[root@centos-6 C]# ./scan-set Enter a string: http://deads programming You entered: http://deads pr [root@centos-6 C]# Let us implement gets() function by using scan set. gets() function reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF found. /* implementation of gets() function using scanset */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str[128]; printf(\u0026#34;Enter a string with spaces: \u0026#34;); scanf(\u0026#34;%[^\\n]s\u0026#34;, str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } Output:\n[root@centos-6 C]# ./gets Enter a string with spaces: Deads Programming You entered: Deads Programming [root@centos-6 C]# As a side note, using gets() may not be a good idea in general. Check below note from Linux man page. Never use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security. Use fgets() instead. Also see this post.\n","date":"7 February 2025","externalUrl":null,"permalink":"/blog/programming/scansets-in-c/","section":"Blog","summary":"","title":"Scansets in C","type":"blog"},{"content":" Introduction # In C programming, format specifiers are used to inform the compiler about the type of data to be printed or read during input and output operations. These specifiers always begin with a % symbol and are used in functions like printf(), scanf(), and sprintf().\nEach format specifier corresponds to a specific data type, such as %d for integers and %c for characters. This guide will cover some of the most commonly used format specifiers and their practical applications.\nList of Format Specifiers # The below table contains the most commonly used format specifiers in C\nExamples of Format Specifiers # Character Format Specifier # The %c is the format specifier for the char data type in C language. It can be used for both formatted input and formatted output in C language.\nSyntax:\nscanf(\u0026#34;%c...\u0026#34;, ...); printf(\u0026#34;%c...\u0026#34;, ...); Example:\n// C Program to illustrate the %c format specifier. #include \u0026lt;stdio.h\u0026gt; int main() { char c; // using %c for character input scanf(\u0026#34;Enter some character: %c\u0026#34;, \u0026amp;c); // using %c for character output printf(\u0026#34;The entered character: %c\u0026#34;, \u0026amp;c); return 0; } Input:\nEnter some character: A Output:\nThe entered character: A Integer Format Specifier (signed) # We can use the signed integer format specifier %d in the scanf() and print() functions or other functions that use formatted string for input and output of int data type.\nSyntax:\nscanf(\u0026#34;%d...\u0026#34;, ...); printf(\u0026#34;%i...\u0026#34;, ...); Example:\n// C Program to demonstrate the use of %d and %i #include \u0026lt;stdio.h\u0026gt; // Driver code int main() { int x; // taking integer input scanf(\u0026#34;Enter the two integers: %d\u0026#34;, \u0026amp;x); // printing integer output printf(\u0026#34;Printed using %%d: %d\\n\u0026#34;, x); printf(\u0026#34;Printed using %%i: %3i\\n\u0026#34;, x); return 0; } Input:\nEnter the integer: 21 Output:\nPrinted using %d: 21 Printed using %i: 21 Unsigned Integer Format Specifier # The %u is the format specifier for the unsigned integer data type. If we specify a negative integer value to the %u, it converts the integer to its 2‚Äôs complement.\nSyntax:\nprintf(\u0026#34;%u...\u0026#34;, ...); scanf(\u0026#34;%u...\u0026#34;, ...); Example:\n// C Program to illustrate the how to use %u #include \u0026lt;stdio.h\u0026gt; int main() { unsigned int var; scanf(\u0026#34;Enter an integer: %u\u0026#34;, \u0026amp;var); printf(\u0026#34;Entered Unsigned Integer: %u\u0026#34;, var); // trying to print negative value using %u printf(\u0026#34;Printing -10 using %%u: %u\\n\u0026#34;, -10); return 0; } Input:\nEnter an integer: 25 Output:\nEntered unsigned integer: 25 Printing -10 using %u: 4294967286 Floating-point format specifier # The %f is the floating point format specifier in C language that can be used inside the formatted string for input and output of float data type. Apart from %f, we can use %e or %E format specifiers to print the floating point value in the exponential form.\nSyntax:\nprintf(\u0026#34;%f...\u0026#34;, ...); scanf(\u0026#34;%e...\u0026#34;, ...); printf(\u0026#34;%E...\u0026#34;, ...); Example:\n// C program to demonstrate the use of %f, %e and %E #include \u0026lt;stdio.h\u0026gt; // driver code int main() { float a = 12.67; printf(\u0026#34;Using %%f: %f\\n\u0026#34;, a); printf(\u0026#34;Using %%e: %e\\n\u0026#34;, a); printf(\u0026#34;Using %%E, %E\u0026#34;, a); return 0; } Output:\nUsing %f: 12.670000 Using %e: 1.267000e+01 Using %E, 1.267000E+01 Unsigned Octal number for integer # We can use the %o format specifier in the C program to print or take input for the unsigned octal integer number.\nSyntax:\nprintf(\u0026#34;%o...\u0026#34;, ...); scanf(\u0026#34;%o...\u0026#34;, ...); Example:\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 67; printf(\u0026#34;%o\\n\u0026#34;, a); return 0; } Output:\n103 Unsigned Hexadecimal for integer # The %x format specifier is used in the formatted string for hexadecimal integers. In this case, the alphabets in the hexadecimal numbers will be in lowercase. For uppercase alphabet digits, we use %X instead.\nSyntax:\nprintf(\u0026#34;%x...\u0026#34;, ...); scanf(\u0026#34;%X...\u0026#34;, ...); Example:\n// C Program to demonstrate the use of %x and %X #include \u0026lt;stdio.h\u0026gt; int main() { int a = 15454; printf(\u0026#34;%x\\n\u0026#34;, a); printf(\u0026#34;%X\u0026#34;, a); return 0; } Output:\n3c5e 3C5E String Format Specifier # The %s in C is used to print strings or take strings as input.\nSyntax:\nprintf(\u0026#34;%s...\u0026#34;, ...); scanf(\u0026#34;%s...\u0026#34;, ...); Example:\n// C program to illustrate the use of %s in C #include \u0026lt;stdio.h\u0026gt; int main() { char a[] = \u0026#34;Hi Guys\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, a); return 0; } Output:\nHi Guys Example: The working of %s with scanf() is a little bit different from its working with printf(). Let‚Äôs understand this with the help of the following C program. // C Program to illustrate the working of %s with scanf() #include \u0026lt;stdio.h\u0026gt; int main() { char str[50]; // taking string as input scanf(\u0026#34;Enter the String: %s\u0026#34;, str); printf(\u0026#34;Entered String: %s\u0026#34;, str); return 0; } Input:\nEnter the string: Hi Guys Output:\nHi As we can see, the string is only scanned till a whitespace is encountered. We can avoid that by using scansets in C.\nAddress Format Specifier # The C language also provides the format specifier to print the address/pointers. We can use %p to print addresses and pointers in C\nSyntax:\nprintf(\u0026#34;%p...\u0026#34;, ...); Example:\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; printf(\u0026#34;The Memory Address of a: %p\\n\u0026#34;,(void*)\u0026amp;a); return 0; } Output:\nThe Memory Address of a: 0x7ffe9645b3fc Input and Output Formatting # C language provides some tools using which we can format the input and output. They are generally inserted between the % sign and the format specifier symbol Some of them are as follows:\nA minus(-) sign tells left alignment. A number after % specifies the minimum field width to be printed if the characters are less than the size of the width the remaining space is filled with space and if it is greater then it is printed as it is without truncation. A period( . ) symbol separates field width with precision. Precision tells the minimum number of digits in an integer, the maximum number of characters in a string, and the number of digits after the decimal part in a floating value. Example of I/O Formatting # // C Program to demonstrate the formatting methods. #include \u0026lt;stdio.h\u0026gt; int main() { char str[] = \u0026#34;unlimitedcodes\u0026#34;; printf(\u0026#34;%20s\\n\u0026#34;, str); printf(\u0026#34;%-20s\\n\u0026#34;, str); printf(\u0026#34;%20.5s\\n\u0026#34;, str); printf(\u0026#34;%-20.5s\\n\u0026#34;, str); return 0; } Output:\nunlimitedcodes unlimitedcodes unlim unlim Common Questions # Does C have a format specifier for binary numbers?\nNo, the C language does not provide a format specifier for binary numbers. What is the formatted string?\nThe input and output functions in C take a string as an argument that decides how the data is displayed on the screen or the data is retrieved to the memory. This string is called the formatted string. ","date":"6 February 2025","externalUrl":null,"permalink":"/blog/programming/format-specifiers-in-c/","section":"Blog","summary":"","title":"Format Specifiers in C","type":"blog"},{"content":"BUFFER OVERFLOW Consider the below program.\nvoid read() { char str[20]; gets(str); printf(\u0026#34;%s\u0026#34;, str); return; } The code looks simple, it reads string from standard input and prints the entered string, but it suffers from Buffer Overflow as gets() doesn‚Äôt do any array bound testing. gets() keeps on reading until it sees a newline character. To avoid Buffer Overflow, fgets() should be used instead of gets() as fgets() makes sure that not more than MAX_LIMIT characters are read.\n#define MAX_LIMIT 20 void read() { char str[MAX_LIMIT]; fgets(str, MAX_LIMIT, stdin); printf(\u0026#34;%s\u0026#34;, str); getchar(); return; } NOTE: fgets() stores the ‚Äò\\n‚Äô character if it is read, so removing that has to be done explicitly by the programmer. It is hence, generally advised that your str can store at least (MAX_LIMIT + 1) characters if your intention is to keep the newline character. This is done so there is enough space for the null terminating character ‚Äò\\0‚Äô to be added at the end of the string.\nIf keeping the newline character is not intended, then one can simply do the following: int len = strlen(str); // Remove the \u0026#39;\\n\u0026#39; character and replace it with \u0026#39;\\0\u0026#39; str[len - 1] = \u0026#39;\\0\u0026#39;; ","date":"6 February 2025","externalUrl":null,"permalink":"/blog/programming/gets-is-risky-to-use/","section":"Blog","summary":"","title":"gets() is risky to use!","type":"blog"},{"content":" Introduction # char is the most basic data type in C. It stores a single character and requires a single byte of memory in almost all compilers.\nNow character datatype can be divided into 2 types:\nsigned char\nunsigned char\nunsigned char # unsigned char is a character datatype where the variable consumes all the 8 bits of the memory and there is no sign bit (which is there in signed char). So it means that the range of unsigned char data type ranges from 0 to 255. Syntax:\nunsigned char [variable_name] = [value] Example:\nunsigned char ch = \u0026#39;a\u0026#39;; Initializing an unsigned char # Initializing an unsigned char: Here we try to insert a char in the unsigned char variable with the help of ASCII value. So the ASCII value 97 will be converted to a character value, i.e. ‚Äòa‚Äô and it will be inserted in unsigned char. // C program to show unsigned char #include \u0026lt;stdio.h\u0026gt; int main() { int chr = 97; unsigned char i = chr; printf(\u0026#34;unsigned char: %c\\n\u0026#34;, i); return 0; } Output:\nunsigned char: a Initializing an unsigned char with signed value: Here we try to insert a char in the unsigned char variable with the help of ASCII value. So the ASCII value -1 will be first converted to a range 0‚Äì255 by rounding. So it will be 255. Now, this value will be converted to a character value, i.e. ‚Äò√ø‚Äô and it will be inserted in unsigned char. // C program to show unsigned char #include \u0026lt;stdio.h\u0026gt; int main() { int chr = -1; unsigned char i = chr; printf(\u0026#34;unsigned char: %c\\n\u0026#34;, i); return 0; } Output:\nunsigned char: √ø ","date":"5 February 2025","externalUrl":null,"permalink":"/blog/programming/unsigned-char-in-c-with-examples/","section":"Blog","summary":"","title":"Unsigned char in C with Examples","type":"blog"},{"content":" Introduction # In an increasingly digital world, protecting information has never been more critical. One of the oldest and most effective ways to secure data is through ciphering \u0026mdash; the process of converting plain information into unreadable text using cryptographic techniques. In this post, we\u0026rsquo;ll explore the basics of ciphering, its historical significance, and its modern applications, complete with C code examples.\nWhat Is Ciphering? # Ciphering is the process of transforming readable information (plaintext) into an encoded format (ciphertext) to protect it from unauthorized access.\nBelow is a simple example in C that uses a basic substitution cipher to encrypt a message by shifting each character: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void encryptMessage(char *message, int shift) { for (int i = 0; i \u0026lt; strlen(message); i++) { if (message[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; message[i] \u0026lt;= \u0026#39;Z\u0026#39;) { message[i] = ((message[i] - \u0026#39;A\u0026#39; + shift) % 26) + \u0026#39;A\u0026#39;; } else if (message[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; message[i] \u0026lt;= \u0026#39;z\u0026#39;) { message[i] = ((message[i] - \u0026#39;a\u0026#39; + shift) % 26) + \u0026#39;a\u0026#39;; } } } int main() { char message[] = \u0026#34;HelloWorld\u0026#34;; int shift = 3; encryptMessage(message, shift); printf(\u0026#34;Encrypted Message: %s\\n\u0026#34;, message); return 0; } Classic Example: Caesar Cipher in C # Here‚Äôs a practical implementation of the classic Caesar cipher:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void caesarCipher(char *text, int shift) { for (int i = 0; i \u0026lt; strlen(text); i++) { if (text[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; text[i] \u0026lt;= \u0026#39;Z\u0026#39;) { text[i] = ((text[i] - \u0026#39;A\u0026#39; + shift) % 26) + \u0026#39;A\u0026#39;; } else if (text[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; text[i] \u0026lt;= \u0026#39;z\u0026#39;) { text[i] = ((text[i] - \u0026#39;a\u0026#39; + shift) % 26) + \u0026#39;a\u0026#39;; } } } int main() { char text[] = \u0026#34;SimpleText\u0026#34;; int shift = 5; caesarCipher(text, shift); printf(\u0026#34;Encrypted Caesar Cipher: %s\\n\u0026#34;, text); return 0; } Types of Ciphers # Substitution Cipher # #include \u0026lt;stdio.h\u0026gt; void simpleSubstitution(char *text) { for (int i = 0; text[i] != \u0026#39;\\0\u0026#39;; i++) { text[i] ^= 0x20; } } int main() { char text[] = \u0026#34;HelloCipher\u0026#34;; simpleSubstitution(text); printf(\u0026#34;After Substitution Cipher: %s\\n\u0026#34;, text); return 0; } Transposition Cipher # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void reverseCipher(char *text) { int len = strlen(text); for (int i = 0; i \u0026lt; len / 2; i++) { char temp = text[i]; text[i] = text[len - i - 1]; text[len - i - 1] = temp; } } int main() { char text[] = \u0026#34;CipherExample\u0026#34;; reverseCipher(text); printf(\u0026#34;Transposition Cipher: %s\\n\u0026#34;, text); return 0; } Importance of Ciphering # Ciphering ensures secure communication by making messages unreadable to unauthorized parties.\nHere‚Äôs an example using an XOR-based cipher in C:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void xorCipher(char *text, char key) { for (int i = 0; i \u0026lt; strlen(text); i++) { text[i] ^= key; } } int main() { char text[] = \u0026#34;SensitiveData\u0026#34;; char key = \u0026#39;K\u0026#39;; xorCipher(text, key); printf(\u0026#34;Ciphered Text: %s\\n\u0026#34;, text); xorCipher(text, key); printf(\u0026#34;Deciphered Text: %s\\n\u0026#34;, text); return 0; } Applications of Ciphering # One basic example is simple password hashing using bitwise operations in C:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned int hashPassword(char *password) { unsigned int hash = 0; for (int i = 0; i \u0026lt; strlen(password); i++) { hash = (hash \u0026lt;\u0026lt; 5) + password[i]; } return hash; } int main() { char password[] = \u0026#34;MySecurePassword\u0026#34;; unsigned int hash = hashPassword(password); printf(\u0026#34;Password Hash: %u\\n\u0026#34;, hash); return 0; } Ciphering is fundamental to many areas of cybersecurity, ensuring confidentiality, integrity, and privacy in data transmission and storage.\nThe Future of Ciphering # As technology evolves, the need for more advanced cryptographic techniques becomes evident. Quantum-resistant algorithms are becoming increasingly important. While such advanced methods are beyond what simple C code can demonstrate, staying informed is essential. ","date":"4 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/unlocking-the-secrets-of-ciphering/","section":"Blog","summary":"","title":"Unlocking the Secrets of Ciphering: A Beginner‚Äôs Guide to Cryptography","type":"blog"},{"content":" WHOAMI # Hello everyone, I\u0026rsquo;m Mazen Elheni, AKA Deadnaut, a Tunisian, 21 yo, Computer Science student at ISSATSO.\nI\u0026rsquo;m a CTF player with Phr34k$ üêß and technical team member at CyberTrace.\nI mainly play Cryptography, but I also dabble in Reverse Engineering and Forensics challenges.\nThis blog contains writeups of the challenges I play or author and also my inside thoughts in cybersecurity fields.\nCVEs # No public ones yet üò≠\nINTERESTS # Cryptography got boring, so I\u0026rsquo;m exploring these topics:\nPenetration testing (currently studying the OSCP) Malware development (still reading DOCS, haven\u0026rsquo;t started yet) Red teaming Kernel exploitation (currently exploring the Linux kernel) Browser exploitation (very interesting, still noob tho) Goals # I aim to contribute to innovative security projects and collaborate with like-minded professionals, working to build secure and resilient digital environments.\n","externalUrl":null,"permalink":"/about/","section":"About","summary":"","title":"About","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/ctfs/","section":"CTFs","summary":"","title":"CTFs","type":"ctfs"},{"content":"","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"You can view or download my resume below:\nDownload Resume (PDF)\n","externalUrl":null,"permalink":"/resume/","section":"Resume","summary":"","title":"Resume","type":"resume"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"}]